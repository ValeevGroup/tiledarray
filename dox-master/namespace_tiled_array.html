<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.20"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>TiledArray: TiledArray Namespace Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
        <script type="text/javascript" src="jquery.smartmenus.js"></script>
        <!-- SmartMenus jQuery Bootstrap Addon -->
        <script type="text/javascript" src="jquery.smartmenus.bootstrap.js"></script>
        <!-- SmartMenus jQuery plugin -->
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">TiledArray 1.0.0</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="userguide.html"><span>User&#160;Guide</span></a></li>
      <li><a href="usergroup0.html"><span>Programmer&#160;Guides</span></a></li>
      <li class="current"><a href="usergroup1.html"><span>Source&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">TiledArray Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_tiled_array_1_1container"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1container.html">container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_tiled_array_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_tiled_array_1_1eigen"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1eigen.html">eigen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_tiled_array_1_1expressions"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1expressions.html">expressions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_tiled_array_1_1math"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1math.html">math</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_tiled_array_1_1meta"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1meta.html">meta</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_tiled_array_1_1symmetry"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1symmetry.html">symmetry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_tiled_array_1_1tile__interface"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1tile__interface.html">tile_interface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_abs_max_reduction.html">AbsMaxReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maxabs tile reduction.  <a href="class_tiled_array_1_1_abs_max_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_abs_min_reduction.html">AbsMinReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minabs tile reduction.  <a href="class_tiled_array_1_1_abs_min_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_add.html">Add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> tile operation.  <a href="class_tiled_array_1_1_add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_add_to.html">AddTo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add-to tile operation.  <a href="class_tiled_array_1_1_add_to.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_bipartite_permutation.html">BipartitePermutation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permutation.html" title="Permutation of a sequence of objects indexed by base-0 indices.">Permutation</a> of a bipartite set.  <a href="class_tiled_array_1_1_bipartite_permutation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a> that references a subblock of another range.  <a href="class_tiled_array_1_1_block_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_cast.html">Cast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> cast operation.  <a href="class_tiled_array_1_1_cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1_cast_3_01_tiled_array_1_1_tensor_3_01_t_00_01_allocator_01_4_00_01btas_1_4609707baf645f507ebd5df14a7b8d69.html">Cast&lt; TiledArray::Tensor&lt; T, Allocator &gt;, btas::Tensor&lt; T, Range_, Storage &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a btas::Tensor to a <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">TiledArray::Tensor</a>  <a href="struct_tiled_array_1_1_cast_3_01_tiled_array_1_1_tensor_3_01_t_00_01_allocator_01_4_00_01btas_1_4609707baf645f507ebd5df14a7b8d69.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1_cast_3_01_tiled_array_1_1_tensor_3_01typename_01_t_1_1value__type_00_01_ab7001ff37fb22896f53384c5970c0ec3.html">Cast&lt; TiledArray::Tensor&lt; typename T::value_type, Allocator &gt;, Tile&lt; T &gt;, std::void_t&lt; decltype(std::declval&lt; TiledArray::Cast&lt; TiledArray::Tensor&lt; typename T::value_type, Allocator &gt;, T &gt;&gt;()(std::declval&lt; const T &amp; &gt;()))&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_clone.html">Clone</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a deep copy of a tile.  <a href="class_tiled_array_1_1_clone.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1clone__trait.html">clone_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_clone.html" title="Create a deep copy of a tile.">Clone</a> trait.  <a href="struct_tiled_array_1_1clone__trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1cpu__cuda__vector.html">cpu_cuda_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a vector that lives on either host or device side, or both  <a href="class_tiled_array_1_1cpu__cuda__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_debugger.html">Debugger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_dense_shape.html">DenseShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense shape of an array.  <a href="class_tiled_array_1_1_dense_shape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declarations.  <a href="class_tiled_array_1_1_dist_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_dot_reduction.html">DotReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector dot product tile reduction.  <a href="class_tiled_array_1_1_dot_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1eval__trait.html">eval_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the object type used in the evaluation of tensor expressions.  <a href="struct_tiled_array_1_1eval__trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_exception.html">Exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1function__ref.html">function_ref</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1function__ref_3_01_r_07_args_8_8_8_08_4.html">function_ref&lt; R(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for function types.  <a href="class_tiled_array_1_1function__ref_3_01_r_07_args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1_initializer_list_rank.html">InitializerListRank</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template for determining how many nested std::initializer_list's are in a type.  <a href="struct_tiled_array_1_1_initializer_list_rank.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1_initializer_list_rank_3_01std_1_1initializer__list_3_01_t_01_4_00_01_size_type_01_4.html">InitializerListRank&lt; std::initializer_list&lt; T &gt;, SizeType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="struct_tiled_array_1_1_initializer_list_rank.html" title="Primary template for determining how many nested std::initializer_list&#39;s are in a type.">InitializerListRank</a> used when the template type parameter is a std::initializer_list type.  <a href="struct_tiled_array_1_1_initializer_list_rank_3_01std_1_1initializer__list_3_01_t_01_4_00_01_size_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_inner_product_reduction.html">InnerProductReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector inner product tile reduction.  <a href="class_tiled_array_1_1_inner_product_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_irrep.html">Irrep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_irrep.html" title="Irrep of an  symmetric group.">Irrep</a> of an <img class="formulaInl" alt="$ S_n $" src="form_72.png"/> symmetric group.  <a href="class_tiled_array_1_1_irrep.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1is__consumable__tile.html">is_consumable_tile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumable tile type trait.  <a href="struct_tiled_array_1_1is__consumable__tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1is__consumable__tile_3_01_zero_tensor_01_4.html">is_consumable_tile&lt; ZeroTensor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1is__dense.html">is_dense</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect dense shape types.  <a href="struct_tiled_array_1_1is__dense.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1is__dense_3_01_dense_policy_01_4.html">is_dense&lt; DensePolicy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1is__dense_3_01_dense_shape_01_4.html">is_dense&lt; DenseShape &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1is__dense_3_01_dist_array_3_01_tile_00_01_policy_01_4_01_4.html">is_dense&lt; DistArray&lt; Tile, Policy &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1is__lazy__tile.html">is_lazy_tile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect lazy evaluation tiles.  <a href="struct_tiled_array_1_1is__lazy__tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1is__lazy__tile_3_01_dist_array_3_01_tile_00_01_policy_01_4_01_4.html">is_lazy_tile&lt; DistArray&lt; Tile, Policy &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_max_reduction.html">MaxReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum tile reduction.  <a href="class_tiled_array_1_1_max_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_max_reduction_3_01_tile_00_01typename_01std_1_1enable__if_3_01detail_1_1is72dbf640bf0586b2657ce5cdd9539f2d.html">MaxReduction&lt; Tile, typename std::enable_if&lt; detail::is_strictly_ordered&lt; detail::numeric_t&lt; Tile &gt; &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_min_reduction.html">MinReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum tile reduction.  <a href="class_tiled_array_1_1_min_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_min_reduction_3_01_tile_00_01typename_01std_1_1enable__if_3_01detail_1_1isbbf8cab6c762ebd87aacbfefa47f9cbf.html">MinReduction&lt; Tile, typename std::enable_if&lt; detail::is_strictly_ordered&lt; detail::numeric_t&lt; Tile &gt; &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permutation.html" title="Permutation of a sequence of objects indexed by base-0 indices.">Permutation</a> of a sequence of objects indexed by base-0 indices.  <a href="class_tiled_array_1_1_permutation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_permute.html">Permute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permute.html" title="Permute a tile.">Permute</a> a tile.  <a href="class_tiled_array_1_1_permute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1permute__trait.html">permute_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permute.html" title="Permute a tile.">Permute</a> trait.  <a href="struct_tiled_array_1_1permute__trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_pmap.html">Pmap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process map.  <a href="class_tiled_array_1_1_pmap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_product_reduction.html">ProductReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> product reduction.  <a href="class_tiled_array_1_1_product_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (hyperrectangular) interval on <img class="formulaInl" alt="$ Z^n $" src="form_60.png"/>, space of integer <img class="formulaInl" alt="$ n $" src="form_61.png"/>-indices.  <a href="class_tiled_array_1_1_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_scal_add.html">ScalAdd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> tile operation.  <a href="class_tiled_array_1_1_scal_add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_scal_add_to.html">ScalAddTo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add-to and scale tile operation.  <a href="class_tiled_array_1_1_scal_add_to.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_scale.html">Scale</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile.">Scale</a> tile.  <a href="class_tiled_array_1_1_scale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1scale__trait.html">scale_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile.">Scale</a> trait.  <a href="struct_tiled_array_1_1scale__trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1shared__function.html">shared_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">analogous to std::function, but has shallow-copy semantics  <a href="class_tiled_array_1_1shared__function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_shift.html">Shift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> the range of tile.  <a href="class_tiled_array_1_1_shift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_shift_to.html">ShiftTo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> the range of tile in place.  <a href="class_tiled_array_1_1_shift_to.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_singleton.html">Singleton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_singleton.html" title="Singleton base class To create a singleton class A do:">Singleton</a> base class To create a singleton class <code>A</code> do:  <a href="class_tiled_array_1_1_singleton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_sparse_shape.html">SparseShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frobenius-norm-based sparse shape.  <a href="class_tiled_array_1_1_sparse_shape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_squared_norm_reduction.html">SquaredNormReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squared norm tile reduction.  <a href="class_tiled_array_1_1_squared_norm_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_sum_reduction.html">SumReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> sum reduction.  <a href="class_tiled_array_1_1_sum_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An N-dimensional tensor object.  <a href="class_tiled_array_1_1_tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An N-dimensional shallow copy wrapper for tile objects.  <a href="class_tiled_array_1_1_tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a> data of a tiled array.  <a href="class_tiled_array_1_1_tiled_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1_tile_ops_logger.html">TileOpsLogger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_trace_reduction.html">TraceReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> trace reduction.  <a href="class_tiled_array_1_1_trace_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1_zero_tensor.html">ZeroTensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place-holder object for a zero tensor.  <a href="struct_tiled_array_1_1_zero_tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac5db88c965b8d32f1f72d37d3dc3561c"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac5db88c965b8d32f1f72d37d3dc3561c">EigenMatrixXd</a></td></tr>
<tr class="separator:ac5db88c965b8d32f1f72d37d3dc3561c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdf44d8771941244661bf77cf07069e"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aacdf44d8771941244661bf77cf07069e">EigenMatrixXf</a></td></tr>
<tr class="separator:aacdf44d8771941244661bf77cf07069e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598c53efb66f9c18b8a6b5bcfbeaf8f3"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; std::complex&lt; double &gt;, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a598c53efb66f9c18b8a6b5bcfbeaf8f3">EigenMatrixXcd</a></td></tr>
<tr class="separator:a598c53efb66f9c18b8a6b5bcfbeaf8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde89f3f1e4ba23ddf9ce7b6e2db088f"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; std::complex&lt; float &gt;, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#adde89f3f1e4ba23ddf9ce7b6e2db088f">EigenMatrixXcf</a></td></tr>
<tr class="separator:adde89f3f1e4ba23ddf9ce7b6e2db088f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d1d4be6c1d3cef049c42490778da56"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; int, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ae5d1d4be6c1d3cef049c42490778da56">EigenMatrixXi</a></td></tr>
<tr class="separator:ae5d1d4be6c1d3cef049c42490778da56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa83a358322961f1da1b50d5e28ae0ea"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; long, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#afa83a358322961f1da1b50d5e28ae0ea">EigenMatrixXl</a></td></tr>
<tr class="separator:afa83a358322961f1da1b50d5e28ae0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa783ea4f581c1c1bb75f647d68c65a68"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa783ea4f581c1c1bb75f647d68c65a68">EigenVectorXd</a></td></tr>
<tr class="separator:aa783ea4f581c1c1bb75f647d68c65a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c54f8e9145825b6155cf5389a9ee03a"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; float, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a0c54f8e9145825b6155cf5389a9ee03a">EigenVectorXf</a></td></tr>
<tr class="separator:a0c54f8e9145825b6155cf5389a9ee03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c2ebf917a509ec12deca6a13dd1904"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; std::complex&lt; double &gt;, 1, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a19c2ebf917a509ec12deca6a13dd1904">EigenVectorXcd</a></td></tr>
<tr class="separator:a19c2ebf917a509ec12deca6a13dd1904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe17eddb0710849aa9af552f4f85098"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; std::complex&lt; float &gt;, 1, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#abfe17eddb0710849aa9af552f4f85098">EigenVectorXcf</a></td></tr>
<tr class="separator:abfe17eddb0710849aa9af552f4f85098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb38a6b56111826e5b451528b939eb60"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; int, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#acb38a6b56111826e5b451528b939eb60">EigenVectorXi</a></td></tr>
<tr class="separator:acb38a6b56111826e5b451528b939eb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5f429338b7707830ce0339ebaf6274"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; long, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aec5f429338b7707830ce0339ebaf6274">EigenVectorXl</a></td></tr>
<tr class="separator:aec5f429338b7707830ce0339ebaf6274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8bdb4a9d561d001f7a34f49c077a5c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_  = Range, typename OpResult  = Tensor&lt;T&gt;&gt; </td></tr>
<tr class="memitem:acf8bdb4a9d561d001f7a34f49c077a5c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#acf8bdb4a9d561d001f7a34f49c077a5c">TensorMap</a> = <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; T, Range_, OpResult &gt;</td></tr>
<tr class="separator:acf8bdb4a9d561d001f7a34f49c077a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362559c766dfbca887fc6dff5523fb3b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_  = Range, typename OpResult  = Tensor&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a362559c766dfbca887fc6dff5523fb3b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a362559c766dfbca887fc6dff5523fb3b">TensorConstMap</a> = <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; typename std::add_const&lt; T &gt;::type, Range_, OpResult &gt;</td></tr>
<tr class="separator:a362559c766dfbca887fc6dff5523fb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d2edc4ec73d986edc524386dab1f9c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59d2edc4ec73d986edc524386dab1f9c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a59d2edc4ec73d986edc524386dab1f9c">TensorView</a> = <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &gt;</td></tr>
<tr class="separator:a59d2edc4ec73d986edc524386dab1f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1950fa935cff5cb1415b58d822057f23"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1950fa935cff5cb1415b58d822057f23"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a1950fa935cff5cb1415b58d822057f23">TensorConstView</a> = <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; typename std::add_const&lt; T &gt;::type, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &gt;</td></tr>
<tr class="separator:a1950fa935cff5cb1415b58d822057f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670509be08925c46286e374cdeee130e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a670509be08925c46286e374cdeee130e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a670509be08925c46286e374cdeee130e">result_of_trace_t</a> = decltype(<a class="el" href="group___tile_interface.html#ga72bc37c3b1bcb1f5bb7f630667243615">trace</a>(std::declval&lt; T &gt;()))</td></tr>
<tr class="separator:a670509be08925c46286e374cdeee130e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0a15302527b61f10109a44e76ea62d2"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:gac0a15302527b61f10109a44e76ea62d2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gac0a15302527b61f10109a44e76ea62d2">result_of_subt_t</a> = decltype(<a class="el" href="group___tile_interface.html#ga58d10685bc8b980fed30a5e64db19caa">subt</a>(std::declval&lt; T &gt;()...))</td></tr>
<tr class="separator:gac0a15302527b61f10109a44e76ea62d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb597ee654962821e46fe67505d9d82e"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:gafb597ee654962821e46fe67505d9d82e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gafb597ee654962821e46fe67505d9d82e">result_of_subt_to_t</a> = decltype(<a class="el" href="group___tile_interface.html#ga67b0fd498d81c2a5898673bcb0152934">subt_to</a>(std::declval&lt; T &gt;()...))</td></tr>
<tr class="separator:gafb597ee654962821e46fe67505d9d82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16021b6394d1bf4cb669cd411f75f84c"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga16021b6394d1bf4cb669cd411f75f84c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga16021b6394d1bf4cb669cd411f75f84c">result_of_mult_t</a> = decltype(<a class="el" href="group___tile_interface.html#gaf465d9c7b7f7d31918a6150c9d51ca40">mult</a>(std::declval&lt; T &gt;()...))</td></tr>
<tr class="separator:ga16021b6394d1bf4cb669cd411f75f84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad69682934d9dd00448f43db07be177be"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:gad69682934d9dd00448f43db07be177be"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gad69682934d9dd00448f43db07be177be">result_of_mult_to_t</a> = decltype(<a class="el" href="group___tile_interface.html#gad37039529fef4c507e5e5ecf379edf38">mult_to</a>(std::declval&lt; T &gt;()...))</td></tr>
<tr class="separator:gad69682934d9dd00448f43db07be177be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f7c9af01701a7e404eea1297ea0a593"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga9f7c9af01701a7e404eea1297ea0a593"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga9f7c9af01701a7e404eea1297ea0a593">result_of_binary_t</a> = decltype(<a class="el" href="group___tile_interface.html#ga4eb0d0c051737f67276e03e895aefad9">binary</a>(std::declval&lt; T &gt;()...))</td></tr>
<tr class="separator:ga9f7c9af01701a7e404eea1297ea0a593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf019ef97799c508a579e2f562b8ef2a5"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:gaf019ef97799c508a579e2f562b8ef2a5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gaf019ef97799c508a579e2f562b8ef2a5">result_of_inplace_binary_t</a> = decltype(<a class="el" href="group___tile_interface.html#ga2dd0527cbaf5c320eb78d1f53711305b">inplace_binary</a>(std::declval&lt; T &gt;()...))</td></tr>
<tr class="separator:gaf019ef97799c508a579e2f562b8ef2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b695ca615c23ac38f3fcd53a905fc70"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga1b695ca615c23ac38f3fcd53a905fc70"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga1b695ca615c23ac38f3fcd53a905fc70">result_of_neg_t</a> = decltype(<a class="el" href="group___tile_interface.html#ga6bd5665b8e247cd53460501c3f672751">neg</a>(std::declval&lt; T &gt;()...))</td></tr>
<tr class="separator:ga1b695ca615c23ac38f3fcd53a905fc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a03566e3a493068e38d06c43cd4a8ab"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga3a03566e3a493068e38d06c43cd4a8ab"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga3a03566e3a493068e38d06c43cd4a8ab">result_of_neg_to_t</a> = decltype(<a class="el" href="group___tile_interface.html#ga7f07b2f0fde49f0f04284bc3f6de3db4">neg_to</a>(std::declval&lt; T &gt;()...))</td></tr>
<tr class="separator:ga3a03566e3a493068e38d06c43cd4a8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e359ae046dd03b00740c908258957dc"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga9e359ae046dd03b00740c908258957dc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga9e359ae046dd03b00740c908258957dc">result_of_conj_t</a> = decltype(<a class="el" href="group___tile_interface.html#ga4d7a9a1250ba51b27addd91171a1c77f">conj</a>(std::declval&lt; T &gt;()...))</td></tr>
<tr class="separator:ga9e359ae046dd03b00740c908258957dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf642faede431676d47b016bcf6a1fe6d"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:gaf642faede431676d47b016bcf6a1fe6d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gaf642faede431676d47b016bcf6a1fe6d">result_of_conj_to_t</a> = decltype(<a class="el" href="group___tile_interface.html#ga5d755d58b153633beaf43d985aa64081">conj_to</a>(std::declval&lt; T &gt;()...))</td></tr>
<tr class="separator:gaf642faede431676d47b016bcf6a1fe6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga468b9f978adc61edf721b5aa2ea9cadd"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga468b9f978adc61edf721b5aa2ea9cadd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga468b9f978adc61edf721b5aa2ea9cadd">result_of_unary_t</a> = decltype(<a class="el" href="group___tile_interface.html#ga547cfd18b8ef1453c69372f3fc121ba8">unary</a>(std::declval&lt; T &gt;()...))</td></tr>
<tr class="separator:ga468b9f978adc61edf721b5aa2ea9cadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab51ad824fc20a6f2a833a74def308ecb"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:gab51ad824fc20a6f2a833a74def308ecb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gab51ad824fc20a6f2a833a74def308ecb">result_of_inplace_unary_t</a> = decltype(<a class="el" href="group___tile_interface.html#gabb6941017c1cc6484e4321220ac1c40c">inplace_unary</a>(std::declval&lt; T &gt;()...))</td></tr>
<tr class="separator:gab51ad824fc20a6f2a833a74def308ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43a9dc9a0def7d24cb5d5d223e7773b5"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga43a9dc9a0def7d24cb5d5d223e7773b5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga43a9dc9a0def7d24cb5d5d223e7773b5">result_of_gemm_t</a> = decltype(<a class="el" href="group___tile_interface.html#ga1f3a08fa940b7d1c314327430c604238">gemm</a>(std::declval&lt; T &gt;()...))</td></tr>
<tr class="separator:ga43a9dc9a0def7d24cb5d5d223e7773b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9472ea3fc9c25a0df1ff1a8766de4a7e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9472ea3fc9c25a0df1ff1a8766de4a7e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga9472ea3fc9c25a0df1ff1a8766de4a7e">result_of_sum_t</a> = decltype(<a class="el" href="group___tile_interface.html#ga25d9a467ed3849aacaab335e5eb2ed57">sum</a>(std::declval&lt; T &gt;()))</td></tr>
<tr class="separator:ga9472ea3fc9c25a0df1ff1a8766de4a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99a39de86e7960d214f90d786236aed2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga99a39de86e7960d214f90d786236aed2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga99a39de86e7960d214f90d786236aed2">result_of_product_t</a> = decltype(<a class="el" href="group___tile_interface.html#gada89177095dd6a757f26e7c45f3798b0">product</a>(std::declval&lt; T &gt;()))</td></tr>
<tr class="separator:ga99a39de86e7960d214f90d786236aed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa99c917a22792c071cda35eea7c4b428"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa99c917a22792c071cda35eea7c4b428"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gaa99c917a22792c071cda35eea7c4b428">result_of_squared_norm_t</a> = decltype(<a class="el" href="namespace_tiled_array.html#a2208f3d88d7e5293d2fc6b1fc01768fd">squared_norm</a>(std::declval&lt; T &gt;()))</td></tr>
<tr class="separator:gaa99c917a22792c071cda35eea7c4b428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6543428aa95b988bc7f5b5af228481c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ResultType  = T&gt; </td></tr>
<tr class="memitem:gae6543428aa95b988bc7f5b5af228481c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gae6543428aa95b988bc7f5b5af228481c">result_of_norm_t</a> = decltype(<a class="el" href="group___tile_interface.html#gaf68ae245fa13091be35fcc8cad8b2ba6">norm</a>(std::declval&lt; T &gt;(), std::declval&lt; ResultType &amp; &gt;()))</td></tr>
<tr class="separator:gae6543428aa95b988bc7f5b5af228481c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1babce417d8aec558a5fdc279f597787"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1babce417d8aec558a5fdc279f597787"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga1babce417d8aec558a5fdc279f597787">result_of_max_t</a> = decltype(<a class="el" href="group___tile_interface.html#gace24afac354bfe849d2ca90df6ab8232">max</a>(std::declval&lt; T &gt;()))</td></tr>
<tr class="separator:ga1babce417d8aec558a5fdc279f597787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaa18ec76e56cfda0b79f797932c2825"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabaa18ec76e56cfda0b79f797932c2825"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gabaa18ec76e56cfda0b79f797932c2825">result_of_min_t</a> = decltype(<a class="el" href="group___tile_interface.html#gad4d977af50ab495f09a985dbfb871a3d">min</a>(std::declval&lt; T &gt;()))</td></tr>
<tr class="separator:gabaa18ec76e56cfda0b79f797932c2825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc6d1f58783873eada78cf1295a91ee1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gadc6d1f58783873eada78cf1295a91ee1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gadc6d1f58783873eada78cf1295a91ee1">result_of_abs_max_t</a> = decltype(<a class="el" href="namespace_tiled_array.html#a37032bc091e5e9452a6385ebbce0dc94">abs_max</a>(std::declval&lt; T &gt;()))</td></tr>
<tr class="separator:gadc6d1f58783873eada78cf1295a91ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga455f69411329a3f8e5019a2f6cfb5826"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga455f69411329a3f8e5019a2f6cfb5826"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga455f69411329a3f8e5019a2f6cfb5826">result_of_abs_min_t</a> = decltype(<a class="el" href="namespace_tiled_array.html#ad09edca89f7e0f6b29c03206118a9c49">abs_min</a>(std::declval&lt; T &gt;()))</td></tr>
<tr class="separator:ga455f69411329a3f8e5019a2f6cfb5826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f19ce3dee29789eb96536ff0e96d0ee"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga5f19ce3dee29789eb96536ff0e96d0ee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga5f19ce3dee29789eb96536ff0e96d0ee">result_of_dot_t</a> = decltype(<a class="el" href="namespace_tiled_array.html#a56e8a14dc06218506b921b90d86bf622">dot</a>(std::declval&lt; L &gt;(), std::declval&lt; R &gt;()))</td></tr>
<tr class="separator:ga5f19ce3dee29789eb96536ff0e96d0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073741f90126d4c17df3404a58f13fd4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a073741f90126d4c17df3404a58f13fd4">time_point</a> = std::chrono::high_resolution_clock::time_point</td></tr>
<tr class="separator:a073741f90126d4c17df3404a58f13fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a673c87e7624e63f641318f610a297"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; double, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac1a673c87e7624e63f641318f610a297">TensorD</a></td></tr>
<tr class="separator:ac1a673c87e7624e63f641318f610a297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f58ff1caa878600bc482e36acb64060"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; int, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a7f58ff1caa878600bc482e36acb64060">TensorI</a></td></tr>
<tr class="separator:a7f58ff1caa878600bc482e36acb64060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b4522d34881253139d842d7345dcbc"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; float, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a43b4522d34881253139d842d7345dcbc">TensorF</a></td></tr>
<tr class="separator:a43b4522d34881253139d842d7345dcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940148a41f1a9b47fabd83511d0ad11f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; long, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt; long &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a940148a41f1a9b47fabd83511d0ad11f">TensorL</a></td></tr>
<tr class="separator:a940148a41f1a9b47fabd83511d0ad11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4438e1e4fac9c7ed76af5bae4a6aff"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; std::complex&lt; double &gt;, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt; std::complex&lt; double &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#abe4438e1e4fac9c7ed76af5bae4a6aff">TensorZ</a></td></tr>
<tr class="separator:abe4438e1e4fac9c7ed76af5bae4a6aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac685ca67ab67879d908e57681834604c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; std::complex&lt; float &gt;, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt; std::complex&lt; float &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac685ca67ab67879d908e57681834604c">TensorC</a></td></tr>
<tr class="separator:ac685ca67ab67879d908e57681834604c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14381436074bbf8eff68427766e395a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a14381436074bbf8eff68427766e395a2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a> = <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt; T &gt; &gt;, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt;</td></tr>
<tr class="separator:a14381436074bbf8eff68427766e395a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b25748e8f1dd4d7421925264bbe4905"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a0b25748e8f1dd4d7421925264bbe4905">TArrayD</a></td></tr>
<tr class="separator:a0b25748e8f1dd4d7421925264bbe4905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6a345559008046e6785aee9d35f11d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a2d6a345559008046e6785aee9d35f11d">TArrayI</a></td></tr>
<tr class="separator:a2d6a345559008046e6785aee9d35f11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeec85e445a8f0330f135292858a3cb4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aaeec85e445a8f0330f135292858a3cb4">TArrayF</a></td></tr>
<tr class="separator:aaeec85e445a8f0330f135292858a3cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99743650f2570e83f35a0ba1958c9569"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a99743650f2570e83f35a0ba1958c9569">TArrayL</a></td></tr>
<tr class="separator:a99743650f2570e83f35a0ba1958c9569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa010edfe058bd83377e3790741e14dee"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa010edfe058bd83377e3790741e14dee">TArrayZ</a></td></tr>
<tr class="separator:aa010edfe058bd83377e3790741e14dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea17c71440d5a58110b7ade911cf1102"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt; std::complex&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aea17c71440d5a58110b7ade911cf1102">TArrayC</a></td></tr>
<tr class="separator:aea17c71440d5a58110b7ade911cf1102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0231c1beab8d7e7c31c19aeceede50fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0231c1beab8d7e7c31c19aeceede50fd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a> = <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt; T &gt; &gt;, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt;</td></tr>
<tr class="separator:a0231c1beab8d7e7c31c19aeceede50fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0c4ccd3689f4dafb20c6d238690705"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#abb0c4ccd3689f4dafb20c6d238690705">TSpArrayD</a></td></tr>
<tr class="separator:abb0c4ccd3689f4dafb20c6d238690705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd7da1c48d18d477b9d0366e94d9b10"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4dd7da1c48d18d477b9d0366e94d9b10">TSpArrayI</a></td></tr>
<tr class="separator:a4dd7da1c48d18d477b9d0366e94d9b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd8165f08a44cf5a27efca786bee5ac"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a6bd8165f08a44cf5a27efca786bee5ac">TSpArrayF</a></td></tr>
<tr class="separator:a6bd8165f08a44cf5a27efca786bee5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e13a617d7cc592f38124462d5a853d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a51e13a617d7cc592f38124462d5a853d">TSpArrayL</a></td></tr>
<tr class="separator:a51e13a617d7cc592f38124462d5a853d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa157a11e4eb462e70e5fec1411acab8c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa157a11e4eb462e70e5fec1411acab8c">TSpArrayZ</a></td></tr>
<tr class="separator:aa157a11e4eb462e70e5fec1411acab8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9caaa3d2c9f944690670df6a1a08ed"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt; std::complex&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#add9caaa3d2c9f944690670df6a1a08ed">TSpArrayC</a></td></tr>
<tr class="separator:add9caaa3d2c9f944690670df6a1a08ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf28ccfd580f62de5342a9a1510e22e9"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned int  = 0, typename Tile  = Tensor&lt;T, Eigen::aligned_allocator&lt;T&gt; &gt;, typename Policy  = DensePolicy&gt; </td></tr>
<tr class="memitem:adf28ccfd580f62de5342a9a1510e22e9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> = <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;</td></tr>
<tr class="separator:adf28ccfd580f62de5342a9a1510e22e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa1333af3bbdd6ac34ec64a4eef6e9e07"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07">ShapeReductionMethod</a> { <a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07aaef12e903e606a4895a16b393bfdec8c">ShapeReductionMethod::Union</a>, 
<a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07a6faa907d79c8bb46a12bea5c8de76654">ShapeReductionMethod::Intersect</a>
 }</td></tr>
<tr class="separator:aa1333af3bbdd6ac34ec64a4eef6e9e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075713b9b2f21c1f7a54361922ff9d13"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a075713b9b2f21c1f7a54361922ff9d13">MemorySpace</a> { <a class="el" href="namespace_tiled_array.html#a075713b9b2f21c1f7a54361922ff9d13abbb93ef26e3c101ff11cdd21cab08a94">MemorySpace::Null</a> = 0b00, 
<a class="el" href="namespace_tiled_array.html#a075713b9b2f21c1f7a54361922ff9d13a2b55387dd066c5bac646ac61543d152d">MemorySpace::CPU</a> = 0b01, 
<a class="el" href="namespace_tiled_array.html#a075713b9b2f21c1f7a54361922ff9d13aa33b7755e5f9b504d2d038eaca4ff28d">MemorySpace::CUDA</a> = 0b10, 
<a class="el" href="namespace_tiled_array.html#a075713b9b2f21c1f7a54361922ff9d13a8deda018646e16512ca30acee5c0d1f6">MemorySpace::CUDA_UM</a> = CPU | CUDA
 }</td></tr>
<tr class="memdesc:a075713b9b2f21c1f7a54361922ff9d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumerates the memory spaces  <a href="namespace_tiled_array.html#a075713b9b2f21c1f7a54361922ff9d13">More...</a><br /></td></tr>
<tr class="separator:a075713b9b2f21c1f7a54361922ff9d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259e0df1635b302bf4f6b15c354dd0ae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a259e0df1635b302bf4f6b15c354dd0ae">ExecutionSpace</a> { <a class="el" href="namespace_tiled_array.html#a259e0df1635b302bf4f6b15c354dd0aea2b55387dd066c5bac646ac61543d152d">ExecutionSpace::CPU</a>, 
<a class="el" href="namespace_tiled_array.html#a259e0df1635b302bf4f6b15c354dd0aeaa33b7755e5f9b504d2d038eaca4ff28d">ExecutionSpace::CUDA</a>
 }</td></tr>
<tr class="memdesc:a259e0df1635b302bf4f6b15c354dd0ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumerates the execution spaces  <a href="namespace_tiled_array.html#a259e0df1635b302bf4f6b15c354dd0ae">More...</a><br /></td></tr>
<tr class="separator:a259e0df1635b302bf4f6b15c354dd0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f64eadfb2120154cc1848d7fc02f66"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a89f64eadfb2120154cc1848d7fc02f66">OrdinalType</a> { <a class="el" href="namespace_tiled_array.html#a89f64eadfb2120154cc1848d7fc02f66abba47a7c03289a67ca347baa3f55be2f">OrdinalType::RowMajor</a> = -1, 
<a class="el" href="namespace_tiled_array.html#a89f64eadfb2120154cc1848d7fc02f66a9e91437ff30e153a77db79d1a362893a">OrdinalType::ColMajor</a> = 1, 
<a class="el" href="namespace_tiled_array.html#a89f64eadfb2120154cc1848d7fc02f66a6311ae17c1ee52b36e68aaf4ad066387">OrdinalType::Other</a> = 0, 
<a class="el" href="namespace_tiled_array.html#a89f64eadfb2120154cc1848d7fc02f66a4bbb8f967da6d1a610596d7257179c2b">OrdinalType::Invalid</a>
 }</td></tr>
<tr class="separator:a89f64eadfb2120154cc1848d7fc02f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad03979f84fd9f2823892518870a3c779"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ad03979f84fd9f2823892518870a3c779">is_congruent</a> (const <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &amp;r2)</td></tr>
<tr class="memdesc:ad03979f84fd9f2823892518870a3c779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that two <a class="el" href="class_tiled_array_1_1_block_range.html" title="Range that references a subblock of another range.">BlockRange</a> objects are congruent.  <a href="namespace_tiled_array.html#ad03979f84fd9f2823892518870a3c779">More...</a><br /></td></tr>
<tr class="separator:ad03979f84fd9f2823892518870a3c779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e14ddddf19c527c4f5625446721622"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ad2e14ddddf19c527c4f5625446721622">is_congruent</a> (const <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r2)</td></tr>
<tr class="memdesc:ad2e14ddddf19c527c4f5625446721622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that <a class="el" href="class_tiled_array_1_1_block_range.html" title="Range that references a subblock of another range.">BlockRange</a> and <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a> are congruent.  <a href="namespace_tiled_array.html#ad2e14ddddf19c527c4f5625446721622">More...</a><br /></td></tr>
<tr class="separator:ad2e14ddddf19c527c4f5625446721622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabeb45688b0531ba26077d27b7bcef6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aeabeb45688b0531ba26077d27b7bcef6">is_congruent</a> (const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &amp;r2)</td></tr>
<tr class="memdesc:aeabeb45688b0531ba26077d27b7bcef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a> and <a class="el" href="class_tiled_array_1_1_block_range.html" title="Range that references a subblock of another range.">BlockRange</a> are congruent.  <a href="namespace_tiled_array.html#aeabeb45688b0531ba26077d27b7bcef6">More...</a><br /></td></tr>
<tr class="separator:aeabeb45688b0531ba26077d27b7bcef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3442799c758651ce6586418d2cf09b24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3442799c758651ce6586418d2cf09b24">operator==</a> (const <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &amp;r2)</td></tr>
<tr class="memdesc:a3442799c758651ce6586418d2cf09b24"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_block_range.html" title="Range that references a subblock of another range.">BlockRange</a> equality comparison.  <a href="namespace_tiled_array.html#a3442799c758651ce6586418d2cf09b24">More...</a><br /></td></tr>
<tr class="separator:a3442799c758651ce6586418d2cf09b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf33eeb75439cdafef2d84e62d6e7fba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#adf33eeb75439cdafef2d84e62d6e7fba">is_contiguous</a> (const <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &amp;range)</td></tr>
<tr class="separator:adf33eeb75439cdafef2d84e62d6e7fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7fbc10ae58bc49609c93b31fa7d4e1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_ , typename Storage_ , typename Tensor_ &gt; </td></tr>
<tr class="memitem:ace7fbc10ae58bc49609c93b31fa7d4e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ace7fbc10ae58bc49609c93b31fa7d4e1">btas_subtensor_to_tensor</a> (const btas::Tensor&lt; T, Range_, Storage_ &gt; &amp;src, Tensor_ &amp;dst)</td></tr>
<tr class="memdesc:ace7fbc10ae58bc49609c93b31fa7d4e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a block of a btas::Tensor into a <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">TiledArray::Tensor</a>.  <a href="namespace_tiled_array.html#ace7fbc10ae58bc49609c93b31fa7d4e1">More...</a><br /></td></tr>
<tr class="separator:ace7fbc10ae58bc49609c93b31fa7d4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cb3eac6d5a72fae3c98b4d78f5b77a"><td class="memTemplParams" colspan="2">template&lt;typename Tensor_ , typename T , typename Range_ , typename Storage_ &gt; </td></tr>
<tr class="memitem:ad8cb3eac6d5a72fae3c98b4d78f5b77a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ad8cb3eac6d5a72fae3c98b4d78f5b77a">tensor_to_btas_subtensor</a> (const Tensor_ &amp;src, btas::Tensor&lt; T, Range_, Storage_ &gt; &amp;dst)</td></tr>
<tr class="memdesc:ad8cb3eac6d5a72fae3c98b4d78f5b77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a block of a btas::Tensor into a <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">TiledArray::Tensor</a>.  <a href="namespace_tiled_array.html#ad8cb3eac6d5a72fae3c98b4d78f5b77a">More...</a><br /></td></tr>
<tr class="separator:ad8cb3eac6d5a72fae3c98b4d78f5b77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4eb781438f1d5ffec3f75b879ead8c0"><td class="memTemplParams" colspan="2">template&lt;typename DistArray_ , typename T , typename Range , typename Storage &gt; </td></tr>
<tr class="memitem:aa4eb781438f1d5ffec3f75b879ead8c0"><td class="memTemplItemLeft" align="right" valign="top">DistArray_&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa4eb781438f1d5ffec3f75b879ead8c0">btas_tensor_to_array</a> (World &amp;world, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> &amp;trange, const btas::Tensor&lt; T, <a class="el" href="class_tiled_array_1_1_range.html">Range</a>, Storage &gt; &amp;src, bool replicated=false)</td></tr>
<tr class="memdesc:aa4eb781438f1d5ffec3f75b879ead8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a btas::Tensor object into a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">TiledArray::DistArray</a> object.  <a href="namespace_tiled_array.html#aa4eb781438f1d5ffec3f75b879ead8c0">More...</a><br /></td></tr>
<tr class="separator:aa4eb781438f1d5ffec3f75b879ead8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae732935e243d742f37911ca9592ab851"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy , typename Storage  = std::vector&lt;typename Tile::value_type&gt;&gt; </td></tr>
<tr class="memitem:ae732935e243d742f37911ca9592ab851"><td class="memTemplItemLeft" align="right" valign="top">btas::Tensor&lt; typename <a class="el" href="class_tiled_array_1_1_tile.html#ada00b9498ca68cabc845d54c14f07695">Tile::value_type</a>, btas::DEFAULT::range, Storage &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ae732935e243d742f37911ca9592ab851">array_to_btas_tensor</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">TiledArray::DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;src, int target_rank=-1)</td></tr>
<tr class="memdesc:ae732935e243d742f37911ca9592ab851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">TiledArray::DistArray</a> object into a btas::Tensor object.  <a href="namespace_tiled_array.html#ae732935e243d742f37911ca9592ab851">More...</a><br /></td></tr>
<tr class="separator:ae732935e243d742f37911ca9592ab851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9fa503cbbd6e5627b1e1878cf51141"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a7c9fa503cbbd6e5627b1e1878cf51141"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a7c9fa503cbbd6e5627b1e1878cf51141">clone</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;arg)</td></tr>
<tr class="memdesc:a7c9fa503cbbd6e5627b1e1878cf51141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a deep copy of an array.  <a href="namespace_tiled_array.html#a7c9fa503cbbd6e5627b1e1878cf51141">More...</a><br /></td></tr>
<tr class="separator:a7c9fa503cbbd6e5627b1e1878cf51141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8957a8fceb6790b1ea9e5637728e0f66"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename ResultPolicy  = SparsePolicy, typename ArgPolicy &gt; </td></tr>
<tr class="memitem:a8957a8fceb6790b1ea9e5637728e0f66"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt; ResultPolicy &gt; &amp;&amp;<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt; ArgPolicy &gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, ResultPolicy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a8957a8fceb6790b1ea9e5637728e0f66">to_sparse</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, ArgPolicy &gt; const &amp;dense_array)</td></tr>
<tr class="memdesc:a8957a8fceb6790b1ea9e5637728e0f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to convert a dense array into a block sparse array.  <a href="namespace_tiled_array.html#a8957a8fceb6790b1ea9e5637728e0f66">More...</a><br /></td></tr>
<tr class="separator:a8957a8fceb6790b1ea9e5637728e0f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb8995bef009f9282891f14263dea8c"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a0cb8995bef009f9282891f14263dea8c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt; Policy &gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a0cb8995bef009f9282891f14263dea8c">to_sparse</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; const &amp;sparse_array)</td></tr>
<tr class="memdesc:a0cb8995bef009f9282891f14263dea8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the array is already sparse return a copy of the array.  <a href="namespace_tiled_array.html#a0cb8995bef009f9282891f14263dea8c">More...</a><br /></td></tr>
<tr class="separator:a0cb8995bef009f9282891f14263dea8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e3bc36192ae1bb9b4f6e3da001023a"><td class="memTemplParams" colspan="2">template&lt;typename T , Eigen::StorageOptions Storage = Eigen::RowMajor, std::enable_if_t&lt; detail::is_contiguous_tensor_v&lt; T &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a03e3bc36192ae1bb9b4f6e3da001023a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Map&lt; const Eigen::Matrix&lt; typename T::value_type, Eigen::Dynamic, Eigen::Dynamic, Storage &gt;, Eigen::AutoAlign &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a03e3bc36192ae1bb9b4f6e3da001023a">eigen_map</a> (const T &amp;tensor, const std::size_t m, const std::size_t n)</td></tr>
<tr class="memdesc:a03e3bc36192ae1bb9b4f6e3da001023a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a const Eigen::Map object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> object.  <a href="namespace_tiled_array.html#a03e3bc36192ae1bb9b4f6e3da001023a">More...</a><br /></td></tr>
<tr class="separator:a03e3bc36192ae1bb9b4f6e3da001023a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3193ab0ab6071c4b49f1001a8011a4"><td class="memTemplParams" colspan="2">template&lt;typename T , Eigen::StorageOptions Storage = Eigen::RowMajor, std::enable_if_t&lt; detail::is_contiguous_tensor_v&lt; T &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acb3193ab0ab6071c4b49f1001a8011a4"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Map&lt; Eigen::Matrix&lt; typename T::value_type, Eigen::Dynamic, Eigen::Dynamic, Storage &gt;, Eigen::AutoAlign &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#acb3193ab0ab6071c4b49f1001a8011a4">eigen_map</a> (T &amp;tensor, const std::size_t m, const std::size_t n)</td></tr>
<tr class="memdesc:acb3193ab0ab6071c4b49f1001a8011a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an Eigen::Map object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> object.  <a href="namespace_tiled_array.html#acb3193ab0ab6071c4b49f1001a8011a4">More...</a><br /></td></tr>
<tr class="separator:acb3193ab0ab6071c4b49f1001a8011a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537bd30ddd02a942483a30de7d24b8fa"><td class="memTemplParams" colspan="2">template&lt;typename T , std::enable_if_t&lt; detail::is_contiguous_tensor_v&lt; T &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a537bd30ddd02a942483a30de7d24b8fa"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Map&lt; const Eigen::Matrix&lt; typename T::value_type, Eigen::Dynamic, 1 &gt;, Eigen::AutoAlign &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a537bd30ddd02a942483a30de7d24b8fa">eigen_map</a> (const T &amp;tensor, const std::size_t n)</td></tr>
<tr class="memdesc:a537bd30ddd02a942483a30de7d24b8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a const Eigen::Map object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> object.  <a href="namespace_tiled_array.html#a537bd30ddd02a942483a30de7d24b8fa">More...</a><br /></td></tr>
<tr class="separator:a537bd30ddd02a942483a30de7d24b8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b924855cb7d0183bbfb021e30ccc141"><td class="memTemplParams" colspan="2">template&lt;typename T , std::enable_if_t&lt; detail::is_contiguous_tensor_v&lt; T &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4b924855cb7d0183bbfb021e30ccc141"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Map&lt; Eigen::Matrix&lt; typename T::value_type, Eigen::Dynamic, 1 &gt;, Eigen::AutoAlign &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4b924855cb7d0183bbfb021e30ccc141">eigen_map</a> (T &amp;tensor, const std::size_t n)</td></tr>
<tr class="memdesc:a4b924855cb7d0183bbfb021e30ccc141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an Eigen::Map object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> object.  <a href="namespace_tiled_array.html#a4b924855cb7d0183bbfb021e30ccc141">More...</a><br /></td></tr>
<tr class="separator:a4b924855cb7d0183bbfb021e30ccc141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8766afb7352ed5fd13da1606e526fd6b"><td class="memTemplParams" colspan="2">template&lt;typename T , Eigen::StorageOptions Storage = Eigen::RowMajor, std::enable_if_t&lt; detail::is_contiguous_tensor_v&lt; T &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8766afb7352ed5fd13da1606e526fd6b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Map&lt; const Eigen::Matrix&lt; typename T::value_type, Eigen::Dynamic, Eigen::Dynamic, Storage &gt;, Eigen::AutoAlign &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a8766afb7352ed5fd13da1606e526fd6b">eigen_map</a> (const T &amp;tensor)</td></tr>
<tr class="memdesc:a8766afb7352ed5fd13da1606e526fd6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a const Eigen::Map object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> object.  <a href="namespace_tiled_array.html#a8766afb7352ed5fd13da1606e526fd6b">More...</a><br /></td></tr>
<tr class="separator:a8766afb7352ed5fd13da1606e526fd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac760760f57ff14f177edfb7f3656968e"><td class="memTemplParams" colspan="2">template&lt;typename T , Eigen::StorageOptions Storage = Eigen::RowMajor, std::enable_if_t&lt; detail::is_contiguous_tensor_v&lt; T &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac760760f57ff14f177edfb7f3656968e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Map&lt; Eigen::Matrix&lt; typename T::value_type, Eigen::Dynamic, Eigen::Dynamic, Storage &gt;, Eigen::AutoAlign &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac760760f57ff14f177edfb7f3656968e">eigen_map</a> (T &amp;tensor)</td></tr>
<tr class="memdesc:ac760760f57ff14f177edfb7f3656968e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an Eigen::Map object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> object.  <a href="namespace_tiled_array.html#ac760760f57ff14f177edfb7f3656968e">More...</a><br /></td></tr>
<tr class="separator:ac760760f57ff14f177edfb7f3656968e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d37708c45657fc2af47759b65e607a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Derived , std::enable_if_t&lt; detail::is_contiguous_tensor_v&lt; T &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab7d37708c45657fc2af47759b65e607a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ab7d37708c45657fc2af47759b65e607a">eigen_submatrix_to_tensor</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix, T &amp;tensor)</td></tr>
<tr class="memdesc:ab7d37708c45657fc2af47759b65e607a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a block of an <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> matrix into a tensor.  <a href="namespace_tiled_array.html#ab7d37708c45657fc2af47759b65e607a">More...</a><br /></td></tr>
<tr class="separator:ab7d37708c45657fc2af47759b65e607a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f423f82e222f193a882c9ea1cb7567f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Derived , std::enable_if_t&lt; detail::is_contiguous_tensor_v&lt; T &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3f423f82e222f193a882c9ea1cb7567f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3f423f82e222f193a882c9ea1cb7567f">tensor_to_eigen_submatrix</a> (const T &amp;tensor, Eigen::MatrixBase&lt; Derived &gt; &amp;matrix)</td></tr>
<tr class="memdesc:a3f423f82e222f193a882c9ea1cb7567f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the content of a tensor into an <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> matrix block.  <a href="namespace_tiled_array.html#a3f423f82e222f193a882c9ea1cb7567f">More...</a><br /></td></tr>
<tr class="separator:a3f423f82e222f193a882c9ea1cb7567f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d23e5d8e0578276832bdbb6aac7e712"><td class="memTemplParams" colspan="2">template&lt;typename A , typename Derived &gt; </td></tr>
<tr class="memitem:a4d23e5d8e0578276832bdbb6aac7e712"><td class="memTemplItemLeft" align="right" valign="top">A&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4d23e5d8e0578276832bdbb6aac7e712">eigen_to_array</a> (World &amp;world, const typename A::trange_type &amp;trange, const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix, bool replicated=false, std::shared_ptr&lt; typename A::pmap_interface &gt; pmap={})</td></tr>
<tr class="memdesc:a4d23e5d8e0578276832bdbb6aac7e712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> matrix into an Array object.  <a href="namespace_tiled_array.html#a4d23e5d8e0578276832bdbb6aac7e712">More...</a><br /></td></tr>
<tr class="separator:a4d23e5d8e0578276832bdbb6aac7e712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ffc6de9b633a34e7d724191cd11f3f"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy , unsigned int EigenStorageOrder = Eigen::ColMajor&gt; </td></tr>
<tr class="memitem:ad4ffc6de9b633a34e7d724191cd11f3f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <a class="el" href="class_tiled_array_1_1_tile.html#ada00b9498ca68cabc845d54c14f07695">Tile::value_type</a>, Eigen::Dynamic, Eigen::Dynamic, EigenStorageOrder &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ad4ffc6de9b633a34e7d724191cd11f3f">array_to_eigen</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;array)</td></tr>
<tr class="memdesc:ad4ffc6de9b633a34e7d724191cd11f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an Array object into an <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> matrix object.  <a href="namespace_tiled_array.html#ad4ffc6de9b633a34e7d724191cd11f3f">More...</a><br /></td></tr>
<tr class="separator:ad4ffc6de9b633a34e7d724191cd11f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22699a4d75791748456f10475f3de4c5"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a22699a4d75791748456f10475f3de4c5"><td class="memTemplItemLeft" align="right" valign="top">A&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a22699a4d75791748456f10475f3de4c5">row_major_buffer_to_array</a> (World &amp;world, const typename A::trange_type &amp;trange, const typename A::value_type::value_type *buffer, const std::size_t m, const std::size_t n, const bool replicated=false, std::shared_ptr&lt; typename A::pmap_interface &gt; pmap={})</td></tr>
<tr class="memdesc:a22699a4d75791748456f10475f3de4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a row-major matrix buffer into an Array object.  <a href="namespace_tiled_array.html#a22699a4d75791748456f10475f3de4c5">More...</a><br /></td></tr>
<tr class="separator:a22699a4d75791748456f10475f3de4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69da144eff9ec6f1ad28eb45e4332509"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a69da144eff9ec6f1ad28eb45e4332509"><td class="memTemplItemLeft" align="right" valign="top">A&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a69da144eff9ec6f1ad28eb45e4332509">column_major_buffer_to_array</a> (World &amp;world, const typename A::trange_type &amp;trange, const typename A::value_type::value_type *buffer, const std::size_t m, const std::size_t n, const bool replicated=false, std::shared_ptr&lt; typename A::pmap_interface &gt; pmap={})</td></tr>
<tr class="memdesc:a69da144eff9ec6f1ad28eb45e4332509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a column-major matrix buffer into an Array object.  <a href="namespace_tiled_array.html#a69da144eff9ec6f1ad28eb45e4332509">More...</a><br /></td></tr>
<tr class="separator:a69da144eff9ec6f1ad28eb45e4332509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd3d9c18d8f36108c03e6ef9429144f"><td class="memTemplParams" colspan="2">template&lt;typename Array , typename Op , typename std::enable_if&lt; is_dense&lt; Array &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a7cd3d9c18d8f36108c03e6ef9429144f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a7cd3d9c18d8f36108c03e6ef9429144f">make_array</a> (World &amp;world, const <a class="el" href="namespace_tiled_array_1_1detail.html#a06e12c23ae1ad65ad65ef54b041abb37">detail::trange_t</a>&lt; <a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &gt; &amp;trange, const std::shared_ptr&lt; <a class="el" href="namespace_tiled_array_1_1detail.html#a11981ec4cf6f0e145fe51fa42c93ec10">detail::pmap_t</a>&lt; <a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &gt; &gt; &amp;pmap, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:a7cd3d9c18d8f36108c03e6ef9429144f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct dense Array.  <a href="namespace_tiled_array.html#a7cd3d9c18d8f36108c03e6ef9429144f">More...</a><br /></td></tr>
<tr class="separator:a7cd3d9c18d8f36108c03e6ef9429144f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73ea2d1e2e1b222f741f94a3f949e1c"><td class="memTemplParams" colspan="2">template&lt;typename Array , typename Op &gt; </td></tr>
<tr class="memitem:ad73ea2d1e2e1b222f741f94a3f949e1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ad73ea2d1e2e1b222f741f94a3f949e1c">make_array</a> (World &amp;world, const <a class="el" href="namespace_tiled_array_1_1detail.html#a06e12c23ae1ad65ad65ef54b041abb37">detail::trange_t</a>&lt; <a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &gt; &amp;trange, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:ad73ea2d1e2e1b222f741f94a3f949e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an Array.  <a href="namespace_tiled_array.html#ad73ea2d1e2e1b222f741f94a3f949e1c">More...</a><br /></td></tr>
<tr class="separator:ad73ea2d1e2e1b222f741f94a3f949e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e85683a584368627bbc160569c246f"><td class="memTemplParams" colspan="2">template&lt;typename TileType , typename PolicyType &gt; </td></tr>
<tr class="memitem:a93e85683a584368627bbc160569c246f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a93e85683a584368627bbc160569c246f">retile</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; TileType, PolicyType &gt; &amp;tensor, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;new_trange)</td></tr>
<tr class="separator:a93e85683a584368627bbc160569c246f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14fae9ffb07568e7366e6e1964665cc"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename ResultPolicy  = DensePolicy, typename ArgPolicy &gt; </td></tr>
<tr class="memitem:aa14fae9ffb07568e7366e6e1964665cc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt; ResultPolicy &gt; &amp;&amp;!<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt; ArgPolicy &gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, ResultPolicy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa14fae9ffb07568e7366e6e1964665cc">to_dense</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, ArgPolicy &gt; const &amp;sparse_array)</td></tr>
<tr class="separator:aa14fae9ffb07568e7366e6e1964665cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64038a31ff7ab96b97008f3ab99e915f"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a64038a31ff7ab96b97008f3ab99e915f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt; Policy &gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a64038a31ff7ab96b97008f3ab99e915f">to_dense</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; const &amp;other)</td></tr>
<tr class="separator:a64038a31ff7ab96b97008f3ab99e915f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef954fffe09fc2ffff5921bd107e0df"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename ConvTile  = Tile, typename Policy , typename Op &gt; </td></tr>
<tr class="memitem:a5ef954fffe09fc2ffff5921bd107e0df"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a5ef954fffe09fc2ffff5921bd107e0df">to_new_tile_type</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; const &amp;old_array, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:a5ef954fffe09fc2ffff5921bd107e0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to convert an array to a new array with a different tile type.  <a href="namespace_tiled_array.html#a5ef954fffe09fc2ffff5921bd107e0df">More...</a><br /></td></tr>
<tr class="separator:a5ef954fffe09fc2ffff5921bd107e0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9879b4e6b03e7be2b37f3b1e8c8a0f8"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:ae9879b4e6b03e7be2b37f3b1e8c8a0f8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt; Policy &gt;, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ae9879b4e6b03e7be2b37f3b1e8c8a0f8">truncate</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;array, typename Policy::shape_type::value_type=0)</td></tr>
<tr class="memdesc:ae9879b4e6b03e7be2b37f3b1e8c8a0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate a dense Array.  <a href="namespace_tiled_array.html#ae9879b4e6b03e7be2b37f3b1e8c8a0f8">More...</a><br /></td></tr>
<tr class="separator:ae9879b4e6b03e7be2b37f3b1e8c8a0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e56cc87496a69b06a7d21765b404aa3"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a4e56cc87496a69b06a7d21765b404aa3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt; Policy &gt;, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4e56cc87496a69b06a7d21765b404aa3">truncate</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;array, typename Policy::shape_type::value_type thresh=Policy::shape_type::threshold())</td></tr>
<tr class="memdesc:a4e56cc87496a69b06a7d21765b404aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate a sparse Array.  <a href="namespace_tiled_array.html#a4e56cc87496a69b06a7d21765b404aa3">More...</a><br /></td></tr>
<tr class="separator:a4e56cc87496a69b06a7d21765b404aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac602cf7316f1296d1f59f76975f5cdfb"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:ac602cf7316f1296d1f59f76975f5cdfb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">TA::DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac602cf7316f1296d1f59f76975f5cdfb">fuse_vector_of_arrays_tiles</a> (madness::World &amp;global_world, const std::vector&lt; <a class="el" href="class_tiled_array_1_1_dist_array.html">TA::DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;&gt; &amp;array_vec, const std::size_t fused_dim_extent, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> &amp;array_trange, std::size_t block_size=1)</td></tr>
<tr class="memdesc:ac602cf7316f1296d1f59f76975f5cdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">fuses a vector of <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> objects, each with the same <a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array.">TiledRange</a> into a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> with 1 more dimensions  <a href="namespace_tiled_array.html#ac602cf7316f1296d1f59f76975f5cdfb">More...</a><br /></td></tr>
<tr class="separator:ac602cf7316f1296d1f59f76975f5cdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ec22d8c4caa8f1662a6c124430e802"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a40ec22d8c4caa8f1662a6c124430e802"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a40ec22d8c4caa8f1662a6c124430e802">subarray_from_fused_array</a> (madness::World &amp;local_world, const <a class="el" href="class_tiled_array_1_1_dist_array.html">TA::DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;fused_array, std::size_t tile_idx, std::vector&lt; <a class="el" href="class_tiled_array_1_1_dist_array.html">TA::DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;&gt; &amp;split_arrays, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TA::TiledRange</a> &amp;split_trange)</td></tr>
<tr class="memdesc:a40ec22d8c4caa8f1662a6c124430e802"><td class="mdescLeft">&#160;</td><td class="mdescRight">extracts a subarray of a fused array created with fuse_vector_of_arrays and creates the array in <code>local_world</code>.  <a href="namespace_tiled_array.html#a40ec22d8c4caa8f1662a6c124430e802">More...</a><br /></td></tr>
<tr class="separator:a40ec22d8c4caa8f1662a6c124430e802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa78fc16b2d0cae8227821ab85d635a"><td class="memTemplParams" colspan="2">template&lt;MemorySpace Space, typename T , typename HostAlloc , typename DeviceAlloc &gt; </td></tr>
<tr class="memitem:a7aa78fc16b2d0cae8227821ab85d635a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a7aa78fc16b2d0cae8227821ab85d635a">in_memory_space</a> (const <a class="el" href="class_tiled_array_1_1cpu__cuda__vector.html">cpu_cuda_vector</a>&lt; T, HostAlloc, DeviceAlloc &gt; &amp;vec) noexcept</td></tr>
<tr class="separator:a7aa78fc16b2d0cae8227821ab85d635a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa442389b0a4b843c2e7b580b1c6c0452"><td class="memTemplParams" colspan="2">template&lt;ExecutionSpace Space, typename T , typename HostAlloc , typename DeviceAlloc &gt; </td></tr>
<tr class="memitem:aa442389b0a4b843c2e7b580b1c6c0452"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa442389b0a4b843c2e7b580b1c6c0452">to_execution_space</a> (<a class="el" href="class_tiled_array_1_1cpu__cuda__vector.html">cpu_cuda_vector</a>&lt; T, HostAlloc, DeviceAlloc &gt; &amp;vec, cudaStream_t stream=0)</td></tr>
<tr class="separator:aa442389b0a4b843c2e7b580b1c6c0452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab318ad5c5c3986ad9886c8c6fd6301f7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab318ad5c5c3986ad9886c8c6fd6301f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ab318ad5c5c3986ad9886c8c6fd6301f7">make_device_storage</a> (<a class="el" href="class_tiled_array_1_1cpu__cuda__vector.html">cpu_cuda_vector</a>&lt; T &gt; &amp;storage, std::size_t n, cudaStream_t stream=0)</td></tr>
<tr class="separator:ab318ad5c5c3986ad9886c8c6fd6301f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7241efe0fc81610af58e14dff7a9f7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e7241efe0fc81610af58e14dff7a9f7"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a0e7241efe0fc81610af58e14dff7a9f7">device_data</a> (<a class="el" href="class_tiled_array_1_1cpu__cuda__vector.html">cpu_cuda_vector</a>&lt; T &gt; &amp;storage)</td></tr>
<tr class="separator:a0e7241efe0fc81610af58e14dff7a9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b673ef5df86a644ff32bd1338cca8f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad6b673ef5df86a644ff32bd1338cca8f"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ad6b673ef5df86a644ff32bd1338cca8f">device_data</a> (const <a class="el" href="class_tiled_array_1_1cpu__cuda__vector.html">cpu_cuda_vector</a>&lt; T &gt; &amp;storage)</td></tr>
<tr class="separator:ad6b673ef5df86a644ff32bd1338cca8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa970ec287c852074d963f780cf149824"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa970ec287c852074d963f780cf149824"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa970ec287c852074d963f780cf149824">mult_to_cuda_kernel_impl</a> (T *result, const T *arg, std::size_t n, cudaStream_t stream, int device_id)</td></tr>
<tr class="memdesc:aa970ec287c852074d963f780cf149824"><td class="mdescLeft">&#160;</td><td class="mdescRight">result[i] = result[i] * arg[i]  <a href="namespace_tiled_array.html#aa970ec287c852074d963f780cf149824">More...</a><br /></td></tr>
<tr class="separator:aa970ec287c852074d963f780cf149824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1996e1acc93771802b143a34c44208"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d1996e1acc93771802b143a34c44208"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3d1996e1acc93771802b143a34c44208">mult_cuda_kernel_impl</a> (T *result, const T *arg1, const T *arg2, std::size_t n, cudaStream_t stream, int device_id)</td></tr>
<tr class="memdesc:a3d1996e1acc93771802b143a34c44208"><td class="mdescLeft">&#160;</td><td class="mdescRight">result[i] = arg1[i] * arg2[i]  <a href="namespace_tiled_array.html#a3d1996e1acc93771802b143a34c44208">More...</a><br /></td></tr>
<tr class="separator:a3d1996e1acc93771802b143a34c44208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc356474566d00f7de7b22b0ce8b108"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ReduceOp &gt; </td></tr>
<tr class="memitem:a3bc356474566d00f7de7b22b0ce8b108"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3bc356474566d00f7de7b22b0ce8b108">reduce_cuda_kernel_impl</a> (ReduceOp &amp;&amp;op, const T *arg, std::size_t n, T init, cudaStream_t stream, int device_id)</td></tr>
<tr class="memdesc:a3bc356474566d00f7de7b22b0ce8b108"><td class="mdescLeft">&#160;</td><td class="mdescRight">T = reduce(T* arg)  <a href="namespace_tiled_array.html#a3bc356474566d00f7de7b22b0ce8b108">More...</a><br /></td></tr>
<tr class="separator:a3bc356474566d00f7de7b22b0ce8b108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2340821470ffaf86a80c7f1e3a9cbf53"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2340821470ffaf86a80c7f1e3a9cbf53"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a2340821470ffaf86a80c7f1e3a9cbf53">product_reduce_cuda_kernel_impl</a> (const T *arg, std::size_t n, cudaStream_t stream, int device_id)</td></tr>
<tr class="separator:a2340821470ffaf86a80c7f1e3a9cbf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43d5179dda74b3b85d1e8520e2f12a6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad43d5179dda74b3b85d1e8520e2f12a6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ad43d5179dda74b3b85d1e8520e2f12a6">sum_reduce_cuda_kernel_impl</a> (const T *arg, std::size_t n, cudaStream_t stream, int device_id)</td></tr>
<tr class="separator:ad43d5179dda74b3b85d1e8520e2f12a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f71d75add02ed829ddc72f0a5e19e83"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f71d75add02ed829ddc72f0a5e19e83"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a0f71d75add02ed829ddc72f0a5e19e83">max_reduce_cuda_kernel_impl</a> (const T *arg, std::size_t n, cudaStream_t stream, int device_id)</td></tr>
<tr class="separator:a0f71d75add02ed829ddc72f0a5e19e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1deaffe62f8c644f5e3dc2e21789771"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae1deaffe62f8c644f5e3dc2e21789771"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ae1deaffe62f8c644f5e3dc2e21789771">min_reduce_cuda_kernel_impl</a> (const T *arg, std::size_t n, cudaStream_t stream, int device_id)</td></tr>
<tr class="separator:ae1deaffe62f8c644f5e3dc2e21789771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b185f3cd563766c7aeab90312c8b499"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b185f3cd563766c7aeab90312c8b499"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a0b185f3cd563766c7aeab90312c8b499">absmax_reduce_cuda_kernel_impl</a> (const T *arg, std::size_t n, cudaStream_t stream, int device_id)</td></tr>
<tr class="separator:a0b185f3cd563766c7aeab90312c8b499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0da95cfc7fbabc2f3ad067081cd78a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9f0da95cfc7fbabc2f3ad067081cd78a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a9f0da95cfc7fbabc2f3ad067081cd78a">absmin_reduce_cuda_kernel_impl</a> (const T *arg, std::size_t n, cudaStream_t stream, int device_id)</td></tr>
<tr class="separator:a9f0da95cfc7fbabc2f3ad067081cd78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050b0409972cf113c9f70e26fa9cc181"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_tiled_array.html#a075713b9b2f21c1f7a54361922ff9d13">MemorySpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a050b0409972cf113c9f70e26fa9cc181">operator&amp;</a> (<a class="el" href="namespace_tiled_array.html#a075713b9b2f21c1f7a54361922ff9d13">MemorySpace</a> space1, <a class="el" href="namespace_tiled_array.html#a075713b9b2f21c1f7a54361922ff9d13">MemorySpace</a> space2)</td></tr>
<tr class="separator:a050b0409972cf113c9f70e26fa9cc181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80801a169db3865dd8333dcf76d908fb"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_tiled_array.html#a075713b9b2f21c1f7a54361922ff9d13">MemorySpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a80801a169db3865dd8333dcf76d908fb">operator|</a> (<a class="el" href="namespace_tiled_array.html#a075713b9b2f21c1f7a54361922ff9d13">MemorySpace</a> space1, <a class="el" href="namespace_tiled_array.html#a075713b9b2f21c1f7a54361922ff9d13">MemorySpace</a> space2)</td></tr>
<tr class="separator:a80801a169db3865dd8333dcf76d908fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd16fab45a79047fe90a8ba765185a1d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#acd16fab45a79047fe90a8ba765185a1d">overlap</a> (<a class="el" href="namespace_tiled_array.html#a075713b9b2f21c1f7a54361922ff9d13">MemorySpace</a> space1, <a class="el" href="namespace_tiled_array.html#a075713b9b2f21c1f7a54361922ff9d13">MemorySpace</a> space2)</td></tr>
<tr class="separator:acd16fab45a79047fe90a8ba765185a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de8bd808088bd6375c6dc8a9093b4b6"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a0de8bd808088bd6375c6dc8a9093b4b6">operator==</a> (const <a class="el" href="class_tiled_array_1_1_dense_shape.html">DenseShape</a> &amp;a, const <a class="el" href="class_tiled_array_1_1_dense_shape.html">DenseShape</a> &amp;b)</td></tr>
<tr class="separator:a0de8bd808088bd6375c6dc8a9093b4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a725f292ae8f27a3d142e19bedca1e"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ab8a725f292ae8f27a3d142e19bedca1e">operator!=</a> (const <a class="el" href="class_tiled_array_1_1_dense_shape.html">DenseShape</a> &amp;a, const <a class="el" href="class_tiled_array_1_1_dense_shape.html">DenseShape</a> &amp;b)</td></tr>
<tr class="separator:ab8a725f292ae8f27a3d142e19bedca1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a805e13069e3aa1ea4c09910c1bb1bf"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a9a805e13069e3aa1ea4c09910c1bb1bf">is_replicated</a> (World &amp;world, const <a class="el" href="class_tiled_array_1_1_dense_shape.html">DenseShape</a> &amp;t)</td></tr>
<tr class="separator:a9a805e13069e3aa1ea4c09910c1bb1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8044f7d779135e7bc782943d785a0fc5"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a8044f7d779135e7bc782943d785a0fc5"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a8044f7d779135e7bc782943d785a0fc5">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a)</td></tr>
<tr class="memdesc:a8044f7d779135e7bc782943d785a0fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> the tensor to an output stream.  <a href="namespace_tiled_array.html#a8044f7d779135e7bc782943d785a0fc5">More...</a><br /></td></tr>
<tr class="separator:a8044f7d779135e7bc782943d785a0fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e2da9f3855369c97e61e9105cce50a"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:ae6e2da9f3855369c97e61e9105cce50a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ae6e2da9f3855369c97e61e9105cce50a">rank</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a)</td></tr>
<tr class="separator:ae6e2da9f3855369c97e61e9105cce50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea673bd36f494b9b4c040ea0e09c00bd"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:aea673bd36f494b9b4c040ea0e09c00bd"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aea673bd36f494b9b4c040ea0e09c00bd">volume</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a)</td></tr>
<tr class="separator:aea673bd36f494b9b4c040ea0e09c00bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09edca89f7e0f6b29c03206118a9c49"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:ad09edca89f7e0f6b29c03206118a9c49"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ad09edca89f7e0f6b29c03206118a9c49">abs_min</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a)</td></tr>
<tr class="separator:ad09edca89f7e0f6b29c03206118a9c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37032bc091e5e9452a6385ebbce0dc94"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a37032bc091e5e9452a6385ebbce0dc94"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a37032bc091e5e9452a6385ebbce0dc94">abs_max</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a)</td></tr>
<tr class="separator:a37032bc091e5e9452a6385ebbce0dc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e8a14dc06218506b921b90d86bf622"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a56e8a14dc06218506b921b90d86bf622"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a56e8a14dc06218506b921b90d86bf622">dot</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;b)</td></tr>
<tr class="separator:a56e8a14dc06218506b921b90d86bf622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2108251710c269618bbdf6291f16a340"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a2108251710c269618bbdf6291f16a340"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a2108251710c269618bbdf6291f16a340">inner_product</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;b)</td></tr>
<tr class="separator:a2108251710c269618bbdf6291f16a340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2208f3d88d7e5293d2fc6b1fc01768fd"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a2208f3d88d7e5293d2fc6b1fc01768fd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a2208f3d88d7e5293d2fc6b1fc01768fd">squared_norm</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a)</td></tr>
<tr class="separator:a2208f3d88d7e5293d2fc6b1fc01768fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736de0045a7f48b5df63e3137260e40b"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a736de0045a7f48b5df63e3137260e40b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a736de0045a7f48b5df63e3137260e40b">norm2</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a)</td></tr>
<tr class="separator:a736de0045a7f48b5df63e3137260e40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad641711c98c1b64bdf7ad28cccfae69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aad641711c98c1b64bdf7ad28cccfae69">exception_break</a> ()</td></tr>
<tr class="separator:aad641711c98c1b64bdf7ad28cccfae69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdf2a8c0016b75f187be14d3dde68b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a6bdf2a8c0016b75f187be14d3dde68b4">assert_failed</a> (const std::string &amp;m)</td></tr>
<tr class="separator:a6bdf2a8c0016b75f187be14d3dde68b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add57a0e7f0bc424ea564f06022ce91a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#add57a0e7f0bc424ea564f06022ce91a3">congruent</a> (const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r2)</td></tr>
<tr class="memdesc:add57a0e7f0bc424ea564f06022ce91a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the two ranges are congruent.  <a href="namespace_tiled_array.html#add57a0e7f0bc424ea564f06022ce91a3">More...</a><br /></td></tr>
<tr class="separator:add57a0e7f0bc424ea564f06022ce91a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd2736a88698132f314b8a6e34aec67"><td class="memTemplParams" colspan="2">template&lt;typename Perm &gt; </td></tr>
<tr class="memitem:a1bd2736a88698132f314b8a6e34aec67"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!TiledArray::detail::is_permutation_v&lt; Perm &gt;, <a class="el" href="class_tiled_array_1_1_range.html">TiledArray::Range</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a1bd2736a88698132f314b8a6e34aec67">permute</a> (const <a class="el" href="class_tiled_array_1_1_range.html">TiledArray::Range</a> &amp;r, const Perm &amp;p)</td></tr>
<tr class="separator:a1bd2736a88698132f314b8a6e34aec67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1553ba04e597fc346a2313ab175f37b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a1553ba04e597fc346a2313ab175f37b4">set_default_world</a> (World &amp;world)</td></tr>
<tr class="memdesc:a1553ba04e597fc346a2313ab175f37b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default World to <code>world</code> .  <a href="namespace_tiled_array.html#a1553ba04e597fc346a2313ab175f37b4">More...</a><br /></td></tr>
<tr class="separator:a1553ba04e597fc346a2313ab175f37b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb41dd83ecdc33052c9c02eeda152e8"><td class="memItemLeft" align="right" valign="top">World &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a8bb41dd83ecdc33052c9c02eeda152e8">get_default_world</a> ()</td></tr>
<tr class="separator:a8bb41dd83ecdc33052c9c02eeda152e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8869aaf7a547c7f9870fb0d12cbdfd09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a8869aaf7a547c7f9870fb0d12cbdfd09">reset_default_world</a> ()</td></tr>
<tr class="separator:a8869aaf7a547c7f9870fb0d12cbdfd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefaad05a6d604d7013a5f96d2b28888"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; World, decltype(world_resetter)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aeefaad05a6d604d7013a5f96d2b28888">push_default_world</a> (World &amp;world)</td></tr>
<tr class="separator:aeefaad05a6d604d7013a5f96d2b28888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e6e0c952abcd7466a0efdcbf305681"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a52e6e0c952abcd7466a0efdcbf305681">initialized</a> ()</td></tr>
<tr class="separator:a52e6e0c952abcd7466a0efdcbf305681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38811364e6ac3b5c0a5ac02ae19ddac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ab38811364e6ac3b5c0a5ac02ae19ddac">finalized</a> ()</td></tr>
<tr class="separator:ab38811364e6ac3b5c0a5ac02ae19ddac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82d81ab8db19341b018ee44dd5721d28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__symmetry.html#ga82d81ab8db19341b018ee44dd5721d28">operator==</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p1, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p2)</td></tr>
<tr class="memdesc:ga82d81ab8db19341b018ee44dd5721d28"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permutation.html" title="Permutation of a sequence of objects indexed by base-0 indices.">Permutation</a> equality operator.  <a href="group__symmetry.html#ga82d81ab8db19341b018ee44dd5721d28">More...</a><br /></td></tr>
<tr class="separator:ga82d81ab8db19341b018ee44dd5721d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64f168b5f03c8c2548c1b67a6509e9a4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__symmetry.html#ga64f168b5f03c8c2548c1b67a6509e9a4">operator&lt;&lt;</a> (std::ostream &amp;output, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p)</td></tr>
<tr class="memdesc:ga64f168b5f03c8c2548c1b67a6509e9a4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> permutation to an output stream.  <a href="group__symmetry.html#ga64f168b5f03c8c2548c1b67a6509e9a4">More...</a><br /></td></tr>
<tr class="separator:ga64f168b5f03c8c2548c1b67a6509e9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586be997af3bd421583c8fd36c4e95f2"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a586be997af3bd421583c8fd36c4e95f2"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a586be997af3bd421583c8fd36c4e95f2">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const std::array&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:a586be997af3bd421583c8fd36c4e95f2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permute.html" title="Permute a tile.">Permute</a> a <code>std::array</code>.  <a href="namespace_tiled_array.html#a586be997af3bd421583c8fd36c4e95f2">More...</a><br /></td></tr>
<tr class="separator:a586be997af3bd421583c8fd36c4e95f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84ce21d711a462da4a1b44a811a5a94"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ae84ce21d711a462da4a1b44a811a5a94"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, N &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ae84ce21d711a462da4a1b44a811a5a94">operator*=</a> (std::array&lt; T, N &gt; &amp;a, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:ae84ce21d711a462da4a1b44a811a5a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place permute a <code>std::array</code>.  <a href="namespace_tiled_array.html#ae84ce21d711a462da4a1b44a811a5a94">More...</a><br /></td></tr>
<tr class="separator:ae84ce21d711a462da4a1b44a811a5a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db915cc9b57726c63e876d1260c50dc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a3db915cc9b57726c63e876d1260c50dc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3db915cc9b57726c63e876d1260c50dc">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const std::vector&lt; T, A &gt; &amp;v)</td></tr>
<tr class="memdesc:a3db915cc9b57726c63e876d1260c50dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">permute a <code>std::vector&lt;T&gt;</code>  <a href="namespace_tiled_array.html#a3db915cc9b57726c63e876d1260c50dc">More...</a><br /></td></tr>
<tr class="separator:a3db915cc9b57726c63e876d1260c50dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4beab363e9a6e97343bc39965e548f95"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a4beab363e9a6e97343bc39965e548f95"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T, A &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4beab363e9a6e97343bc39965e548f95">operator*=</a> (std::vector&lt; T, A &gt; &amp;v, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:a4beab363e9a6e97343bc39965e548f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place permute a <code>std::vector</code>.  <a href="namespace_tiled_array.html#a4beab363e9a6e97343bc39965e548f95">More...</a><br /></td></tr>
<tr class="separator:a4beab363e9a6e97343bc39965e548f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35cf85d544ef5cea5a232dc86766d80c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a35cf85d544ef5cea5a232dc86766d80c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a35cf85d544ef5cea5a232dc86766d80c">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const T *MADNESS_RESTRICT const ptr)</td></tr>
<tr class="memdesc:a35cf85d544ef5cea5a232dc86766d80c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permute.html" title="Permute a tile.">Permute</a> a memory buffer.  <a href="namespace_tiled_array.html#a35cf85d544ef5cea5a232dc86766d80c">More...</a><br /></td></tr>
<tr class="separator:a35cf85d544ef5cea5a232dc86766d80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343bef50b59c701745c2dc5de90edd1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a343bef50b59c701745c2dc5de90edd1b">operator==</a> (const <a class="el" href="class_tiled_array_1_1_bipartite_permutation.html">BipartitePermutation</a> &amp;p1, const <a class="el" href="class_tiled_array_1_1_bipartite_permutation.html">BipartitePermutation</a> &amp;p2)</td></tr>
<tr class="memdesc:a343bef50b59c701745c2dc5de90edd1b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permutation.html" title="Permutation of a sequence of objects indexed by base-0 indices.">Permutation</a> equality operator.  <a href="namespace_tiled_array.html#a343bef50b59c701745c2dc5de90edd1b">More...</a><br /></td></tr>
<tr class="separator:a343bef50b59c701745c2dc5de90edd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab38342dbdaa26d0f24c1633f77c6555d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__symmetry.html#gab38342dbdaa26d0f24c1633f77c6555d">operator!=</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p1, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p2)</td></tr>
<tr class="memdesc:gab38342dbdaa26d0f24c1633f77c6555d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permutation.html" title="Permutation of a sequence of objects indexed by base-0 indices.">Permutation</a> inequality operator.  <a href="group__symmetry.html#gab38342dbdaa26d0f24c1633f77c6555d">More...</a><br /></td></tr>
<tr class="separator:gab38342dbdaa26d0f24c1633f77c6555d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63845f58c204f812d564fa36d02103c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__symmetry.html#ga63845f58c204f812d564fa36d02103c6">operator&lt;</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p1, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p2)</td></tr>
<tr class="memdesc:ga63845f58c204f812d564fa36d02103c6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permutation.html" title="Permutation of a sequence of objects indexed by base-0 indices.">Permutation</a> less-than operator.  <a href="group__symmetry.html#ga63845f58c204f812d564fa36d02103c6">More...</a><br /></td></tr>
<tr class="separator:ga63845f58c204f812d564fa36d02103c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb2fae98580d4113b53ee2f7385c22fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__symmetry.html#gaeb2fae98580d4113b53ee2f7385c22fc">operator-</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:gaeb2fae98580d4113b53ee2f7385c22fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse permutation operator.  <a href="group__symmetry.html#gaeb2fae98580d4113b53ee2f7385c22fc">More...</a><br /></td></tr>
<tr class="separator:gaeb2fae98580d4113b53ee2f7385c22fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac35ad610b547911850e7ac729a08a917"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__symmetry.html#gac35ad610b547911850e7ac729a08a917">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p1, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p2)</td></tr>
<tr class="memdesc:gac35ad610b547911850e7ac729a08a917"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permutation.html" title="Permutation of a sequence of objects indexed by base-0 indices.">Permutation</a> multiplication operator.  <a href="group__symmetry.html#gac35ad610b547911850e7ac729a08a917">More...</a><br /></td></tr>
<tr class="separator:gac35ad610b547911850e7ac729a08a917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab001d09984e0b7c2bca406ea43b08078"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__symmetry.html#gab001d09984e0b7c2bca406ea43b08078">operator*=</a> (<a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p1, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p2)</td></tr>
<tr class="memdesc:gab001d09984e0b7c2bca406ea43b08078"><td class="mdescLeft">&#160;</td><td class="mdescRight">return *this ^ other  <a href="group__symmetry.html#gab001d09984e0b7c2bca406ea43b08078">More...</a><br /></td></tr>
<tr class="separator:gab001d09984e0b7c2bca406ea43b08078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1f4db587fe34281a4ffab0ca581d2b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__symmetry.html#gaf1f4db587fe34281a4ffab0ca581d2b1">operator^</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, int n)</td></tr>
<tr class="memdesc:gaf1f4db587fe34281a4ffab0ca581d2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise <code>perm</code> to the n-th power.  <a href="group__symmetry.html#gaf1f4db587fe34281a4ffab0ca581d2b1">More...</a><br /></td></tr>
<tr class="separator:gaf1f4db587fe34281a4ffab0ca581d2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a142539c899a3ad3c1b357dfd27933a"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a5a142539c899a3ad3c1b357dfd27933a"><td class="memTemplItemLeft" align="right" valign="top">boost::container::small_vector&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a5a142539c899a3ad3c1b357dfd27933a">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const boost::container::small_vector&lt; T, N &gt; &amp;v)</td></tr>
<tr class="memdesc:a5a142539c899a3ad3c1b357dfd27933a"><td class="mdescLeft">&#160;</td><td class="mdescRight">permute a <code>boost::container::small_vector&lt;T&gt;</code>  <a href="namespace_tiled_array.html#a5a142539c899a3ad3c1b357dfd27933a">More...</a><br /></td></tr>
<tr class="separator:a5a142539c899a3ad3c1b357dfd27933a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01f9a5a93602269365aefabd0794805"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:aa01f9a5a93602269365aefabd0794805"><td class="memTemplItemLeft" align="right" valign="top">boost::container::small_vector&lt; T, N &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa01f9a5a93602269365aefabd0794805">operator*=</a> (boost::container::small_vector&lt; T, N &gt; &amp;v, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:aa01f9a5a93602269365aefabd0794805"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place permute a <code>boost::container::small_vector</code>.  <a href="namespace_tiled_array.html#aa01f9a5a93602269365aefabd0794805">More...</a><br /></td></tr>
<tr class="separator:aa01f9a5a93602269365aefabd0794805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b32d073bbd4bff28bbbe63b3016c5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a00b32d073bbd4bff28bbbe63b3016c5e">operator!=</a> (const <a class="el" href="class_tiled_array_1_1_bipartite_permutation.html">BipartitePermutation</a> &amp;p1, const <a class="el" href="class_tiled_array_1_1_bipartite_permutation.html">BipartitePermutation</a> &amp;p2)</td></tr>
<tr class="memdesc:a00b32d073bbd4bff28bbbe63b3016c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permutation.html" title="Permutation of a sequence of objects indexed by base-0 indices.">Permutation</a> inequality operator.  <a href="namespace_tiled_array.html#a00b32d073bbd4bff28bbbe63b3016c5e">More...</a><br /></td></tr>
<tr class="separator:a00b32d073bbd4bff28bbbe63b3016c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ff448a634f3c75cf737cdcfdb667df"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a17ff448a634f3c75cf737cdcfdb667df">inner</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p)</td></tr>
<tr class="separator:a17ff448a634f3c75cf737cdcfdb667df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ca17753fe59a1d02033b03b343db89"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a09ca17753fe59a1d02033b03b343db89">outer</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p)</td></tr>
<tr class="separator:a09ca17753fe59a1d02033b03b343db89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cadfa975cfa7318b9a6e8a96fe6e038"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a9cadfa975cfa7318b9a6e8a96fe6e038">inner_size</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p)</td></tr>
<tr class="separator:a9cadfa975cfa7318b9a6e8a96fe6e038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8fcee404b04343dc31f107f1373c8c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aba8fcee404b04343dc31f107f1373c8c">outer_size</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p)</td></tr>
<tr class="separator:aba8fcee404b04343dc31f107f1373c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9cfa02e15bfbaaba9fa2e11d73d527"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4e9cfa02e15bfbaaba9fa2e11d73d527">inner</a> (const <a class="el" href="class_tiled_array_1_1_bipartite_permutation.html">BipartitePermutation</a> &amp;p)</td></tr>
<tr class="separator:a4e9cfa02e15bfbaaba9fa2e11d73d527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d11d5e7475f3cd511716fc434dc28c7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a0d11d5e7475f3cd511716fc434dc28c7">outer</a> (const <a class="el" href="class_tiled_array_1_1_bipartite_permutation.html">BipartitePermutation</a> &amp;p)</td></tr>
<tr class="separator:a0d11d5e7475f3cd511716fc434dc28c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5762956a37a733db3ef580528de953c4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a5762956a37a733db3ef580528de953c4">inner_size</a> (const <a class="el" href="class_tiled_array_1_1_bipartite_permutation.html">BipartitePermutation</a> &amp;p)</td></tr>
<tr class="separator:a5762956a37a733db3ef580528de953c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989cf8c0973570f17442418f3bb37a18"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a989cf8c0973570f17442418f3bb37a18">outer_size</a> (const <a class="el" href="class_tiled_array_1_1_bipartite_permutation.html">BipartitePermutation</a> &amp;p)</td></tr>
<tr class="separator:a989cf8c0973570f17442418f3bb37a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705b350b2dbf336a9cc24fb1d0f78fca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a705b350b2dbf336a9cc24fb1d0f78fca">swap</a> (<a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r0, <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r1)</td></tr>
<tr class="memdesc:a705b350b2dbf336a9cc24fb1d0f78fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange the values of the give two ranges.  <a href="namespace_tiled_array.html#a705b350b2dbf336a9cc24fb1d0f78fca">More...</a><br /></td></tr>
<tr class="separator:a705b350b2dbf336a9cc24fb1d0f78fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678f80db611a7af38027953b96bc8f0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_range.html">Range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a678f80db611a7af38027953b96bc8f0d">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r)</td></tr>
<tr class="memdesc:a678f80db611a7af38027953b96bc8f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a permuted range.  <a href="namespace_tiled_array.html#a678f80db611a7af38027953b96bc8f0d">More...</a><br /></td></tr>
<tr class="separator:a678f80db611a7af38027953b96bc8f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4568b46144cd7f450bd034c8db17b807"><td class="memTemplParams" colspan="2">template&lt;typename I , typename  = std::enable_if_t&lt;std::is_integral_v&lt;I&gt;&gt;&gt; </td></tr>
<tr class="memitem:a4568b46144cd7f450bd034c8db17b807"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_range.html">Range</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4568b46144cd7f450bd034c8db17b807">permute</a> (const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r, std::initializer_list&lt; I &gt; perm)</td></tr>
<tr class="memdesc:a4568b46144cd7f450bd034c8db17b807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a permuted range.  <a href="namespace_tiled_array.html#a4568b46144cd7f450bd034c8db17b807">More...</a><br /></td></tr>
<tr class="separator:a4568b46144cd7f450bd034c8db17b807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25a0fb0ad765d6c6a383c67d403fc57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac25a0fb0ad765d6c6a383c67d403fc57">operator==</a> (const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r2)</td></tr>
<tr class="memdesc:ac25a0fb0ad765d6c6a383c67d403fc57"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a> equality comparison.  <a href="namespace_tiled_array.html#ac25a0fb0ad765d6c6a383c67d403fc57">More...</a><br /></td></tr>
<tr class="separator:ac25a0fb0ad765d6c6a383c67d403fc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc410382ebb92ab3373034a9b54a9a78"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#abc410382ebb92ab3373034a9b54a9a78">operator!=</a> (const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r2)</td></tr>
<tr class="memdesc:abc410382ebb92ab3373034a9b54a9a78"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a> inequality comparison.  <a href="namespace_tiled_array.html#abc410382ebb92ab3373034a9b54a9a78">More...</a><br /></td></tr>
<tr class="separator:abc410382ebb92ab3373034a9b54a9a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00568c34aef7e5f9b2802cbdd4382ea5"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a00568c34aef7e5f9b2802cbdd4382ea5">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r)</td></tr>
<tr class="memdesc:a00568c34aef7e5f9b2802cbdd4382ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a> output operator.  <a href="namespace_tiled_array.html#a00568c34aef7e5f9b2802cbdd4382ea5">More...</a><br /></td></tr>
<tr class="separator:a00568c34aef7e5f9b2802cbdd4382ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7540b327326cb346b3348c695994db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a2d7540b327326cb346b3348c695994db">is_congruent</a> (const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r2)</td></tr>
<tr class="memdesc:a2d7540b327326cb346b3348c695994db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test the two ranges are congruent.  <a href="namespace_tiled_array.html#a2d7540b327326cb346b3348c695994db">More...</a><br /></td></tr>
<tr class="separator:a2d7540b327326cb346b3348c695994db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6721abfa16c73293afcaf6e4451601"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aec6721abfa16c73293afcaf6e4451601">is_contiguous</a> (const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;range)</td></tr>
<tr class="separator:aec6721abfa16c73293afcaf6e4451601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4eb5173fc9dae94dd7a1a012f42b4d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b4eb5173fc9dae94dd7a1a012f42b4d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a9b4eb5173fc9dae94dd7a1a012f42b4d">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1_sparse_shape.html">SparseShape</a>&lt; T &gt; &amp;shape)</td></tr>
<tr class="memdesc:a9b4eb5173fc9dae94dd7a1a012f42b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> the shape to an output stream.  <a href="namespace_tiled_array.html#a9b4eb5173fc9dae94dd7a1a012f42b4d">More...</a><br /></td></tr>
<tr class="separator:a9b4eb5173fc9dae94dd7a1a012f42b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a3b9976b8eacacfa0517e6bdc7c44d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a55a3b9976b8eacacfa0517e6bdc7c44d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a55a3b9976b8eacacfa0517e6bdc7c44d">is_replicated</a> (World &amp;world, const <a class="el" href="class_tiled_array_1_1_sparse_shape.html">SparseShape</a>&lt; T &gt; &amp;shape)</td></tr>
<tr class="memdesc:a55a3b9976b8eacacfa0517e6bdc7c44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">collective bitwise-compare-reduce for <a class="el" href="class_tiled_array_1_1_sparse_shape.html" title="Frobenius-norm-based sparse shape.">SparseShape</a> objects  <a href="namespace_tiled_array.html#a55a3b9976b8eacacfa0517e6bdc7c44d">More...</a><br /></td></tr>
<tr class="separator:a55a3b9976b8eacacfa0517e6bdc7c44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2668989011ee62fa6314733cfc4a32"><td class="memTemplParams" colspan="2">template&lt;typename Array , typename T  = double&gt; </td></tr>
<tr class="memitem:a8d2668989011ee62fa6314733cfc4a32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a8d2668989011ee62fa6314733cfc4a32">diagonal_array</a> (World &amp;world, <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> const &amp;trange, T val=1)</td></tr>
<tr class="memdesc:a8d2668989011ee62fa6314733cfc4a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a constant diagonal <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a>.  <a href="namespace_tiled_array.html#a8d2668989011ee62fa6314733cfc4a32">More...</a><br /></td></tr>
<tr class="separator:a8d2668989011ee62fa6314733cfc4a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529e79017aae7ae9256a7c5a2ab15893"><td class="memTemplParams" colspan="2">template&lt;typename Array , typename RandomAccessIterator &gt; </td></tr>
<tr class="memitem:a529e79017aae7ae9256a7c5a2ab15893"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt; RandomAccessIterator &gt;::value, <a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a529e79017aae7ae9256a7c5a2ab15893">diagonal_array</a> (World &amp;world, <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> const &amp;trange, RandomAccessIterator diagonals_begin, RandomAccessIterator diagonals_end={})</td></tr>
<tr class="memdesc:a529e79017aae7ae9256a7c5a2ab15893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a non-constant diagonal <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a>.  <a href="namespace_tiled_array.html#a529e79017aae7ae9256a7c5a2ab15893">More...</a><br /></td></tr>
<tr class="separator:a529e79017aae7ae9256a7c5a2ab15893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70044a879bcceefda052fe65023bb378"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt; detail::is_tensor&lt; T1, T2 &gt;::value||detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a70044a879bcceefda052fe65023bb378"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a70044a879bcceefda052fe65023bb378">operator+</a> (const T1 &amp;left, const T2 &amp;right)</td></tr>
<tr class="memdesc:a70044a879bcceefda052fe65023bb378"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> plus operator.  <a href="namespace_tiled_array.html#a70044a879bcceefda052fe65023bb378">More...</a><br /></td></tr>
<tr class="separator:a70044a879bcceefda052fe65023bb378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6846288ddd37fd160c0afcdf72ce03b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt; detail::is_tensor&lt; T1, T2 &gt;::value||detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ac6846288ddd37fd160c0afcdf72ce03b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac6846288ddd37fd160c0afcdf72ce03b">operator-</a> (const T1 &amp;left, const T2 &amp;right)</td></tr>
<tr class="memdesc:ac6846288ddd37fd160c0afcdf72ce03b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> minus operator.  <a href="namespace_tiled_array.html#ac6846288ddd37fd160c0afcdf72ce03b">More...</a><br /></td></tr>
<tr class="separator:ac6846288ddd37fd160c0afcdf72ce03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7b0326fbc5daaf9df0298d58e7df49"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt; detail::is_tensor&lt; T1, T2 &gt;::value||detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a2b7b0326fbc5daaf9df0298d58e7df49"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a2b7b0326fbc5daaf9df0298d58e7df49">operator*</a> (const T1 &amp;left, const T2 &amp;right)</td></tr>
<tr class="memdesc:a2b7b0326fbc5daaf9df0298d58e7df49"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> multiplication operator.  <a href="namespace_tiled_array.html#a2b7b0326fbc5daaf9df0298d58e7df49">More...</a><br /></td></tr>
<tr class="separator:a2b7b0326fbc5daaf9df0298d58e7df49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93accba5edcc96b461552d4a9483ec3d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename N , typename std::enable_if&lt;(detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value) &amp;&amp;detail::is_numeric_v&lt; N &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a93accba5edcc96b461552d4a9483ec3d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a93accba5edcc96b461552d4a9483ec3d">operator*</a> (const T &amp;left, N right)</td></tr>
<tr class="memdesc:a93accba5edcc96b461552d4a9483ec3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of <code>left</code> that is scaled by <code>right</code>.  <a href="namespace_tiled_array.html#a93accba5edcc96b461552d4a9483ec3d">More...</a><br /></td></tr>
<tr class="separator:a93accba5edcc96b461552d4a9483ec3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22953e4bba13494766ec2fc06ea1744"><td class="memTemplParams" colspan="2">template&lt;typename N , typename T , typename std::enable_if&lt; detail::is_numeric_v&lt; N &gt; &amp;&amp;(detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value)&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ae22953e4bba13494766ec2fc06ea1744"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ae22953e4bba13494766ec2fc06ea1744">operator*</a> (N left, const T &amp;right)</td></tr>
<tr class="memdesc:ae22953e4bba13494766ec2fc06ea1744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of <code>right</code> that is scaled by <code>left</code>.  <a href="namespace_tiled_array.html#ae22953e4bba13494766ec2fc06ea1744">More...</a><br /></td></tr>
<tr class="separator:ae22953e4bba13494766ec2fc06ea1744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90b5d6c5aae4293d2b9d3456477aeba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ac90b5d6c5aae4293d2b9d3456477aeba"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac90b5d6c5aae4293d2b9d3456477aeba">operator-</a> (const T &amp;arg) -&gt; decltype(arg.neg())</td></tr>
<tr class="memdesc:ac90b5d6c5aae4293d2b9d3456477aeba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a negated copy of <code>arg</code>.  <a href="namespace_tiled_array.html#ac90b5d6c5aae4293d2b9d3456477aeba">More...</a><br /></td></tr>
<tr class="separator:ac90b5d6c5aae4293d2b9d3456477aeba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b58b8591b03eebae61c177036697562"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a5b58b8591b03eebae61c177036697562"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a5b58b8591b03eebae61c177036697562">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const T &amp;arg)</td></tr>
<tr class="memdesc:a5b58b8591b03eebae61c177036697562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a permuted copy of <code>arg</code>.  <a href="namespace_tiled_array.html#a5b58b8591b03eebae61c177036697562">More...</a><br /></td></tr>
<tr class="separator:a5b58b8591b03eebae61c177036697562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f076f0602b99660440a31b1290dcba7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt; detail::is_tensor&lt; T1, T2 &gt;::value||detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a9f076f0602b99660440a31b1290dcba7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a9f076f0602b99660440a31b1290dcba7">operator+=</a> (T1 &amp;left, const T2 &amp;right)</td></tr>
<tr class="memdesc:a9f076f0602b99660440a31b1290dcba7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> plus operator.  <a href="namespace_tiled_array.html#a9f076f0602b99660440a31b1290dcba7">More...</a><br /></td></tr>
<tr class="separator:a9f076f0602b99660440a31b1290dcba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ca0c0a8f3a232c9d615ffd6e84e41f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt; detail::is_tensor&lt; T1, T2 &gt;::value||detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a21ca0c0a8f3a232c9d615ffd6e84e41f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a21ca0c0a8f3a232c9d615ffd6e84e41f">operator-=</a> (T1 &amp;left, const T2 &amp;right)</td></tr>
<tr class="memdesc:a21ca0c0a8f3a232c9d615ffd6e84e41f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> minus operator.  <a href="namespace_tiled_array.html#a21ca0c0a8f3a232c9d615ffd6e84e41f">More...</a><br /></td></tr>
<tr class="separator:a21ca0c0a8f3a232c9d615ffd6e84e41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf25c7dbd596cf41749f0c284a09eafd"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt; detail::is_tensor&lt; T1, T2 &gt;::value||detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aaf25c7dbd596cf41749f0c284a09eafd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aaf25c7dbd596cf41749f0c284a09eafd">operator*=</a> (T1 &amp;left, const T2 &amp;right)</td></tr>
<tr class="memdesc:aaf25c7dbd596cf41749f0c284a09eafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">In place tensor multiplication.  <a href="namespace_tiled_array.html#aaf25c7dbd596cf41749f0c284a09eafd">More...</a><br /></td></tr>
<tr class="separator:aaf25c7dbd596cf41749f0c284a09eafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868921cf563ff1fb9f3304bc314fec22"><td class="memTemplParams" colspan="2">template&lt;typename T , typename N , typename std::enable_if&lt;(detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value) &amp;&amp;detail::is_numeric_v&lt; N &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a868921cf563ff1fb9f3304bc314fec22"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a868921cf563ff1fb9f3304bc314fec22">operator+=</a> (T &amp;left, N right)</td></tr>
<tr class="memdesc:a868921cf563ff1fb9f3304bc314fec22"><td class="mdescLeft">&#160;</td><td class="mdescRight">In place tensor add constant.  <a href="namespace_tiled_array.html#a868921cf563ff1fb9f3304bc314fec22">More...</a><br /></td></tr>
<tr class="separator:a868921cf563ff1fb9f3304bc314fec22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3890c67d7f105e091e0f6114b9c56c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename N , typename std::enable_if&lt;(detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value) &amp;&amp;detail::is_numeric_v&lt; N &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:acf3890c67d7f105e091e0f6114b9c56c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#acf3890c67d7f105e091e0f6114b9c56c">operator-=</a> (T &amp;left, N right)</td></tr>
<tr class="memdesc:acf3890c67d7f105e091e0f6114b9c56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">In place tensor subtract constant.  <a href="namespace_tiled_array.html#acf3890c67d7f105e091e0f6114b9c56c">More...</a><br /></td></tr>
<tr class="separator:acf3890c67d7f105e091e0f6114b9c56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1493d57cb2d466240eeaef8e173cf6b2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename N , typename std::enable_if&lt;(detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value) &amp;&amp;detail::is_numeric_v&lt; N &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a1493d57cb2d466240eeaef8e173cf6b2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a1493d57cb2d466240eeaef8e173cf6b2">operator*=</a> (T &amp;left, N right)</td></tr>
<tr class="memdesc:a1493d57cb2d466240eeaef8e173cf6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">In place tensor scale.  <a href="namespace_tiled_array.html#a1493d57cb2d466240eeaef8e173cf6b2">More...</a><br /></td></tr>
<tr class="separator:a1493d57cb2d466240eeaef8e173cf6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed423a0b023a4a5aadfb5012d968a4a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ed423a0b023a4a5aadfb5012d968a4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html">detail::ShiftWrapper</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3ed423a0b023a4a5aadfb5012d968a4a">shift</a> (T &amp;tensor)</td></tr>
<tr class="memdesc:a3ed423a0b023a4a5aadfb5012d968a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> a tensor from one range to another.  <a href="namespace_tiled_array.html#a3ed423a0b023a4a5aadfb5012d968a4a">More...</a><br /></td></tr>
<tr class="separator:a3ed423a0b023a4a5aadfb5012d968a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b1b3fec016be7c5ed4230f72e5b29d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62b1b3fec016be7c5ed4230f72e5b29d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html">detail::ShiftWrapper</a>&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a62b1b3fec016be7c5ed4230f72e5b29d">shift</a> (const T &amp;tensor)</td></tr>
<tr class="memdesc:a62b1b3fec016be7c5ed4230f72e5b29d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> a tensor from one range to another.  <a href="namespace_tiled_array.html#a62b1b3fec016be7c5ed4230f72e5b29d">More...</a><br /></td></tr>
<tr class="separator:a62b1b3fec016be7c5ed4230f72e5b29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15916eaafd6285509fe08919de285f23"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a15916eaafd6285509fe08919de285f23"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a15916eaafd6285509fe08919de285f23">operator==</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;a, const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;b)</td></tr>
<tr class="separator:a15916eaafd6285509fe08919de285f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3316fbfa5aa7fe5314bf54670d198bee"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a3316fbfa5aa7fe5314bf54670d198bee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3316fbfa5aa7fe5314bf54670d198bee">operator!=</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;a, const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;b)</td></tr>
<tr class="separator:a3316fbfa5aa7fe5314bf54670d198bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3eccf37d7d009fa685a2a3e3e42b6b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_ , typename OpResult , typename Index1 , typename Index2 &gt; </td></tr>
<tr class="memitem:a3f3eccf37d7d009fa685a2a3e3e42b6b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3f3eccf37d7d009fa685a2a3e3e42b6b">remap</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; T, Range_, OpResult &gt; &amp;, T *const, const Index1 &amp;, const Index2 &amp;)</td></tr>
<tr class="separator:a3f3eccf37d7d009fa685a2a3e3e42b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db494b2ac41df5b86b630c1af56ce3c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_ , typename OpResult , typename Index1 , typename Index2 &gt; </td></tr>
<tr class="memitem:a3db494b2ac41df5b86b630c1af56ce3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3db494b2ac41df5b86b630c1af56ce3c">remap</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; const T, Range_, OpResult &gt; &amp;, T *const, const Index1 &amp;, const Index2 &amp;)</td></tr>
<tr class="separator:a3db494b2ac41df5b86b630c1af56ce3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3322ef849eda8162808382d772564c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_ , typename OpResult , typename Index1 , typename Index2 &gt; </td></tr>
<tr class="memitem:a1f3322ef849eda8162808382d772564c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a1f3322ef849eda8162808382d772564c">remap</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; T, Range_, OpResult &gt; &amp;, T *const, const std::initializer_list&lt; Index1 &gt; &amp;, const std::initializer_list&lt; Index2 &gt; &amp;)</td></tr>
<tr class="separator:a1f3322ef849eda8162808382d772564c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c838835577e8b9255dd7eaa44eceeee"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_ , typename OpResult , typename Index1 , typename Index2 &gt; </td></tr>
<tr class="memitem:a8c838835577e8b9255dd7eaa44eceeee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a8c838835577e8b9255dd7eaa44eceeee">remap</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; const T, Range_, OpResult &gt; &amp;, T *const, const std::initializer_list&lt; Index1 &gt; &amp;, const std::initializer_list&lt; Index2 &gt; &amp;)</td></tr>
<tr class="separator:a8c838835577e8b9255dd7eaa44eceeee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676ce2ab1b89d4f820aba886f9ce12a7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_  = Range, typename OpResult  = Tensor&lt;T&gt;, typename Index &gt; </td></tr>
<tr class="memitem:a676ce2ab1b89d4f820aba886f9ce12a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#acf8bdb4a9d561d001f7a34f49c077a5c">TensorMap</a>&lt; T, Range_, OpResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a676ce2ab1b89d4f820aba886f9ce12a7">make_map</a> (T *const data, const Index &amp;lower_bound, const Index &amp;upper_bound)</td></tr>
<tr class="separator:a676ce2ab1b89d4f820aba886f9ce12a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae62f2e2cc4456fa20849bfa583edd8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_  = Range, typename OpResult  = Tensor&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a3ae62f2e2cc4456fa20849bfa583edd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#acf8bdb4a9d561d001f7a34f49c077a5c">TensorMap</a>&lt; T, Range_, OpResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3ae62f2e2cc4456fa20849bfa583edd8">make_map</a> (T *const data, const std::initializer_list&lt; std::size_t &gt; &amp;lower_bound, const std::initializer_list&lt; std::size_t &gt; &amp;upper_bound)</td></tr>
<tr class="separator:a3ae62f2e2cc4456fa20849bfa583edd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ca6f02c32be6cf9e395e79b6d15521"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_ , typename OpResult  = Tensor&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a46ca6f02c32be6cf9e395e79b6d15521"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#acf8bdb4a9d561d001f7a34f49c077a5c">TensorMap</a>&lt; T, std::decay_t&lt; Range_ &gt;, OpResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a46ca6f02c32be6cf9e395e79b6d15521">make_map</a> (T *const data, Range_ &amp;&amp;range)</td></tr>
<tr class="separator:a46ca6f02c32be6cf9e395e79b6d15521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bfbeb46b2175bef60689e6c813d2c3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_  = Range, typename OpResult  = Tensor&lt;T&gt;, typename Index &gt; </td></tr>
<tr class="memitem:a69bfbeb46b2175bef60689e6c813d2c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a362559c766dfbca887fc6dff5523fb3b">TensorConstMap</a>&lt; T, Range_, OpResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a69bfbeb46b2175bef60689e6c813d2c3">make_map</a> (const T *const data, const Index &amp;lower_bound, const Index &amp;upper_bound)</td></tr>
<tr class="separator:a69bfbeb46b2175bef60689e6c813d2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894dfdb7e721f1e7f50ac49555412636"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_  = Range, typename OpResult  = Tensor&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a894dfdb7e721f1e7f50ac49555412636"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a362559c766dfbca887fc6dff5523fb3b">TensorConstMap</a>&lt; T, Range_, OpResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a894dfdb7e721f1e7f50ac49555412636">make_map</a> (const T *const data, const std::initializer_list&lt; std::size_t &gt; &amp;lower_bound, const std::initializer_list&lt; std::size_t &gt; &amp;upper_bound)</td></tr>
<tr class="separator:a894dfdb7e721f1e7f50ac49555412636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1be30c56b5b6bf89be779ab1103d23c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_ , typename OpResult  = Tensor&lt;T&gt;&gt; </td></tr>
<tr class="memitem:aa1be30c56b5b6bf89be779ab1103d23c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a362559c766dfbca887fc6dff5523fb3b">TensorConstMap</a>&lt; T, std::decay_t&lt; Range_ &gt;, OpResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa1be30c56b5b6bf89be779ab1103d23c">make_map</a> (const T *const data, Range_ &amp;&amp;range)</td></tr>
<tr class="separator:aa1be30c56b5b6bf89be779ab1103d23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc8675b642f53bdab884e5a6c473103"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_  = Range, typename OpResult  = Tensor&lt;T&gt;, typename Index &gt; </td></tr>
<tr class="memitem:a4fc8675b642f53bdab884e5a6c473103"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a362559c766dfbca887fc6dff5523fb3b">TensorConstMap</a>&lt; T, Range_, OpResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4fc8675b642f53bdab884e5a6c473103">make_const_map</a> (const T *const data, const Index &amp;lower_bound, const Index &amp;upper_bound)</td></tr>
<tr class="separator:a4fc8675b642f53bdab884e5a6c473103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04aee79763cf537e55a3a4805978860e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_  = Range, typename OpResult  = Tensor&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a04aee79763cf537e55a3a4805978860e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a362559c766dfbca887fc6dff5523fb3b">TensorConstMap</a>&lt; T, Range_, OpResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a04aee79763cf537e55a3a4805978860e">make_const_map</a> (const T *const data, const std::initializer_list&lt; std::size_t &gt; &amp;lower_bound, const std::initializer_list&lt; std::size_t &gt; &amp;upper_bound)</td></tr>
<tr class="separator:a04aee79763cf537e55a3a4805978860e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1dbc423a60cd4dc28b579d248408fb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_ , typename OpResult  = Tensor&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a6e1dbc423a60cd4dc28b579d248408fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a362559c766dfbca887fc6dff5523fb3b">TensorConstMap</a>&lt; T, std::decay_t&lt; Range_ &gt;, OpResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a6e1dbc423a60cd4dc28b579d248408fb">make_const_map</a> (const T *const data, Range_ &amp;&amp;range)</td></tr>
<tr class="separator:a6e1dbc423a60cd4dc28b579d248408fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c3e42482ba47e674bb8b56e0e9428d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_ , typename OpResult  = Tensor&lt;T&gt;, typename Index &gt; </td></tr>
<tr class="memitem:a61c3e42482ba47e674bb8b56e0e9428d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a362559c766dfbca887fc6dff5523fb3b">TensorConstMap</a>&lt; T, Range_, OpResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a61c3e42482ba47e674bb8b56e0e9428d">make_const_map</a> (T *const data, const Index &amp;lower_bound, const Index &amp;upper_bound)</td></tr>
<tr class="separator:a61c3e42482ba47e674bb8b56e0e9428d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4a56fbb5e457904a047ba0ebbceb7e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_ , typename OpResult  = Tensor&lt;T&gt;&gt; </td></tr>
<tr class="memitem:aef4a56fbb5e457904a047ba0ebbceb7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a362559c766dfbca887fc6dff5523fb3b">TensorConstMap</a>&lt; T, Range_, OpResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aef4a56fbb5e457904a047ba0ebbceb7e">make_const_map</a> (T *const data, const std::initializer_list&lt; std::size_t &gt; &amp;lower_bound, const std::initializer_list&lt; std::size_t &gt; &amp;upper_bound)</td></tr>
<tr class="separator:aef4a56fbb5e457904a047ba0ebbceb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7fe8e8790e1238ab0e7f47ef78a7d2c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_ , typename OpResult  = Tensor&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ae7fe8e8790e1238ab0e7f47ef78a7d2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a362559c766dfbca887fc6dff5523fb3b">TensorConstMap</a>&lt; T, std::decay_t&lt; Range_ &gt;, OpResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ae7fe8e8790e1238ab0e7f47ef78a7d2c">make_const_map</a> (T *const data, Range_ &amp;&amp;range)</td></tr>
<tr class="separator:ae7fe8e8790e1238ab0e7f47ef78a7d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87cc62a790937f001093b0677471e61"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_ , typename OpResult , typename Index1 , typename Index2 &gt; </td></tr>
<tr class="memitem:ab87cc62a790937f001093b0677471e61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ab87cc62a790937f001093b0677471e61">remap</a> (<a class="el" href="namespace_tiled_array.html#acf8bdb4a9d561d001f7a34f49c077a5c">TensorMap</a>&lt; T, Range_, OpResult &gt; &amp;map, T *const data, const Index1 &amp;lower_bound, const Index2 &amp;upper_bound)</td></tr>
<tr class="memdesc:ab87cc62a790937f001093b0677471e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">For reusing map without allocating new ranges . . . maybe.  <a href="namespace_tiled_array.html#ab87cc62a790937f001093b0677471e61">More...</a><br /></td></tr>
<tr class="separator:ab87cc62a790937f001093b0677471e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da7247ef54c50ac1e2cc8c51d3e8bac"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_ , typename OpResult , typename Index1 , typename Index2 , typename  = std::enable_if_t&lt;!std::is_const&lt;T&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a4da7247ef54c50ac1e2cc8c51d3e8bac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4da7247ef54c50ac1e2cc8c51d3e8bac">remap</a> (<a class="el" href="namespace_tiled_array.html#a362559c766dfbca887fc6dff5523fb3b">TensorConstMap</a>&lt; T, Range_, OpResult &gt; &amp;map, T *const data, const Index1 &amp;lower_bound, const Index2 &amp;upper_bound)</td></tr>
<tr class="separator:a4da7247ef54c50ac1e2cc8c51d3e8bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9555255255f82b5cb66cfd240db0cad5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_ , typename OpResult , typename Index1 , typename Index2 &gt; </td></tr>
<tr class="memitem:a9555255255f82b5cb66cfd240db0cad5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a9555255255f82b5cb66cfd240db0cad5">remap</a> (<a class="el" href="namespace_tiled_array.html#acf8bdb4a9d561d001f7a34f49c077a5c">TensorMap</a>&lt; T, Range_, OpResult &gt; &amp;map, T *const data, const std::initializer_list&lt; Index1 &gt; &amp;lower_bound, const std::initializer_list&lt; Index2 &gt; &amp;upper_bound)</td></tr>
<tr class="separator:a9555255255f82b5cb66cfd240db0cad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a8c53fcc8e44d44de78348bce433f7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_ , typename OpResult , typename Index1 , typename Index2 , typename  = std::enable_if_t&lt;!std::is_const&lt;T&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a06a8c53fcc8e44d44de78348bce433f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a06a8c53fcc8e44d44de78348bce433f7">remap</a> (<a class="el" href="namespace_tiled_array.html#a362559c766dfbca887fc6dff5523fb3b">TensorConstMap</a>&lt; T, Range_, OpResult &gt; &amp;map, T *const data, const std::initializer_list&lt; Index1 &gt; &amp;lower_bound, const std::initializer_list&lt; Index2 &gt; &amp;upper_bound)</td></tr>
<tr class="separator:a06a8c53fcc8e44d44de78348bce433f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d07017bf139b8ea4e344216443b372"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; detail::is_tensor&lt; T &gt;::value &amp;&amp;detail::is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a67d07017bf139b8ea4e344216443b372"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a67d07017bf139b8ea4e344216443b372">operator&lt;&lt;</a> (std::ostream &amp;os, const T &amp;t)</td></tr>
<tr class="memdesc:a67d07017bf139b8ea4e344216443b372"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> output operator.  <a href="namespace_tiled_array.html#a67d07017bf139b8ea4e344216443b372">More...</a><br /></td></tr>
<tr class="separator:a67d07017bf139b8ea4e344216443b372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec378f0f4b197546fb0b69f16748bfa1"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gaec378f0f4b197546fb0b69f16748bfa1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gaec378f0f4b197546fb0b69f16748bfa1">clone</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:gaec378f0f4b197546fb0b69f16748bfa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of <code>arg</code>.  <a href="group___tile_interface.html#gaec378f0f4b197546fb0b69f16748bfa1">More...</a><br /></td></tr>
<tr class="separator:gaec378f0f4b197546fb0b69f16748bfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd7e8d783c93f6a965a52cfc7124b6d0"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gacd7e8d783c93f6a965a52cfc7124b6d0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gacd7e8d783c93f6a965a52cfc7124b6d0">empty</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:gacd7e8d783c93f6a965a52cfc7124b6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that <code>arg</code> is empty (no data)  <a href="group___tile_interface.html#gacd7e8d783c93f6a965a52cfc7124b6d0">More...</a><br /></td></tr>
<tr class="separator:gacd7e8d783c93f6a965a52cfc7124b6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab21c3c768743ce8dec32ae106a3e79ca"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:gab21c3c768743ce8dec32ae106a3e79ca"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gab21c3c768743ce8dec32ae106a3e79ca">permute</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Perm &amp;perm)</td></tr>
<tr class="memdesc:gab21c3c768743ce8dec32ae106a3e79ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a permuted copy of <code>arg</code>.  <a href="group___tile_interface.html#gab21c3c768743ce8dec32ae106a3e79ca">More...</a><br /></td></tr>
<tr class="separator:gab21c3c768743ce8dec32ae106a3e79ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacca0c957b239734acfa9b111a65736df"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Index , typename  = std::enable_if_t&lt;detail::is_integral_range_v&lt;Index&gt;&gt;&gt; </td></tr>
<tr class="memitem:gacca0c957b239734acfa9b111a65736df"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gacca0c957b239734acfa9b111a65736df">shift</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Index &amp;range_shift)</td></tr>
<tr class="memdesc:gacca0c957b239734acfa9b111a65736df"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> the range of <code>arg</code>.  <a href="group___tile_interface.html#gacca0c957b239734acfa9b111a65736df">More...</a><br /></td></tr>
<tr class="separator:gacca0c957b239734acfa9b111a65736df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf929275ada4366f78a7fcc27146a125c"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Index , typename  = std::enable_if_t&lt;std::is_integral_v&lt;Index&gt;&gt;&gt; </td></tr>
<tr class="memitem:gaf929275ada4366f78a7fcc27146a125c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gaf929275ada4366f78a7fcc27146a125c">shift</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const std::initializer_list&lt; Index &gt; &amp;range_shift)</td></tr>
<tr class="memdesc:gaf929275ada4366f78a7fcc27146a125c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> the range of <code>arg</code>.  <a href="group___tile_interface.html#gaf929275ada4366f78a7fcc27146a125c">More...</a><br /></td></tr>
<tr class="separator:gaf929275ada4366f78a7fcc27146a125c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10e76f18a1f5bfd9efe378b1330c0e57"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Index , typename  = std::enable_if_t&lt;detail::is_integral_range_v&lt;Index&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga10e76f18a1f5bfd9efe378b1330c0e57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga10e76f18a1f5bfd9efe378b1330c0e57">shift_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Index &amp;range_shift)</td></tr>
<tr class="memdesc:ga10e76f18a1f5bfd9efe378b1330c0e57"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> the range of <code>arg</code> in place.  <a href="group___tile_interface.html#ga10e76f18a1f5bfd9efe378b1330c0e57">More...</a><br /></td></tr>
<tr class="separator:ga10e76f18a1f5bfd9efe378b1330c0e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f49789b2f257dee9fccbae4389d8667"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Index , typename  = std::enable_if_t&lt;std::is_integral_v&lt;Index&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga2f49789b2f257dee9fccbae4389d8667"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga2f49789b2f257dee9fccbae4389d8667">shift_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const std::initializer_list&lt; Index &gt; &amp;range_shift)</td></tr>
<tr class="memdesc:ga2f49789b2f257dee9fccbae4389d8667"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> the range of <code>arg</code> in place.  <a href="group___tile_interface.html#ga2f49789b2f257dee9fccbae4389d8667">More...</a><br /></td></tr>
<tr class="separator:ga2f49789b2f257dee9fccbae4389d8667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f9977ff8130c6b95fc646e6a968f7a6"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga4f9977ff8130c6b95fc646e6a968f7a6"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga4f9977ff8130c6b95fc646e6a968f7a6">add</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right)</td></tr>
<tr class="memdesc:ga4f9977ff8130c6b95fc646e6a968f7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> tile arguments.  <a href="group___tile_interface.html#ga4f9977ff8130c6b95fc646e6a968f7a6">More...</a><br /></td></tr>
<tr class="separator:ga4f9977ff8130c6b95fc646e6a968f7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac080bac89fc26e28adc8ce434f7098bd"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gac080bac89fc26e28adc8ce434f7098bd"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gac080bac89fc26e28adc8ce434f7098bd">add</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Scalar factor)</td></tr>
<tr class="memdesc:gac080bac89fc26e28adc8ce434f7098bd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> and scale tile arguments.  <a href="group___tile_interface.html#gac080bac89fc26e28adc8ce434f7098bd">More...</a><br /></td></tr>
<tr class="separator:gac080bac89fc26e28adc8ce434f7098bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b51af7755c9597bd3422e051003e61a"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga4b51af7755c9597bd3422e051003e61a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga4b51af7755c9597bd3422e051003e61a">add</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Perm &amp;perm)</td></tr>
<tr class="memdesc:ga4b51af7755c9597bd3422e051003e61a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> and permute tile arguments.  <a href="group___tile_interface.html#ga4b51af7755c9597bd3422e051003e61a">More...</a><br /></td></tr>
<tr class="separator:ga4b51af7755c9597bd3422e051003e61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f90855310c2bbb9a0af75e16895513c"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename Perm , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0f90855310c2bbb9a0af75e16895513c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga0f90855310c2bbb9a0af75e16895513c">add</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Scalar factor, const Perm &amp;perm)</td></tr>
<tr class="memdesc:ga0f90855310c2bbb9a0af75e16895513c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a>, scale, and permute tile arguments.  <a href="group___tile_interface.html#ga0f90855310c2bbb9a0af75e16895513c">More...</a><br /></td></tr>
<tr class="separator:ga0f90855310c2bbb9a0af75e16895513c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacad2b52ab350044c8742ec1eef39a0b"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gaacad2b52ab350044c8742ec1eef39a0b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gaacad2b52ab350044c8742ec1eef39a0b">add</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar value)</td></tr>
<tr class="memdesc:gaacad2b52ab350044c8742ec1eef39a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> a constant scalar to tile argument.  <a href="group___tile_interface.html#gaacad2b52ab350044c8742ec1eef39a0b">More...</a><br /></td></tr>
<tr class="separator:gaacad2b52ab350044c8742ec1eef39a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32d91f6977425c0432a88269b3344a8f"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename Perm , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga32d91f6977425c0432a88269b3344a8f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga32d91f6977425c0432a88269b3344a8f">add</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar value, const Perm &amp;perm)</td></tr>
<tr class="memdesc:ga32d91f6977425c0432a88269b3344a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> a constant scalar and permute tile argument.  <a href="group___tile_interface.html#ga32d91f6977425c0432a88269b3344a8f">More...</a><br /></td></tr>
<tr class="separator:ga32d91f6977425c0432a88269b3344a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eaf2e2efc1f2ca1fca6e5e2fcee256e"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg &gt; </td></tr>
<tr class="memitem:ga5eaf2e2efc1f2ca1fca6e5e2fcee256e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga5eaf2e2efc1f2ca1fca6e5e2fcee256e">add_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:ga5eaf2e2efc1f2ca1fca6e5e2fcee256e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> to the result tile.  <a href="group___tile_interface.html#ga5eaf2e2efc1f2ca1fca6e5e2fcee256e">More...</a><br /></td></tr>
<tr class="separator:ga5eaf2e2efc1f2ca1fca6e5e2fcee256e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dabb8dd35f758019c80da238cf50196"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6dabb8dd35f758019c80da238cf50196"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga6dabb8dd35f758019c80da238cf50196">add_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:ga6dabb8dd35f758019c80da238cf50196"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> and scale to the result tile.  <a href="group___tile_interface.html#ga6dabb8dd35f758019c80da238cf50196">More...</a><br /></td></tr>
<tr class="separator:ga6dabb8dd35f758019c80da238cf50196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0887904f4fbb716dec1467ff37bcdef6"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0887904f4fbb716dec1467ff37bcdef6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga0887904f4fbb716dec1467ff37bcdef6">add_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const Scalar value)</td></tr>
<tr class="memdesc:ga0887904f4fbb716dec1467ff37bcdef6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> constant scalar to the result tile.  <a href="group___tile_interface.html#ga0887904f4fbb716dec1467ff37bcdef6">More...</a><br /></td></tr>
<tr class="separator:ga0887904f4fbb716dec1467ff37bcdef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58d10685bc8b980fed30a5e64db19caa"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga58d10685bc8b980fed30a5e64db19caa"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga58d10685bc8b980fed30a5e64db19caa">subt</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right)</td></tr>
<tr class="memdesc:ga58d10685bc8b980fed30a5e64db19caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract tile arguments.  <a href="group___tile_interface.html#ga58d10685bc8b980fed30a5e64db19caa">More...</a><br /></td></tr>
<tr class="separator:ga58d10685bc8b980fed30a5e64db19caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad477a9e151bd7d6bb29dacda947c83aa"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gad477a9e151bd7d6bb29dacda947c83aa"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gad477a9e151bd7d6bb29dacda947c83aa">subt</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Scalar factor)</td></tr>
<tr class="memdesc:gad477a9e151bd7d6bb29dacda947c83aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract and scale tile arguments.  <a href="group___tile_interface.html#gad477a9e151bd7d6bb29dacda947c83aa">More...</a><br /></td></tr>
<tr class="separator:gad477a9e151bd7d6bb29dacda947c83aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd2a9776bcaff14294ba03b107635b7c"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:gafd2a9776bcaff14294ba03b107635b7c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gafd2a9776bcaff14294ba03b107635b7c">subt</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Perm &amp;perm)</td></tr>
<tr class="memdesc:gafd2a9776bcaff14294ba03b107635b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract and permute tile arguments.  <a href="group___tile_interface.html#gafd2a9776bcaff14294ba03b107635b7c">More...</a><br /></td></tr>
<tr class="separator:gafd2a9776bcaff14294ba03b107635b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae48fee5e08995e96188e2797c491789a"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename Perm , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gae48fee5e08995e96188e2797c491789a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gae48fee5e08995e96188e2797c491789a">subt</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Scalar factor, const Perm &amp;perm)</td></tr>
<tr class="memdesc:gae48fee5e08995e96188e2797c491789a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract, scale, and permute tile arguments.  <a href="group___tile_interface.html#gae48fee5e08995e96188e2797c491789a">More...</a><br /></td></tr>
<tr class="separator:gae48fee5e08995e96188e2797c491789a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac48dff1fb3c32301f8a1d970dd28a447"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gac48dff1fb3c32301f8a1d970dd28a447"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gac48dff1fb3c32301f8a1d970dd28a447">subt</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar value)</td></tr>
<tr class="memdesc:gac48dff1fb3c32301f8a1d970dd28a447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a scalar constant from the tile argument.  <a href="group___tile_interface.html#gac48dff1fb3c32301f8a1d970dd28a447">More...</a><br /></td></tr>
<tr class="separator:gac48dff1fb3c32301f8a1d970dd28a447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b21588dd3509876ffd41d2b6d02db05"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename Perm , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1b21588dd3509876ffd41d2b6d02db05"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga1b21588dd3509876ffd41d2b6d02db05">subt</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar value, const Perm &amp;perm)</td></tr>
<tr class="memdesc:ga1b21588dd3509876ffd41d2b6d02db05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a constant scalar and permute tile argument.  <a href="group___tile_interface.html#ga1b21588dd3509876ffd41d2b6d02db05">More...</a><br /></td></tr>
<tr class="separator:ga1b21588dd3509876ffd41d2b6d02db05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67b0fd498d81c2a5898673bcb0152934"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg &gt; </td></tr>
<tr class="memitem:ga67b0fd498d81c2a5898673bcb0152934"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga67b0fd498d81c2a5898673bcb0152934">subt_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:ga67b0fd498d81c2a5898673bcb0152934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract from the result tile.  <a href="group___tile_interface.html#ga67b0fd498d81c2a5898673bcb0152934">More...</a><br /></td></tr>
<tr class="separator:ga67b0fd498d81c2a5898673bcb0152934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3857edf071769c169d08af65690063eb"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3857edf071769c169d08af65690063eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga3857edf071769c169d08af65690063eb">subt_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:ga3857edf071769c169d08af65690063eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract and scale from the result tile.  <a href="group___tile_interface.html#ga3857edf071769c169d08af65690063eb">More...</a><br /></td></tr>
<tr class="separator:ga3857edf071769c169d08af65690063eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc7653e81aa69141646e7c93b916fadb"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gafc7653e81aa69141646e7c93b916fadb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gafc7653e81aa69141646e7c93b916fadb">subt_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const Scalar value)</td></tr>
<tr class="memdesc:gafc7653e81aa69141646e7c93b916fadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract constant scalar from the result tile.  <a href="group___tile_interface.html#gafc7653e81aa69141646e7c93b916fadb">More...</a><br /></td></tr>
<tr class="separator:gafc7653e81aa69141646e7c93b916fadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf465d9c7b7f7d31918a6150c9d51ca40"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:gaf465d9c7b7f7d31918a6150c9d51ca40"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gaf465d9c7b7f7d31918a6150c9d51ca40">mult</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right)</td></tr>
<tr class="memdesc:gaf465d9c7b7f7d31918a6150c9d51ca40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication tile arguments.  <a href="group___tile_interface.html#gaf465d9c7b7f7d31918a6150c9d51ca40">More...</a><br /></td></tr>
<tr class="separator:gaf465d9c7b7f7d31918a6150c9d51ca40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27e2e80dcf97b3ad64e8797e2226a432"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga27e2e80dcf97b3ad64e8797e2226a432"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga27e2e80dcf97b3ad64e8797e2226a432">mult</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Scalar factor)</td></tr>
<tr class="memdesc:ga27e2e80dcf97b3ad64e8797e2226a432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication and scale tile arguments.  <a href="group___tile_interface.html#ga27e2e80dcf97b3ad64e8797e2226a432">More...</a><br /></td></tr>
<tr class="separator:ga27e2e80dcf97b3ad64e8797e2226a432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d8fd1b5628ed84b16e682d52b3de833"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga0d8fd1b5628ed84b16e682d52b3de833"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga0d8fd1b5628ed84b16e682d52b3de833">mult</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Perm &amp;perm)</td></tr>
<tr class="memdesc:ga0d8fd1b5628ed84b16e682d52b3de833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication and permute tile arguments.  <a href="group___tile_interface.html#ga0d8fd1b5628ed84b16e682d52b3de833">More...</a><br /></td></tr>
<tr class="separator:ga0d8fd1b5628ed84b16e682d52b3de833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e407269a49cf52f8797aaa2043ca4e2"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename Perm , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2e407269a49cf52f8797aaa2043ca4e2"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga2e407269a49cf52f8797aaa2043ca4e2">mult</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Scalar factor, const Perm &amp;perm)</td></tr>
<tr class="memdesc:ga2e407269a49cf52f8797aaa2043ca4e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication, scale, and permute tile arguments.  <a href="group___tile_interface.html#ga2e407269a49cf52f8797aaa2043ca4e2">More...</a><br /></td></tr>
<tr class="separator:ga2e407269a49cf52f8797aaa2043ca4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad37039529fef4c507e5e5ecf379edf38"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg &gt; </td></tr>
<tr class="memitem:gad37039529fef4c507e5e5ecf379edf38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gad37039529fef4c507e5e5ecf379edf38">mult_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:gad37039529fef4c507e5e5ecf379edf38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply to the result tile.  <a href="group___tile_interface.html#gad37039529fef4c507e5e5ecf379edf38">More...</a><br /></td></tr>
<tr class="separator:gad37039529fef4c507e5e5ecf379edf38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff6e36fcc141764f788ab1eb59965a8c"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gaff6e36fcc141764f788ab1eb59965a8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gaff6e36fcc141764f788ab1eb59965a8c">mult_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:gaff6e36fcc141764f788ab1eb59965a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and scale to the result tile.  <a href="group___tile_interface.html#gaff6e36fcc141764f788ab1eb59965a8c">More...</a><br /></td></tr>
<tr class="separator:gaff6e36fcc141764f788ab1eb59965a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eb0d0c051737f67276e03e895aefad9"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Op &gt; </td></tr>
<tr class="memitem:ga4eb0d0c051737f67276e03e895aefad9"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga4eb0d0c051737f67276e03e895aefad9">binary</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:ga4eb0d0c051737f67276e03e895aefad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary element-wise transform producing a new tile.  <a href="group___tile_interface.html#ga4eb0d0c051737f67276e03e895aefad9">More...</a><br /></td></tr>
<tr class="separator:ga4eb0d0c051737f67276e03e895aefad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga691bf0934b03444773dd5568dcf342db"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Op , typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga691bf0934b03444773dd5568dcf342db"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga691bf0934b03444773dd5568dcf342db">binary</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, Op &amp;&amp;op, const Perm &amp;perm)</td></tr>
<tr class="memdesc:ga691bf0934b03444773dd5568dcf342db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary element-wise transform producing a new tile.  <a href="group___tile_interface.html#ga691bf0934b03444773dd5568dcf342db">More...</a><br /></td></tr>
<tr class="separator:ga691bf0934b03444773dd5568dcf342db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dd0527cbaf5c320eb78d1f53711305b"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Op &gt; </td></tr>
<tr class="memitem:ga2dd0527cbaf5c320eb78d1f53711305b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga2dd0527cbaf5c320eb78d1f53711305b">inplace_binary</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:ga2dd0527cbaf5c320eb78d1f53711305b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary element-wise in-place transform.  <a href="group___tile_interface.html#ga2dd0527cbaf5c320eb78d1f53711305b">More...</a><br /></td></tr>
<tr class="separator:ga2dd0527cbaf5c320eb78d1f53711305b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebe37fcda193946fcc4501b42796e9cc"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gaebe37fcda193946fcc4501b42796e9cc"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gaebe37fcda193946fcc4501b42796e9cc">scale</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:gaebe37fcda193946fcc4501b42796e9cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar the tile argument.  <a href="group___tile_interface.html#gaebe37fcda193946fcc4501b42796e9cc">More...</a><br /></td></tr>
<tr class="separator:gaebe37fcda193946fcc4501b42796e9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae20e928921671713350adf7ee214a1eb"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename Perm , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gae20e928921671713350adf7ee214a1eb"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gae20e928921671713350adf7ee214a1eb">scale</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar factor, const Perm &amp;perm)</td></tr>
<tr class="memdesc:gae20e928921671713350adf7ee214a1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile.">Scale</a> and permute tile argument.  <a href="group___tile_interface.html#gae20e928921671713350adf7ee214a1eb">More...</a><br /></td></tr>
<tr class="separator:gae20e928921671713350adf7ee214a1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga381f8c925fdcfdee5cfef07f66c4da25"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga381f8c925fdcfdee5cfef07f66c4da25"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga381f8c925fdcfdee5cfef07f66c4da25">scale_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const Scalar factor)</td></tr>
<tr class="memdesc:ga381f8c925fdcfdee5cfef07f66c4da25"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile.">Scale</a> to the result tile.  <a href="group___tile_interface.html#ga381f8c925fdcfdee5cfef07f66c4da25">More...</a><br /></td></tr>
<tr class="separator:ga381f8c925fdcfdee5cfef07f66c4da25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bd5665b8e247cd53460501c3f672751"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga6bd5665b8e247cd53460501c3f672751"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga6bd5665b8e247cd53460501c3f672751">neg</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:ga6bd5665b8e247cd53460501c3f672751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate the tile argument.  <a href="group___tile_interface.html#ga6bd5665b8e247cd53460501c3f672751">More...</a><br /></td></tr>
<tr class="separator:ga6bd5665b8e247cd53460501c3f672751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab58f7f1369d90de51ae9033dd601a6d6"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:gab58f7f1369d90de51ae9033dd601a6d6"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gab58f7f1369d90de51ae9033dd601a6d6">neg</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Perm &amp;perm)</td></tr>
<tr class="memdesc:gab58f7f1369d90de51ae9033dd601a6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate and permute tile argument.  <a href="group___tile_interface.html#gab58f7f1369d90de51ae9033dd601a6d6">More...</a><br /></td></tr>
<tr class="separator:gab58f7f1369d90de51ae9033dd601a6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f07b2f0fde49f0f04284bc3f6de3db4"><td class="memTemplParams" colspan="2">template&lt;typename Result &gt; </td></tr>
<tr class="memitem:ga7f07b2f0fde49f0f04284bc3f6de3db4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga7f07b2f0fde49f0f04284bc3f6de3db4">neg_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result)</td></tr>
<tr class="memdesc:ga7f07b2f0fde49f0f04284bc3f6de3db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place negate tile.  <a href="group___tile_interface.html#ga7f07b2f0fde49f0f04284bc3f6de3db4">More...</a><br /></td></tr>
<tr class="separator:ga7f07b2f0fde49f0f04284bc3f6de3db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d7a9a1250ba51b27addd91171a1c77f"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga4d7a9a1250ba51b27addd91171a1c77f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga4d7a9a1250ba51b27addd91171a1c77f">conj</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:ga4d7a9a1250ba51b27addd91171a1c77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated copy of a tile.  <a href="group___tile_interface.html#ga4d7a9a1250ba51b27addd91171a1c77f">More...</a><br /></td></tr>
<tr class="separator:ga4d7a9a1250ba51b27addd91171a1c77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac18ac642dbdbed016061d5cc969ffa2a"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gac18ac642dbdbed016061d5cc969ffa2a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gac18ac642dbdbed016061d5cc969ffa2a">conj</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:gac18ac642dbdbed016061d5cc969ffa2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated and scaled copy of a tile.  <a href="group___tile_interface.html#gac18ac642dbdbed016061d5cc969ffa2a">More...</a><br /></td></tr>
<tr class="separator:gac18ac642dbdbed016061d5cc969ffa2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45baae8352d9c8cd127f130b11d9d387"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga45baae8352d9c8cd127f130b11d9d387"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga45baae8352d9c8cd127f130b11d9d387">conj</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Perm &amp;perm)</td></tr>
<tr class="memdesc:ga45baae8352d9c8cd127f130b11d9d387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated and permuted copy of a tile.  <a href="group___tile_interface.html#ga45baae8352d9c8cd127f130b11d9d387">More...</a><br /></td></tr>
<tr class="separator:ga45baae8352d9c8cd127f130b11d9d387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7907664546d32b3e682914b7062ec7a"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename Perm , typename std::enable_if&lt; TiledArray::detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gad7907664546d32b3e682914b7062ec7a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gad7907664546d32b3e682914b7062ec7a">conj</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar factor, const Perm &amp;perm)</td></tr>
<tr class="memdesc:gad7907664546d32b3e682914b7062ec7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated, scaled, and permuted copy of a tile.  <a href="group___tile_interface.html#gad7907664546d32b3e682914b7062ec7a">More...</a><br /></td></tr>
<tr class="separator:gad7907664546d32b3e682914b7062ec7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d755d58b153633beaf43d985aa64081"><td class="memTemplParams" colspan="2">template&lt;typename Result &gt; </td></tr>
<tr class="memitem:ga5d755d58b153633beaf43d985aa64081"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga5d755d58b153633beaf43d985aa64081">conj_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result)</td></tr>
<tr class="memdesc:ga5d755d58b153633beaf43d985aa64081"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place complex conjugate a tile.  <a href="group___tile_interface.html#ga5d755d58b153633beaf43d985aa64081">More...</a><br /></td></tr>
<tr class="separator:ga5d755d58b153633beaf43d985aa64081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25dcafe9108060bbbc54cde4f7e64a13"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga25dcafe9108060bbbc54cde4f7e64a13"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga25dcafe9108060bbbc54cde4f7e64a13">conj_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const Scalar factor)</td></tr>
<tr class="memdesc:ga25dcafe9108060bbbc54cde4f7e64a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place complex conjugate and scale a tile.  <a href="group___tile_interface.html#ga25dcafe9108060bbbc54cde4f7e64a13">More...</a><br /></td></tr>
<tr class="separator:ga25dcafe9108060bbbc54cde4f7e64a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga547cfd18b8ef1453c69372f3fc121ba8"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Op &gt; </td></tr>
<tr class="memitem:ga547cfd18b8ef1453c69372f3fc121ba8"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga547cfd18b8ef1453c69372f3fc121ba8">unary</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:ga547cfd18b8ef1453c69372f3fc121ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary element-wise transform producing a new tile.  <a href="group___tile_interface.html#ga547cfd18b8ef1453c69372f3fc121ba8">More...</a><br /></td></tr>
<tr class="separator:ga547cfd18b8ef1453c69372f3fc121ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2723b061d47e32d4907b8ef580f33a4b"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Op , typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga2723b061d47e32d4907b8ef580f33a4b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga2723b061d47e32d4907b8ef580f33a4b">unary</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, Op &amp;&amp;op, const Perm &amp;perm)</td></tr>
<tr class="memdesc:ga2723b061d47e32d4907b8ef580f33a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary element-wise transform producing a new tile.  <a href="group___tile_interface.html#ga2723b061d47e32d4907b8ef580f33a4b">More...</a><br /></td></tr>
<tr class="separator:ga2723b061d47e32d4907b8ef580f33a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb6941017c1cc6484e4321220ac1c40c"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Op &gt; </td></tr>
<tr class="memitem:gabb6941017c1cc6484e4321220ac1c40c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gabb6941017c1cc6484e4321220ac1c40c">inplace_unary</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;arg, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:gabb6941017c1cc6484e4321220ac1c40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary element-wise in-place transform.  <a href="group___tile_interface.html#gabb6941017c1cc6484e4321220ac1c40c">More...</a><br /></td></tr>
<tr class="separator:gabb6941017c1cc6484e4321220ac1c40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f3a08fa940b7d1c314327430c604238"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1f3a08fa940b7d1c314327430c604238"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga1f3a08fa940b7d1c314327430c604238">gemm</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1math_1_1_gemm_helper.html">math::GemmHelper</a> &amp;gemm_config)</td></tr>
<tr class="memdesc:ga1f3a08fa940b7d1c314327430c604238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract 2 tensors over head/tail modes and scale the product.  <a href="group___tile_interface.html#ga1f3a08fa940b7d1c314327430c604238">More...</a><br /></td></tr>
<tr class="separator:ga1f3a08fa940b7d1c314327430c604238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cd5e3e8121313e9684e91cfa6230fd6"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5cd5e3e8121313e9684e91cfa6230fd6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga5cd5e3e8121313e9684e91cfa6230fd6">gemm</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1math_1_1_gemm_helper.html">math::GemmHelper</a> &amp;gemm_config)</td></tr>
<tr class="separator:ga5cd5e3e8121313e9684e91cfa6230fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d54218426c7c46531cd52ed8af61cb3"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Left , typename Right , typename ElementMultiplyAddOp , typename std::enable_if&lt; std::is_invocable_r_v&lt; void, std::remove_reference_t&lt; ElementMultiplyAddOp &gt;, typename Result::value_type &amp;, const typename Left::value_type &amp;, const typename Right::value_type &amp; &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5d54218426c7c46531cd52ed8af61cb3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga5d54218426c7c46531cd52ed8af61cb3">gemm</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const <a class="el" href="class_tiled_array_1_1math_1_1_gemm_helper.html">math::GemmHelper</a> &amp;gemm_config, ElementMultiplyAddOp &amp;&amp;element_multiplyadd_op)</td></tr>
<tr class="separator:ga5d54218426c7c46531cd52ed8af61cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72bc37c3b1bcb1f5bb7f630667243615"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga72bc37c3b1bcb1f5bb7f630667243615"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga72bc37c3b1bcb1f5bb7f630667243615">trace</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:ga72bc37c3b1bcb1f5bb7f630667243615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the hyper-diagonal elements a tile.  <a href="group___tile_interface.html#ga72bc37c3b1bcb1f5bb7f630667243615">More...</a><br /></td></tr>
<tr class="separator:ga72bc37c3b1bcb1f5bb7f630667243615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d9a467ed3849aacaab335e5eb2ed57"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga25d9a467ed3849aacaab335e5eb2ed57"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga25d9a467ed3849aacaab335e5eb2ed57">sum</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:ga25d9a467ed3849aacaab335e5eb2ed57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the elements of a tile.  <a href="group___tile_interface.html#ga25d9a467ed3849aacaab335e5eb2ed57">More...</a><br /></td></tr>
<tr class="separator:ga25d9a467ed3849aacaab335e5eb2ed57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada89177095dd6a757f26e7c45f3798b0"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gada89177095dd6a757f26e7c45f3798b0"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gada89177095dd6a757f26e7c45f3798b0">product</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:gada89177095dd6a757f26e7c45f3798b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply the elements of a tile.  <a href="group___tile_interface.html#gada89177095dd6a757f26e7c45f3798b0">More...</a><br /></td></tr>
<tr class="separator:gada89177095dd6a757f26e7c45f3798b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0367bc300cd4417138d2ac139048c234"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga0367bc300cd4417138d2ac139048c234"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga0367bc300cd4417138d2ac139048c234">squared_norm</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:ga0367bc300cd4417138d2ac139048c234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squared vector 2-norm of the elements of a tile.  <a href="group___tile_interface.html#ga0367bc300cd4417138d2ac139048c234">More...</a><br /></td></tr>
<tr class="separator:ga0367bc300cd4417138d2ac139048c234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf68ae245fa13091be35fcc8cad8b2ba6"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gaf68ae245fa13091be35fcc8cad8b2ba6"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gaf68ae245fa13091be35fcc8cad8b2ba6">norm</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:gaf68ae245fa13091be35fcc8cad8b2ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector 2-norm of a tile.  <a href="group___tile_interface.html#gaf68ae245fa13091be35fcc8cad8b2ba6">More...</a><br /></td></tr>
<tr class="separator:gaf68ae245fa13091be35fcc8cad8b2ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2ba6729821ea752fc81d96af65abd98"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename ResultType &gt; </td></tr>
<tr class="memitem:gaa2ba6729821ea752fc81d96af65abd98"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gaa2ba6729821ea752fc81d96af65abd98">norm</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, ResultType &amp;result)</td></tr>
<tr class="memdesc:gaa2ba6729821ea752fc81d96af65abd98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector 2-norm of a tile.  <a href="group___tile_interface.html#gaa2ba6729821ea752fc81d96af65abd98">More...</a><br /></td></tr>
<tr class="separator:gaa2ba6729821ea752fc81d96af65abd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace24afac354bfe849d2ca90df6ab8232"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gace24afac354bfe849d2ca90df6ab8232"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gace24afac354bfe849d2ca90df6ab8232">max</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:gace24afac354bfe849d2ca90df6ab8232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum element of a tile.  <a href="group___tile_interface.html#gace24afac354bfe849d2ca90df6ab8232">More...</a><br /></td></tr>
<tr class="separator:gace24afac354bfe849d2ca90df6ab8232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4d977af50ab495f09a985dbfb871a3d"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gad4d977af50ab495f09a985dbfb871a3d"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gad4d977af50ab495f09a985dbfb871a3d">min</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:gad4d977af50ab495f09a985dbfb871a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum element of a tile.  <a href="group___tile_interface.html#gad4d977af50ab495f09a985dbfb871a3d">More...</a><br /></td></tr>
<tr class="separator:gad4d977af50ab495f09a985dbfb871a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86214f440122e8aac85a93dce17e0d7d"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga86214f440122e8aac85a93dce17e0d7d"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga86214f440122e8aac85a93dce17e0d7d">abs_max</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:ga86214f440122e8aac85a93dce17e0d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute maximum element of a tile.  <a href="group___tile_interface.html#ga86214f440122e8aac85a93dce17e0d7d">More...</a><br /></td></tr>
<tr class="separator:ga86214f440122e8aac85a93dce17e0d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac89ec1d5bad433cb8a9ee8612a6d88fd"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gac89ec1d5bad433cb8a9ee8612a6d88fd"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gac89ec1d5bad433cb8a9ee8612a6d88fd">abs_min</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:gac89ec1d5bad433cb8a9ee8612a6d88fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute mainimum element of a tile.  <a href="group___tile_interface.html#gac89ec1d5bad433cb8a9ee8612a6d88fd">More...</a><br /></td></tr>
<tr class="separator:gac89ec1d5bad433cb8a9ee8612a6d88fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf71813b13896a29698efff4232719d70"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:gaf71813b13896a29698efff4232719d70"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gaf71813b13896a29698efff4232719d70">dot</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right)</td></tr>
<tr class="memdesc:gaf71813b13896a29698efff4232719d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector dot product of a tile.  <a href="group___tile_interface.html#gaf71813b13896a29698efff4232719d70">More...</a><br /></td></tr>
<tr class="separator:gaf71813b13896a29698efff4232719d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac817534360dc7eb173c22113bc49522f"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:gac817534360dc7eb173c22113bc49522f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gac817534360dc7eb173c22113bc49522f">inner_product</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right)</td></tr>
<tr class="memdesc:gac817534360dc7eb173c22113bc49522f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector inner product of a tile.  <a href="group___tile_interface.html#gac817534360dc7eb173c22113bc49522f">More...</a><br /></td></tr>
<tr class="separator:gac817534360dc7eb173c22113bc49522f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac07ca3ab32da77765c0546689feb400f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac07ca3ab32da77765c0546689feb400f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gac07ca3ab32da77765c0546689feb400f">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; T &gt; &amp;tile)</td></tr>
<tr class="separator:gac07ca3ab32da77765c0546689feb400f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef306922e8b07ed8df0ef92f0242947"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a4ef306922e8b07ed8df0ef92f0242947"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4ef306922e8b07ed8df0ef92f0242947">operator==</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; T1 &gt; &amp;t1, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; T2 &gt; &amp;t2)</td></tr>
<tr class="memdesc:a4ef306922e8b07ed8df0ef92f0242947"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> equality comparison.  <a href="namespace_tiled_array.html#a4ef306922e8b07ed8df0ef92f0242947">More...</a><br /></td></tr>
<tr class="separator:a4ef306922e8b07ed8df0ef92f0242947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc317c0fc817305f509add105ee3cd44"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:abc317c0fc817305f509add105ee3cd44"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#abc317c0fc817305f509add105ee3cd44">operator!=</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; T1 &gt; &amp;t1, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; T2 &gt; &amp;t2)</td></tr>
<tr class="memdesc:abc317c0fc817305f509add105ee3cd44"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> inequality comparison.  <a href="namespace_tiled_array.html#abc317c0fc817305f509add105ee3cd44">More...</a><br /></td></tr>
<tr class="separator:abc317c0fc817305f509add105ee3cd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ca6bca2735b62e0eaf5cac4a3cba58"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:a87ca6bca2735b62e0eaf5cac4a3cba58"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a87ca6bca2735b62e0eaf5cac4a3cba58">add</a> (const Left &amp;left, const Right &amp;right) -&gt; decltype(left.add(right))</td></tr>
<tr class="memdesc:a87ca6bca2735b62e0eaf5cac4a3cba58"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> tile arguments.  <a href="namespace_tiled_array.html#a87ca6bca2735b62e0eaf5cac4a3cba58">More...</a><br /></td></tr>
<tr class="separator:a87ca6bca2735b62e0eaf5cac4a3cba58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f55826b650600d7dbea2e362f5520c6"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a3f55826b650600d7dbea2e362f5520c6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3f55826b650600d7dbea2e362f5520c6">add</a> (const Left &amp;left, const Right &amp;right, const Scalar factor)</td></tr>
<tr class="memdesc:a3f55826b650600d7dbea2e362f5520c6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> and scale tile arguments.  <a href="namespace_tiled_array.html#a3f55826b650600d7dbea2e362f5520c6">More...</a><br /></td></tr>
<tr class="separator:a3f55826b650600d7dbea2e362f5520c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c4e84610468c5983826d1395efff7f"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt; &amp;&amp;                                detail::has_member_function_add_anyreturn_v&lt;                                    const Left, const Right&amp;, const Perm&amp;&gt;&gt;&gt; </td></tr>
<tr class="memitem:ac6c4e84610468c5983826d1395efff7f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac6c4e84610468c5983826d1395efff7f">add</a> (const Left &amp;left, const Right &amp;right, const Perm &amp;perm)</td></tr>
<tr class="memdesc:ac6c4e84610468c5983826d1395efff7f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> and permute tile arguments.  <a href="namespace_tiled_array.html#ac6c4e84610468c5983826d1395efff7f">More...</a><br /></td></tr>
<tr class="separator:ac6c4e84610468c5983826d1395efff7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3130f476f94d3917efcc41f483ef731"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename Perm , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ac3130f476f94d3917efcc41f483ef731"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac3130f476f94d3917efcc41f483ef731">add</a> (const Left &amp;left, const Right &amp;right, const Scalar factor, const Perm &amp;perm)</td></tr>
<tr class="memdesc:ac3130f476f94d3917efcc41f483ef731"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a>, scale, and permute tile arguments.  <a href="namespace_tiled_array.html#ac3130f476f94d3917efcc41f483ef731">More...</a><br /></td></tr>
<tr class="separator:ac3130f476f94d3917efcc41f483ef731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b6f318b11b3abb7986751995a880d0"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg &gt; </td></tr>
<tr class="memitem:af7b6f318b11b3abb7986751995a880d0"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#af7b6f318b11b3abb7986751995a880d0">add_to</a> (Result &amp;result, const Arg &amp;arg)</td></tr>
<tr class="memdesc:af7b6f318b11b3abb7986751995a880d0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> to the result tile.  <a href="namespace_tiled_array.html#af7b6f318b11b3abb7986751995a880d0">More...</a><br /></td></tr>
<tr class="separator:af7b6f318b11b3abb7986751995a880d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ec71822bfc6ea2da939913f8ee8f02"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a17ec71822bfc6ea2da939913f8ee8f02"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a17ec71822bfc6ea2da939913f8ee8f02">add_to</a> (Result &amp;result, const Arg &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:a17ec71822bfc6ea2da939913f8ee8f02"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> and scale to the result tile.  <a href="namespace_tiled_array.html#a17ec71822bfc6ea2da939913f8ee8f02">More...</a><br /></td></tr>
<tr class="separator:a17ec71822bfc6ea2da939913f8ee8f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf3ee231866723665a23c1669e4c754"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Result  = typename TiledArray::eval_trait&lt;                            madness::remove_fcvr_t&lt;Arg&gt;&gt;::type&gt; </td></tr>
<tr class="memitem:a4bf3ee231866723665a23c1669e4c754"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4bf3ee231866723665a23c1669e4c754">invoke_cast</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="separator:a4bf3ee231866723665a23c1669e4c754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead4454c3584b960202d2390a0139c33"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:aead4454c3584b960202d2390a0139c33"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aead4454c3584b960202d2390a0139c33">clone</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:aead4454c3584b960202d2390a0139c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of <code>arg</code>.  <a href="namespace_tiled_array.html#aead4454c3584b960202d2390a0139c33">More...</a><br /></td></tr>
<tr class="separator:aead4454c3584b960202d2390a0139c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f8422b76a244ec44b61a8beeb014ee"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt; &amp;&amp;                                detail::has_member_function_permute_anyreturn_v&lt;                                    const Arg, const Perm&amp;&gt;&gt;&gt; </td></tr>
<tr class="memitem:ab8f8422b76a244ec44b61a8beeb014ee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ab8f8422b76a244ec44b61a8beeb014ee">permute</a> (const Arg &amp;arg, const Perm &amp;perm)</td></tr>
<tr class="memdesc:ab8f8422b76a244ec44b61a8beeb014ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a permuted copy of <code>arg</code>.  <a href="namespace_tiled_array.html#ab8f8422b76a244ec44b61a8beeb014ee">More...</a><br /></td></tr>
<tr class="separator:ab8f8422b76a244ec44b61a8beeb014ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf92d0f99f726bc096fe6e7c6a6bee7b"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , std::enable_if_t&lt; TiledArray::detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;!TiledArray::detail::is_array_v&lt; Arg &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acf92d0f99f726bc096fe6e7c6a6bee7b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#acf92d0f99f726bc096fe6e7c6a6bee7b">scale</a> (const Arg &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:acf92d0f99f726bc096fe6e7c6a6bee7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar the tile argument.  <a href="namespace_tiled_array.html#acf92d0f99f726bc096fe6e7c6a6bee7b">More...</a><br /></td></tr>
<tr class="separator:acf92d0f99f726bc096fe6e7c6a6bee7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2177a3aa0107d3a03856779aa5bad8e9"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename Perm , std::enable_if_t&lt; TiledArray::detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;TiledArray::detail::is_permutation_v&lt; Perm &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2177a3aa0107d3a03856779aa5bad8e9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a2177a3aa0107d3a03856779aa5bad8e9">scale</a> (const Arg &amp;arg, const Scalar factor, const Perm &amp;perm)</td></tr>
<tr class="memdesc:a2177a3aa0107d3a03856779aa5bad8e9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile.">Scale</a> and permute tile argument.  <a href="namespace_tiled_array.html#a2177a3aa0107d3a03856779aa5bad8e9">More...</a><br /></td></tr>
<tr class="separator:a2177a3aa0107d3a03856779aa5bad8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10222cde45203777a4b3a6dc2d2d72d"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Scalar , std::enable_if_t&lt; TiledArray::detail::is_numeric_v&lt; Scalar &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac10222cde45203777a4b3a6dc2d2d72d"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac10222cde45203777a4b3a6dc2d2d72d">scale_to</a> (Result &amp;result, const Scalar factor)</td></tr>
<tr class="memdesc:ac10222cde45203777a4b3a6dc2d2d72d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile.">Scale</a> to the result tile.  <a href="namespace_tiled_array.html#ac10222cde45203777a4b3a6dc2d2d72d">More...</a><br /></td></tr>
<tr class="separator:ac10222cde45203777a4b3a6dc2d2d72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b406a97e00d20e23f39f52cae8d6dc"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Index , typename  = std::enable_if_t&lt;detail::is_integral_range_v&lt;Index&gt;&gt;&gt; </td></tr>
<tr class="memitem:a55b406a97e00d20e23f39f52cae8d6dc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a55b406a97e00d20e23f39f52cae8d6dc">shift</a> (const Arg &amp;arg, const Index &amp;range_shift)</td></tr>
<tr class="memdesc:a55b406a97e00d20e23f39f52cae8d6dc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> the range of <code>arg</code>.  <a href="namespace_tiled_array.html#a55b406a97e00d20e23f39f52cae8d6dc">More...</a><br /></td></tr>
<tr class="separator:a55b406a97e00d20e23f39f52cae8d6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2d4c345272f74469cd90d9f563d787"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Index , typename  = std::enable_if_t&lt;std::is_integral_v&lt;Index&gt;&gt;&gt; </td></tr>
<tr class="memitem:a9f2d4c345272f74469cd90d9f563d787"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a9f2d4c345272f74469cd90d9f563d787">shift</a> (const Arg &amp;arg, const std::initializer_list&lt; Index &gt; &amp;range_shift)</td></tr>
<tr class="memdesc:a9f2d4c345272f74469cd90d9f563d787"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> the range of <code>arg</code>.  <a href="namespace_tiled_array.html#a9f2d4c345272f74469cd90d9f563d787">More...</a><br /></td></tr>
<tr class="separator:a9f2d4c345272f74469cd90d9f563d787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b4cffaa8c8a7ded3b9a0a56f529ebb"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Index , typename  = std::enable_if_t&lt;detail::is_integral_range_v&lt;Index&gt;&gt;&gt; </td></tr>
<tr class="memitem:a53b4cffaa8c8a7ded3b9a0a56f529ebb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a53b4cffaa8c8a7ded3b9a0a56f529ebb">shift_to</a> (Arg &amp;arg, const Index &amp;range_shift)</td></tr>
<tr class="memdesc:a53b4cffaa8c8a7ded3b9a0a56f529ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> the range of <code>arg</code> in place.  <a href="namespace_tiled_array.html#a53b4cffaa8c8a7ded3b9a0a56f529ebb">More...</a><br /></td></tr>
<tr class="separator:a53b4cffaa8c8a7ded3b9a0a56f529ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df329d84b8e06ed0c5eac001dcee410"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Index , typename  = std::enable_if_t&lt;std::is_integral_v&lt;Index&gt;&gt;&gt; </td></tr>
<tr class="memitem:a1df329d84b8e06ed0c5eac001dcee410"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a1df329d84b8e06ed0c5eac001dcee410">shift_to</a> (Arg &amp;arg, const std::initializer_list&lt; Index &gt; &amp;range_shift)</td></tr>
<tr class="memdesc:a1df329d84b8e06ed0c5eac001dcee410"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> the range of <code>arg</code> in place.  <a href="namespace_tiled_array.html#a1df329d84b8e06ed0c5eac001dcee410">More...</a><br /></td></tr>
<tr class="separator:a1df329d84b8e06ed0c5eac001dcee410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10502bd5879f539420520f928f8bae2e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = detail::enable_if_trace_is_defined_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a10502bd5879f539420520f928f8bae2e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a10502bd5879f539420520f928f8bae2e">trace</a> (const T &amp;t)</td></tr>
<tr class="separator:a10502bd5879f539420520f928f8bae2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga868fcf578c023fc98e1f46cd50266d04"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga868fcf578c023fc98e1f46cd50266d04"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga868fcf578c023fc98e1f46cd50266d04">subt</a> (const Left &amp;left, const Right &amp;right)</td></tr>
<tr class="memdesc:ga868fcf578c023fc98e1f46cd50266d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract tile arguments.  <a href="group___non_intrusive_tile_interface.html#ga868fcf578c023fc98e1f46cd50266d04">More...</a><br /></td></tr>
<tr class="separator:ga868fcf578c023fc98e1f46cd50266d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac59cfe02cb4e608cdaaa2beb43b97306"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gac59cfe02cb4e608cdaaa2beb43b97306"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gac59cfe02cb4e608cdaaa2beb43b97306">subt</a> (const Left &amp;left, const Right &amp;right, const Scalar factor)</td></tr>
<tr class="memdesc:gac59cfe02cb4e608cdaaa2beb43b97306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract and scale tile arguments.  <a href="group___non_intrusive_tile_interface.html#gac59cfe02cb4e608cdaaa2beb43b97306">More...</a><br /></td></tr>
<tr class="separator:gac59cfe02cb4e608cdaaa2beb43b97306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga335c2f5a10724b3739d3834f733544c4"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga335c2f5a10724b3739d3834f733544c4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga335c2f5a10724b3739d3834f733544c4">subt</a> (const Left &amp;left, const Right &amp;right, const Perm &amp;perm)</td></tr>
<tr class="memdesc:ga335c2f5a10724b3739d3834f733544c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract and permute tile arguments.  <a href="group___non_intrusive_tile_interface.html#ga335c2f5a10724b3739d3834f733544c4">More...</a><br /></td></tr>
<tr class="separator:ga335c2f5a10724b3739d3834f733544c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7fd945708ca86889185ea7ca3608ff6"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename Perm , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gae7fd945708ca86889185ea7ca3608ff6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gae7fd945708ca86889185ea7ca3608ff6">subt</a> (const Left &amp;left, const Right &amp;right, const Scalar factor, const Perm &amp;perm)</td></tr>
<tr class="memdesc:gae7fd945708ca86889185ea7ca3608ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract, scale, and permute tile arguments.  <a href="group___non_intrusive_tile_interface.html#gae7fd945708ca86889185ea7ca3608ff6">More...</a><br /></td></tr>
<tr class="separator:gae7fd945708ca86889185ea7ca3608ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0100e842082acfc8fba40823d1e29c93"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0100e842082acfc8fba40823d1e29c93"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga0100e842082acfc8fba40823d1e29c93">subt</a> (const Arg &amp;arg, const Scalar value)</td></tr>
<tr class="memdesc:ga0100e842082acfc8fba40823d1e29c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a scalar constant from the tile argument.  <a href="group___non_intrusive_tile_interface.html#ga0100e842082acfc8fba40823d1e29c93">More...</a><br /></td></tr>
<tr class="separator:ga0100e842082acfc8fba40823d1e29c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d579b7860bc62b1dc90becd5d6c1038"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename Perm , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2d579b7860bc62b1dc90becd5d6c1038"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga2d579b7860bc62b1dc90becd5d6c1038">subt</a> (const Arg &amp;arg, const Scalar value, const Perm &amp;perm)</td></tr>
<tr class="memdesc:ga2d579b7860bc62b1dc90becd5d6c1038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a constant scalar and permute tile argument.  <a href="group___non_intrusive_tile_interface.html#ga2d579b7860bc62b1dc90becd5d6c1038">More...</a><br /></td></tr>
<tr class="separator:ga2d579b7860bc62b1dc90becd5d6c1038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6433ca823a7f563abbb980b72ee6dba3"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg &gt; </td></tr>
<tr class="memitem:ga6433ca823a7f563abbb980b72ee6dba3"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga6433ca823a7f563abbb980b72ee6dba3">subt_to</a> (Result &amp;result, const Arg &amp;arg)</td></tr>
<tr class="memdesc:ga6433ca823a7f563abbb980b72ee6dba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract from the result tile.  <a href="group___non_intrusive_tile_interface.html#ga6433ca823a7f563abbb980b72ee6dba3">More...</a><br /></td></tr>
<tr class="separator:ga6433ca823a7f563abbb980b72ee6dba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5666748f9fda3e3173eac160328bd5c"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gab5666748f9fda3e3173eac160328bd5c"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gab5666748f9fda3e3173eac160328bd5c">subt_to</a> (Result &amp;result, const Arg &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:gab5666748f9fda3e3173eac160328bd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract and scale from the result tile.  <a href="group___non_intrusive_tile_interface.html#gab5666748f9fda3e3173eac160328bd5c">More...</a><br /></td></tr>
<tr class="separator:gab5666748f9fda3e3173eac160328bd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3c0183d91fdc7febc0aac4e0f929d97"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gae3c0183d91fdc7febc0aac4e0f929d97"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gae3c0183d91fdc7febc0aac4e0f929d97">subt_to</a> (Result &amp;result, const Scalar value)</td></tr>
<tr class="memdesc:gae3c0183d91fdc7febc0aac4e0f929d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract constant scalar from the result tile.  <a href="group___non_intrusive_tile_interface.html#gae3c0183d91fdc7febc0aac4e0f929d97">More...</a><br /></td></tr>
<tr class="separator:gae3c0183d91fdc7febc0aac4e0f929d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2efde56a873ec888fe91db82e336ddff"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga2efde56a873ec888fe91db82e336ddff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga2efde56a873ec888fe91db82e336ddff">mult</a> (const Left &amp;left, const Right &amp;right)</td></tr>
<tr class="memdesc:ga2efde56a873ec888fe91db82e336ddff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication tile arguments.  <a href="group___non_intrusive_tile_interface.html#ga2efde56a873ec888fe91db82e336ddff">More...</a><br /></td></tr>
<tr class="separator:ga2efde56a873ec888fe91db82e336ddff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02de75c65c05021e1d3b65f60d839a80"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , std::enable_if_t&lt; TiledArray::detail::is_numeric_v&lt; Scalar &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga02de75c65c05021e1d3b65f60d839a80"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga02de75c65c05021e1d3b65f60d839a80">mult</a> (const Left &amp;left, const Right &amp;right, const Scalar factor)</td></tr>
<tr class="memdesc:ga02de75c65c05021e1d3b65f60d839a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication and scale tile arguments.  <a href="group___non_intrusive_tile_interface.html#ga02de75c65c05021e1d3b65f60d839a80">More...</a><br /></td></tr>
<tr class="separator:ga02de75c65c05021e1d3b65f60d839a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab79cce818190ca6bac3d086707fdd177"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt; &amp;&amp;                                detail::has_member_function_mult_anyreturn_v&lt;                                    const Left, const Right&amp;, const Perm&amp;&gt;&gt;&gt; </td></tr>
<tr class="memitem:gab79cce818190ca6bac3d086707fdd177"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gab79cce818190ca6bac3d086707fdd177">mult</a> (const Left &amp;left, const Right &amp;right, const Perm &amp;perm)</td></tr>
<tr class="memdesc:gab79cce818190ca6bac3d086707fdd177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication and permute tile arguments.  <a href="group___non_intrusive_tile_interface.html#gab79cce818190ca6bac3d086707fdd177">More...</a><br /></td></tr>
<tr class="separator:gab79cce818190ca6bac3d086707fdd177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga684ae24d2f757eebb765d9fcdb3a0e07"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename Perm , std::enable_if_t&lt; TiledArray::detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga684ae24d2f757eebb765d9fcdb3a0e07"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga684ae24d2f757eebb765d9fcdb3a0e07">mult</a> (const Left &amp;left, const Right &amp;right, const Scalar factor, const Perm &amp;perm)</td></tr>
<tr class="memdesc:ga684ae24d2f757eebb765d9fcdb3a0e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication, scale, and permute tile arguments.  <a href="group___non_intrusive_tile_interface.html#ga684ae24d2f757eebb765d9fcdb3a0e07">More...</a><br /></td></tr>
<tr class="separator:ga684ae24d2f757eebb765d9fcdb3a0e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8d5fd9f983b98c143a694fa82166585"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg &gt; </td></tr>
<tr class="memitem:gaf8d5fd9f983b98c143a694fa82166585"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gaf8d5fd9f983b98c143a694fa82166585">mult_to</a> (Result &amp;result, const Arg &amp;arg)</td></tr>
<tr class="memdesc:gaf8d5fd9f983b98c143a694fa82166585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply to the result tile.  <a href="group___non_intrusive_tile_interface.html#gaf8d5fd9f983b98c143a694fa82166585">More...</a><br /></td></tr>
<tr class="separator:gaf8d5fd9f983b98c143a694fa82166585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b9a07027db87b4785e7e9f2f31cc567"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg , typename Scalar , std::enable_if_t&lt; TiledArray::detail::is_numeric_v&lt; Scalar &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5b9a07027db87b4785e7e9f2f31cc567"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga5b9a07027db87b4785e7e9f2f31cc567">mult_to</a> (Result &amp;result, const Arg &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:ga5b9a07027db87b4785e7e9f2f31cc567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and scale to the result tile.  <a href="group___non_intrusive_tile_interface.html#ga5b9a07027db87b4785e7e9f2f31cc567">More...</a><br /></td></tr>
<tr class="separator:ga5b9a07027db87b4785e7e9f2f31cc567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c135a4745d147911d58ad2c29b3f6b5"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Op &gt; </td></tr>
<tr class="memitem:ga5c135a4745d147911d58ad2c29b3f6b5"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga5c135a4745d147911d58ad2c29b3f6b5">binary</a> (const Left &amp;left, const Right &amp;right, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:ga5c135a4745d147911d58ad2c29b3f6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary element-wise transform producing a new tile.  <a href="group___non_intrusive_tile_interface.html#ga5c135a4745d147911d58ad2c29b3f6b5">More...</a><br /></td></tr>
<tr class="separator:ga5c135a4745d147911d58ad2c29b3f6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45110691b522d2f15c3b8d5307affefe"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Op , typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga45110691b522d2f15c3b8d5307affefe"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga45110691b522d2f15c3b8d5307affefe">binary</a> (const Left &amp;left, const Right &amp;right, Op &amp;&amp;op, const Perm &amp;perm)</td></tr>
<tr class="memdesc:ga45110691b522d2f15c3b8d5307affefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary element-wise transform producing a new tile.  <a href="group___non_intrusive_tile_interface.html#ga45110691b522d2f15c3b8d5307affefe">More...</a><br /></td></tr>
<tr class="separator:ga45110691b522d2f15c3b8d5307affefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae96fc72af4843edf9ba4e9902fea9709"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Op &gt; </td></tr>
<tr class="memitem:gae96fc72af4843edf9ba4e9902fea9709"><td class="memTemplItemLeft" align="right" valign="top">Left &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gae96fc72af4843edf9ba4e9902fea9709">inplace_binary</a> (Left &amp;left, const Right &amp;right, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:gae96fc72af4843edf9ba4e9902fea9709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary element-wise in-place transform.  <a href="group___non_intrusive_tile_interface.html#gae96fc72af4843edf9ba4e9902fea9709">More...</a><br /></td></tr>
<tr class="separator:gae96fc72af4843edf9ba4e9902fea9709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga930711d2b817ac11c592fa3dd90fbbbb"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga930711d2b817ac11c592fa3dd90fbbbb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga930711d2b817ac11c592fa3dd90fbbbb">neg</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:ga930711d2b817ac11c592fa3dd90fbbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate the tile argument.  <a href="group___non_intrusive_tile_interface.html#ga930711d2b817ac11c592fa3dd90fbbbb">More...</a><br /></td></tr>
<tr class="separator:ga930711d2b817ac11c592fa3dd90fbbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79929bcbb3f6660fd1df9e3e9a30278f"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga79929bcbb3f6660fd1df9e3e9a30278f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga79929bcbb3f6660fd1df9e3e9a30278f">neg</a> (const Arg &amp;arg, const Perm &amp;perm)</td></tr>
<tr class="memdesc:ga79929bcbb3f6660fd1df9e3e9a30278f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate and permute tile argument.  <a href="group___non_intrusive_tile_interface.html#ga79929bcbb3f6660fd1df9e3e9a30278f">More...</a><br /></td></tr>
<tr class="separator:ga79929bcbb3f6660fd1df9e3e9a30278f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0983dfc5809ebfca2de350b5bf42dca0"><td class="memTemplParams" colspan="2">template&lt;typename Result &gt; </td></tr>
<tr class="memitem:ga0983dfc5809ebfca2de350b5bf42dca0"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga0983dfc5809ebfca2de350b5bf42dca0">neg_to</a> (Result &amp;result)</td></tr>
<tr class="memdesc:ga0983dfc5809ebfca2de350b5bf42dca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate the tile argument in-place.  <a href="group___non_intrusive_tile_interface.html#ga0983dfc5809ebfca2de350b5bf42dca0">More...</a><br /></td></tr>
<tr class="separator:ga0983dfc5809ebfca2de350b5bf42dca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada05b20133963ad39dd26f45588a69a3"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gada05b20133963ad39dd26f45588a69a3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gada05b20133963ad39dd26f45588a69a3">conj</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:gada05b20133963ad39dd26f45588a69a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated copy of a tile.  <a href="group___non_intrusive_tile_interface.html#gada05b20133963ad39dd26f45588a69a3">More...</a><br /></td></tr>
<tr class="separator:gada05b20133963ad39dd26f45588a69a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b703fbc17b07716f36468a174327013"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3b703fbc17b07716f36468a174327013"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga3b703fbc17b07716f36468a174327013">conj</a> (const Arg &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:ga3b703fbc17b07716f36468a174327013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated and scaled copy of a tile.  <a href="group___non_intrusive_tile_interface.html#ga3b703fbc17b07716f36468a174327013">More...</a><br /></td></tr>
<tr class="separator:ga3b703fbc17b07716f36468a174327013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6449aba7ac797256ab8d3a48db979796"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga6449aba7ac797256ab8d3a48db979796"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga6449aba7ac797256ab8d3a48db979796">conj</a> (const Arg &amp;arg, const Perm &amp;perm)</td></tr>
<tr class="memdesc:ga6449aba7ac797256ab8d3a48db979796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated and permuted copy of a tile.  <a href="group___non_intrusive_tile_interface.html#ga6449aba7ac797256ab8d3a48db979796">More...</a><br /></td></tr>
<tr class="separator:ga6449aba7ac797256ab8d3a48db979796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedaa41b169b1ceb11e6fb502a85e66ec"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename Perm , typename std::enable_if&lt; TiledArray::detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gaedaa41b169b1ceb11e6fb502a85e66ec"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gaedaa41b169b1ceb11e6fb502a85e66ec">conj</a> (const Arg &amp;arg, const Scalar factor, const Perm &amp;perm)</td></tr>
<tr class="memdesc:gaedaa41b169b1ceb11e6fb502a85e66ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated, scaled, and permuted copy of a tile.  <a href="group___non_intrusive_tile_interface.html#gaedaa41b169b1ceb11e6fb502a85e66ec">More...</a><br /></td></tr>
<tr class="separator:gaedaa41b169b1ceb11e6fb502a85e66ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65b3ee6f080b8a842bba1e7a56afb794"><td class="memTemplParams" colspan="2">template&lt;typename Result &gt; </td></tr>
<tr class="memitem:ga65b3ee6f080b8a842bba1e7a56afb794"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga65b3ee6f080b8a842bba1e7a56afb794">conj_to</a> (Result &amp;result)</td></tr>
<tr class="memdesc:ga65b3ee6f080b8a842bba1e7a56afb794"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place complex conjugate a tile.  <a href="group___non_intrusive_tile_interface.html#ga65b3ee6f080b8a842bba1e7a56afb794">More...</a><br /></td></tr>
<tr class="separator:ga65b3ee6f080b8a842bba1e7a56afb794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e2f551d8e19e04b8fa91c6a0da7d18c"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5e2f551d8e19e04b8fa91c6a0da7d18c"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga5e2f551d8e19e04b8fa91c6a0da7d18c">conj_to</a> (Result &amp;result, const Scalar factor)</td></tr>
<tr class="memdesc:ga5e2f551d8e19e04b8fa91c6a0da7d18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place complex conjugate and scale a tile.  <a href="group___non_intrusive_tile_interface.html#ga5e2f551d8e19e04b8fa91c6a0da7d18c">More...</a><br /></td></tr>
<tr class="separator:ga5e2f551d8e19e04b8fa91c6a0da7d18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf1b06ea0ea1ed72e034cfb9eeaa17bf"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Op &gt; </td></tr>
<tr class="memitem:gaaf1b06ea0ea1ed72e034cfb9eeaa17bf"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gaaf1b06ea0ea1ed72e034cfb9eeaa17bf">unary</a> (const Arg &amp;arg, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:gaaf1b06ea0ea1ed72e034cfb9eeaa17bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary element-wise transform producing a new tile.  <a href="group___non_intrusive_tile_interface.html#gaaf1b06ea0ea1ed72e034cfb9eeaa17bf">More...</a><br /></td></tr>
<tr class="separator:gaaf1b06ea0ea1ed72e034cfb9eeaa17bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec5fe111fc036c6ef817bd3b4e2347a3"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Op , typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:gaec5fe111fc036c6ef817bd3b4e2347a3"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gaec5fe111fc036c6ef817bd3b4e2347a3">unary</a> (const Arg &amp;arg, Op &amp;&amp;op, const Perm &amp;perm)</td></tr>
<tr class="memdesc:gaec5fe111fc036c6ef817bd3b4e2347a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary element-wise transform producing a new tile.  <a href="group___non_intrusive_tile_interface.html#gaec5fe111fc036c6ef817bd3b4e2347a3">More...</a><br /></td></tr>
<tr class="separator:gaec5fe111fc036c6ef817bd3b4e2347a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ac1eef13fdad1a8321eef485e7f50af"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Op &gt; </td></tr>
<tr class="memitem:ga0ac1eef13fdad1a8321eef485e7f50af"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga0ac1eef13fdad1a8321eef485e7f50af">inplace_unary</a> (Result &amp;arg, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:ga0ac1eef13fdad1a8321eef485e7f50af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary element-wise in-place transform.  <a href="group___non_intrusive_tile_interface.html#ga0ac1eef13fdad1a8321eef485e7f50af">More...</a><br /></td></tr>
<tr class="separator:ga0ac1eef13fdad1a8321eef485e7f50af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e87c8a7fa49e53b50d97debf41e5d23"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , std::enable_if_t&lt; TiledArray::detail::is_numeric_v&lt; Scalar &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5e87c8a7fa49e53b50d97debf41e5d23"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga5e87c8a7fa49e53b50d97debf41e5d23">gemm</a> (const Left &amp;left, const Right &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1math_1_1_gemm_helper.html">math::GemmHelper</a> &amp;gemm_config)</td></tr>
<tr class="memdesc:ga5e87c8a7fa49e53b50d97debf41e5d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract 2 tensors over head/tail modes and scale the product.  <a href="group___non_intrusive_tile_interface.html#ga5e87c8a7fa49e53b50d97debf41e5d23">More...</a><br /></td></tr>
<tr class="separator:ga5e87c8a7fa49e53b50d97debf41e5d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcb5f80c0b106673576299ae702e129"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Left , typename Right , typename Scalar , std::enable_if_t&lt; TiledArray::detail::is_numeric_v&lt; Scalar &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7fcb5f80c0b106673576299ae702e129"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga7fcb5f80c0b106673576299ae702e129">gemm</a> (Result &amp;result, const Left &amp;left, const Right &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1math_1_1_gemm_helper.html">math::GemmHelper</a> &amp;gemm_config)</td></tr>
<tr class="separator:ga7fcb5f80c0b106673576299ae702e129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17e603852029b3bc403a2c5ba9d03ab0"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Left , typename Right , typename ElementMultiplyAddOp , std::enable_if_t&lt; std::is_invocable_r_v&lt; void, std::remove_reference_t&lt; ElementMultiplyAddOp &gt;, typename Result::value_type &amp;, const typename Left::value_type &amp;, const typename Right::value_type &amp; &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga17e603852029b3bc403a2c5ba9d03ab0"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga17e603852029b3bc403a2c5ba9d03ab0">gemm</a> (Result &amp;result, const Left &amp;left, const Right &amp;right, const <a class="el" href="class_tiled_array_1_1math_1_1_gemm_helper.html">math::GemmHelper</a> &amp;gemm_config, ElementMultiplyAddOp &amp;&amp;element_multiplyadd_op)</td></tr>
<tr class="separator:ga17e603852029b3bc403a2c5ba9d03ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae38e8020fe61d4fb17a6ce37af5a9c41"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gae38e8020fe61d4fb17a6ce37af5a9c41"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gae38e8020fe61d4fb17a6ce37af5a9c41">sum</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:gae38e8020fe61d4fb17a6ce37af5a9c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the hyper-diagonal elements a tile.  <a href="group___non_intrusive_tile_interface.html#gae38e8020fe61d4fb17a6ce37af5a9c41">More...</a><br /></td></tr>
<tr class="separator:gae38e8020fe61d4fb17a6ce37af5a9c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga194ee4ec9d248e4cb2a0e0965be39ad3"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga194ee4ec9d248e4cb2a0e0965be39ad3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga194ee4ec9d248e4cb2a0e0965be39ad3">product</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:ga194ee4ec9d248e4cb2a0e0965be39ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply the elements of a tile.  <a href="group___non_intrusive_tile_interface.html#ga194ee4ec9d248e4cb2a0e0965be39ad3">More...</a><br /></td></tr>
<tr class="separator:ga194ee4ec9d248e4cb2a0e0965be39ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga338752778aa1675bab78e615c71a578f"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga338752778aa1675bab78e615c71a578f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga338752778aa1675bab78e615c71a578f">squared_norm</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:ga338752778aa1675bab78e615c71a578f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squared vector 2-norm of the elements of a tile.  <a href="group___non_intrusive_tile_interface.html#ga338752778aa1675bab78e615c71a578f">More...</a><br /></td></tr>
<tr class="separator:ga338752778aa1675bab78e615c71a578f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79c1ad5b5a59b783da711eba292b33c5"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga79c1ad5b5a59b783da711eba292b33c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga79c1ad5b5a59b783da711eba292b33c5">norm</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:ga79c1ad5b5a59b783da711eba292b33c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector 2-norm of a tile.  <a href="group___non_intrusive_tile_interface.html#ga79c1ad5b5a59b783da711eba292b33c5">More...</a><br /></td></tr>
<tr class="separator:ga79c1ad5b5a59b783da711eba292b33c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7675a59af884cbbd91bbd2f2f9c2f69a"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename ResultType &gt; </td></tr>
<tr class="memitem:ga7675a59af884cbbd91bbd2f2f9c2f69a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga7675a59af884cbbd91bbd2f2f9c2f69a">norm</a> (const Arg &amp;arg, ResultType &amp;result)</td></tr>
<tr class="memdesc:ga7675a59af884cbbd91bbd2f2f9c2f69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector 2-norm of a tile.  <a href="group___non_intrusive_tile_interface.html#ga7675a59af884cbbd91bbd2f2f9c2f69a">More...</a><br /></td></tr>
<tr class="separator:ga7675a59af884cbbd91bbd2f2f9c2f69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ef7824931c39eeba0ad4b394038d16a"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga1ef7824931c39eeba0ad4b394038d16a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga1ef7824931c39eeba0ad4b394038d16a">max</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:ga1ef7824931c39eeba0ad4b394038d16a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum element of a tile.  <a href="group___non_intrusive_tile_interface.html#ga1ef7824931c39eeba0ad4b394038d16a">More...</a><br /></td></tr>
<tr class="separator:ga1ef7824931c39eeba0ad4b394038d16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga828782da9ce948aa72f353c5564025c8"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga828782da9ce948aa72f353c5564025c8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga828782da9ce948aa72f353c5564025c8">min</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:ga828782da9ce948aa72f353c5564025c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum element of a tile.  <a href="group___non_intrusive_tile_interface.html#ga828782da9ce948aa72f353c5564025c8">More...</a><br /></td></tr>
<tr class="separator:ga828782da9ce948aa72f353c5564025c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb84a7965d7b1ce571419a811da3ed7f"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gafb84a7965d7b1ce571419a811da3ed7f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gafb84a7965d7b1ce571419a811da3ed7f">abs_max</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:gafb84a7965d7b1ce571419a811da3ed7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute maximum element of a tile.  <a href="group___non_intrusive_tile_interface.html#gafb84a7965d7b1ce571419a811da3ed7f">More...</a><br /></td></tr>
<tr class="separator:gafb84a7965d7b1ce571419a811da3ed7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc14202de34a66f84701ddf89dd21c67"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gadc14202de34a66f84701ddf89dd21c67"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gadc14202de34a66f84701ddf89dd21c67">abs_min</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:gadc14202de34a66f84701ddf89dd21c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute mainimum element of a tile.  <a href="group___non_intrusive_tile_interface.html#gadc14202de34a66f84701ddf89dd21c67">More...</a><br /></td></tr>
<tr class="separator:gadc14202de34a66f84701ddf89dd21c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdda011a05f7208b0dc83686a4eee2af"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:gabdda011a05f7208b0dc83686a4eee2af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gabdda011a05f7208b0dc83686a4eee2af">dot</a> (const Left &amp;left, const Right &amp;right)</td></tr>
<tr class="memdesc:gabdda011a05f7208b0dc83686a4eee2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector dot product of two tiles.  <a href="group___non_intrusive_tile_interface.html#gabdda011a05f7208b0dc83686a4eee2af">More...</a><br /></td></tr>
<tr class="separator:gabdda011a05f7208b0dc83686a4eee2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga448de94236be83647ed7aa04ac8f3653"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga448de94236be83647ed7aa04ac8f3653"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga448de94236be83647ed7aa04ac8f3653">inner_product</a> (const Left &amp;left, const Right &amp;right)</td></tr>
<tr class="memdesc:ga448de94236be83647ed7aa04ac8f3653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector inner product of two tiles.  <a href="group___non_intrusive_tile_interface.html#ga448de94236be83647ed7aa04ac8f3653">More...</a><br /></td></tr>
<tr class="separator:ga448de94236be83647ed7aa04ac8f3653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1fa4c93060bc503429e3527f2993ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a2b1fa4c93060bc503429e3527f2993ad">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;r)</td></tr>
<tr class="memdesc:a2b1fa4c93060bc503429e3527f2993ad"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array.">TiledRange</a> permutation operator.  <a href="namespace_tiled_array.html#a2b1fa4c93060bc503429e3527f2993ad">More...</a><br /></td></tr>
<tr class="separator:a2b1fa4c93060bc503429e3527f2993ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0947b0d351b9ee0112b292eb869249"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4b0947b0d351b9ee0112b292eb869249">swap</a> (<a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;r0, <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;r1)</td></tr>
<tr class="memdesc:a4b0947b0d351b9ee0112b292eb869249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange the content of the two given <a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array.">TiledRange</a>'s.  <a href="namespace_tiled_array.html#a4b0947b0d351b9ee0112b292eb869249">More...</a><br /></td></tr>
<tr class="separator:a4b0947b0d351b9ee0112b292eb869249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a1447230c9a5ca4906ee3684cbe890"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a95a1447230c9a5ca4906ee3684cbe890">operator==</a> (const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;r2)</td></tr>
<tr class="memdesc:a95a1447230c9a5ca4906ee3684cbe890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when all tile and element ranges are the same.  <a href="namespace_tiled_array.html#a95a1447230c9a5ca4906ee3684cbe890">More...</a><br /></td></tr>
<tr class="separator:a95a1447230c9a5ca4906ee3684cbe890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4282e9e655ef9479b267ac1975d77eb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4282e9e655ef9479b267ac1975d77eb6">operator!=</a> (const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;r2)</td></tr>
<tr class="separator:a4282e9e655ef9479b267ac1975d77eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42dd6da4a499c34371973b91d3529c0"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac42dd6da4a499c34371973b91d3529c0">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;rng)</td></tr>
<tr class="separator:ac42dd6da4a499c34371973b91d3529c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5632aeeaf569807a5e38b4ae1c5a98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#abe5632aeeaf569807a5e38b4ae1c5a98">swap</a> (<a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;r0, <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;r1)</td></tr>
<tr class="memdesc:abe5632aeeaf569807a5e38b4ae1c5a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange the data of the two given ranges.  <a href="namespace_tiled_array.html#abe5632aeeaf569807a5e38b4ae1c5a98">More...</a><br /></td></tr>
<tr class="separator:abe5632aeeaf569807a5e38b4ae1c5a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0508aa5150620ac2a2a5476c6c5612"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a9e0508aa5150620ac2a2a5476c6c5612">operator==</a> (const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;r2)</td></tr>
<tr class="memdesc:a9e0508aa5150620ac2a2a5476c6c5612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="namespace_tiled_array.html#a9e0508aa5150620ac2a2a5476c6c5612">More...</a><br /></td></tr>
<tr class="separator:a9e0508aa5150620ac2a2a5476c6c5612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a6fdebe3f7dff3beb2637c2c48809f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a49a6fdebe3f7dff3beb2637c2c48809f">operator!=</a> (const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;r2)</td></tr>
<tr class="memdesc:a49a6fdebe3f7dff3beb2637c2c48809f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="namespace_tiled_array.html#a49a6fdebe3f7dff3beb2637c2c48809f">More...</a><br /></td></tr>
<tr class="separator:a49a6fdebe3f7dff3beb2637c2c48809f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4d830e8d3e6b0c3ef4db415eeed8f3"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3e4d830e8d3e6b0c3ef4db415eeed8f3">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;rng)</td></tr>
<tr class="memdesc:a3e4d830e8d3e6b0c3ef4db415eeed8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> ostream operator.  <a href="namespace_tiled_array.html#a3e4d830e8d3e6b0c3ef4db415eeed8f3">More...</a><br /></td></tr>
<tr class="separator:a3e4d830e8d3e6b0c3ef4db415eeed8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1b198e655d9877e8251a2cfc50c70b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#acd1b198e655d9877e8251a2cfc50c70b">concat</a> (const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;r2)</td></tr>
<tr class="memdesc:acd1b198e655d9877e8251a2cfc50c70b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two ranges.  <a href="namespace_tiled_array.html#acd1b198e655d9877e8251a2cfc50c70b">More...</a><br /></td></tr>
<tr class="separator:acd1b198e655d9877e8251a2cfc50c70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561b5e3eb2632a9fb93a06880c83f74c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a561b5e3eb2632a9fb93a06880c83f74c">is_congruent</a> (const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;r2)</td></tr>
<tr class="memdesc:a561b5e3eb2632a9fb93a06880c83f74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that two <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> objects are congruent.  <a href="namespace_tiled_array.html#a561b5e3eb2632a9fb93a06880c83f74c">More...</a><br /></td></tr>
<tr class="separator:a561b5e3eb2632a9fb93a06880c83f74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb19e7ec84d171ded4638b990d3387b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#afeb19e7ec84d171ded4638b990d3387b">launch_gdb_xterm</a> ()</td></tr>
<tr class="memdesc:afeb19e7ec84d171ded4638b990d3387b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this to launch GNU debugger in xterm.  <a href="namespace_tiled_array.html#afeb19e7ec84d171ded4638b990d3387b">More...</a><br /></td></tr>
<tr class="separator:afeb19e7ec84d171ded4638b990d3387b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99d473ae1db21c29a59983dcb29d8bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ab99d473ae1db21c29a59983dcb29d8bc">launch_lldb_xterm</a> ()</td></tr>
<tr class="memdesc:ab99d473ae1db21c29a59983dcb29d8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this to launch LLVM debugger in xterm.  <a href="namespace_tiled_array.html#ab99d473ae1db21c29a59983dcb29d8bc">More...</a><br /></td></tr>
<tr class="separator:ab99d473ae1db21c29a59983dcb29d8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec660a9421bf4776cd585846131a8b3"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a5ec660a9421bf4776cd585846131a8b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1shared__function.html">shared_function</a>&lt; std::decay_t&lt; F &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a5ec660a9421bf4776cd585846131a8b3">make_shared_function</a> (F &amp;&amp;f)</td></tr>
<tr class="separator:a5ec660a9421bf4776cd585846131a8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8386153a74ac2847e5c1025d438fd1a6"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:a8386153a74ac2847e5c1025d438fd1a6"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a8386153a74ac2847e5c1025d438fd1a6">swap</a> (<a class="el" href="class_tiled_array_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt; &amp;lhs, <a class="el" href="class_tiled_array_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a8386153a74ac2847e5c1025d438fd1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the referred callables of <code>lhs</code> and <code>rhs</code>.  <a href="namespace_tiled_array.html#a8386153a74ac2847e5c1025d438fd1a6">More...</a><br /></td></tr>
<tr class="separator:a8386153a74ac2847e5c1025d438fd1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44cdecfe02b2ca9f8134aed6c94f39c"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:aa44cdecfe02b2ca9f8134aed6c94f39c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa44cdecfe02b2ca9f8134aed6c94f39c">make_op_shared_handle</a> (Op &amp;&amp;op)</td></tr>
<tr class="separator:aa44cdecfe02b2ca9f8134aed6c94f39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8291483119dcf3831ee15dce5be0b85a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U  = std::array&lt;TiledRange1, initializer_list_rank_v&lt;std::decay_t&lt;T&gt;&gt;&gt;&gt; </td></tr>
<tr class="memitem:a8291483119dcf3831ee15dce5be0b85a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a8291483119dcf3831ee15dce5be0b85a">tiled_range_from_il</a> (T &amp;&amp;il, U shape={})</td></tr>
<tr class="memdesc:a8291483119dcf3831ee15dce5be0b85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array.">TiledRange</a> for the provided initializer list.  <a href="namespace_tiled_array.html#a8291483119dcf3831ee15dce5be0b85a">More...</a><br /></td></tr>
<tr class="separator:a8291483119dcf3831ee15dce5be0b85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae700b3b3135e46316e8c2c035e018e4b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename OutputItr &gt; </td></tr>
<tr class="memitem:ae700b3b3135e46316e8c2c035e018e4b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ae700b3b3135e46316e8c2c035e018e4b">flatten_il</a> (T &amp;&amp;il, OutputItr out_itr)</td></tr>
<tr class="memdesc:ae700b3b3135e46316e8c2c035e018e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens the contents of a (possibly nested) initializer_list into the provided buffer.  <a href="namespace_tiled_array.html#ae700b3b3135e46316e8c2c035e018e4b">More...</a><br /></td></tr>
<tr class="separator:ae700b3b3135e46316e8c2c035e018e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07853a9be617e5079dbc6768c6e72fc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aa07853a9be617e5079dbc6768c6e72fc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa07853a9be617e5079dbc6768c6e72fc">get_elem_from_il</a> (T idx, U &amp;&amp;il, std::size_t depth=0)</td></tr>
<tr class="memdesc:aa07853a9be617e5079dbc6768c6e72fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the specified element from an initializer_list.  <a href="namespace_tiled_array.html#aa07853a9be617e5079dbc6768c6e72fc">More...</a><br /></td></tr>
<tr class="separator:aa07853a9be617e5079dbc6768c6e72fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095de0b56a3abbd7dba7cd9d0085088e"><td class="memTemplParams" colspan="2">template&lt;typename ArrayType , typename T &gt; </td></tr>
<tr class="memitem:a095de0b56a3abbd7dba7cd9d0085088e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a095de0b56a3abbd7dba7cd9d0085088e">array_from_il</a> (World &amp;world, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;trange, T &amp;&amp;il)</td></tr>
<tr class="memdesc:a095de0b56a3abbd7dba7cd9d0085088e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an <code>std::initializer_list</code> into a tiled array.  <a href="namespace_tiled_array.html#a095de0b56a3abbd7dba7cd9d0085088e">More...</a><br /></td></tr>
<tr class="separator:a095de0b56a3abbd7dba7cd9d0085088e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9109c96280c540844ebe4e8ab8adecd"><td class="memTemplParams" colspan="2">template&lt;typename ArrayType , typename T &gt; </td></tr>
<tr class="memitem:af9109c96280c540844ebe4e8ab8adecd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#af9109c96280c540844ebe4e8ab8adecd">array_from_il</a> (World &amp;world, T &amp;&amp;il)</td></tr>
<tr class="memdesc:af9109c96280c540844ebe4e8ab8adecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an <code>std::initializer_list</code> into a single tile array.  <a href="namespace_tiled_array.html#af9109c96280c540844ebe4e8ab8adecd">More...</a><br /></td></tr>
<tr class="separator:af9109c96280c540844ebe4e8ab8adecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ed2ff1e65aebae0733ebc4b73e17bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a073741f90126d4c17df3404a58f13fd4">time_point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a28ed2ff1e65aebae0733ebc4b73e17bf">now</a> ()</td></tr>
<tr class="separator:a28ed2ff1e65aebae0733ebc4b73e17bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982f4ff04f86f6ea1bd32d0f8046d479"><td class="memItemLeft" align="right" valign="top">std::chrono::system_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a982f4ff04f86f6ea1bd32d0f8046d479">system_now</a> ()</td></tr>
<tr class="separator:a982f4ff04f86f6ea1bd32d0f8046d479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005131306e7ea258c4b32acb596b099e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a005131306e7ea258c4b32acb596b099e">duration_in_s</a> (<a class="el" href="namespace_tiled_array.html#a073741f90126d4c17df3404a58f13fd4">time_point</a> const &amp;t0, <a class="el" href="namespace_tiled_array.html#a073741f90126d4c17df3404a58f13fd4">time_point</a> const &amp;t1)</td></tr>
<tr class="separator:a005131306e7ea258c4b32acb596b099e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944424aad68a42848039f662a7eaaa57"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a944424aad68a42848039f662a7eaaa57">duration_in_ns</a> (<a class="el" href="namespace_tiled_array.html#a073741f90126d4c17df3404a58f13fd4">time_point</a> const &amp;t0, <a class="el" href="namespace_tiled_array.html#a073741f90126d4c17df3404a58f13fd4">time_point</a> const &amp;t1)</td></tr>
<tr class="separator:a944424aad68a42848039f662a7eaaa57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cc9b9b9bb8de13205881618621a353"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:af6cc9b9b9bb8de13205881618621a353"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#af6cc9b9b9bb8de13205881618621a353">operator&lt;&lt;</a> (std::ostream &amp;os, const std::vector&lt; T, A &gt; &amp;vec)</td></tr>
<tr class="memdesc:af6cc9b9b9bb8de13205881618621a353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector output stream operator.  <a href="namespace_tiled_array.html#af6cc9b9b9bb8de13205881618621a353">More...</a><br /></td></tr>
<tr class="separator:af6cc9b9b9bb8de13205881618621a353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b271d3125f302d86bcfbfae903a907"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ab0b271d3125f302d86bcfbfae903a907">ignore_tile_position</a> (bool b)</td></tr>
<tr class="separator:ab0b271d3125f302d86bcfbfae903a907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03207b3ecd61bae1b8ad439f583dc2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac03207b3ecd61bae1b8ad439f583dc2b">ignore_tile_position</a> ()</td></tr>
<tr class="separator:ac03207b3ecd61bae1b8ad439f583dc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">foreach/foreach_inplace functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><code>foreach/foreach_inplace</code> is a generalization of <code>std::transform</code> for <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> objects. Specifically, it applies callable <code>Op</code> to each tile in the argument <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> object (or objects for the binary <code>foreach/foreach_inplace</code> ). The <code>Op</code> callable either writes the output to the first tile it's given or it produces a new tile (of potentially different type). It also can optionally compute the norm of the result tile. A <code>foreach</code> function produces new <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> object, whereas <code>foreach_inplace</code> mutates the first <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> argument "in-place". For dense arrays <code>Op</code> therefore must be callable as</p><div class="fragment"><div class="line">void(ResultTile&amp;, <span class="keyword">const</span> ArgTiles&amp;...);</div>
</div><!-- fragment --><p> For sparse arrays <code>Op</code> must be callable as either </p><div class="fragment"><div class="line">void(ResultTile&amp;, <span class="keyword">const</span> ArgTiles&amp;...);</div>
</div><!-- fragment --><p> or as </p><div class="fragment"><div class="line">real(ResultTile&amp;, <span class="keyword">const</span> ArgTiles&amp;...);</div>
</div><!-- fragment --><p> where <code>real</code> is convertible to the first <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> argument's shape value; in the latter case the return value is converted to Policy::shape_type::value_type and used to construct the shape of the result, whereas in the former case the shape of the result is computed from the shapes of the <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> arguments (e.g. assigned to the shape of the first <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> argument). </p><dl class="section note"><dt>Note</dt><dd><code>foreach/foreach_inplace</code> are collective, with sparse variants synchronizing due to the need to compute and replicate shapes. </dd></dl>
</div></td></tr>
<tr class="memitem:a7945ee30f3a11a878035bb9e89dfe958"><td class="memTemplParams" colspan="2">template&lt;typename ResultTile , typename ArgTile , typename Policy , typename Op , typename  = typename std::enable_if&lt;              !std::is_same&lt;ResultTile, ArgTile&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a7945ee30f3a11a878035bb9e89dfe958"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt; Policy &gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ResultTile, Policy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a7945ee30f3a11a878035bb9e89dfe958">foreach</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ArgTile, Policy &gt; &amp;arg, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:a7945ee30f3a11a878035bb9e89dfe958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to each tile of a dense Array.  <a href="namespace_tiled_array.html#a7945ee30f3a11a878035bb9e89dfe958">More...</a><br /></td></tr>
<tr class="separator:a7945ee30f3a11a878035bb9e89dfe958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84773a24f4220b460b21d539df9f69c"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy , typename Op &gt; </td></tr>
<tr class="memitem:ac84773a24f4220b460b21d539df9f69c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt; Policy &gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac84773a24f4220b460b21d539df9f69c">foreach</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;arg, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:ac84773a24f4220b460b21d539df9f69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to each tile of a dense Array.  <a href="namespace_tiled_array.html#ac84773a24f4220b460b21d539df9f69c">More...</a><br /></td></tr>
<tr class="separator:ac84773a24f4220b460b21d539df9f69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e69c84228fd78ec135151a5747532c"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy , typename Op , typename  = typename std::enable_if&lt;!TiledArray::detail::is_array&lt;              typename std::decay&lt;Op&gt;::type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ac8e69c84228fd78ec135151a5747532c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt; Policy &gt;, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac8e69c84228fd78ec135151a5747532c">foreach_inplace</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;arg, Op &amp;&amp;op, bool fence=true)</td></tr>
<tr class="memdesc:ac8e69c84228fd78ec135151a5747532c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify each tile of a dense Array.  <a href="namespace_tiled_array.html#ac8e69c84228fd78ec135151a5747532c">More...</a><br /></td></tr>
<tr class="separator:ac8e69c84228fd78ec135151a5747532c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0cf0bb08d269dfb07bde76aad6c6f7"><td class="memTemplParams" colspan="2">template&lt;typename ResultTile , typename ArgTile , typename Policy , typename Op , typename  = typename std::enable_if&lt;              !std::is_same&lt;ResultTile, ArgTile&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aef0cf0bb08d269dfb07bde76aad6c6f7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt; Policy &gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ResultTile, Policy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aef0cf0bb08d269dfb07bde76aad6c6f7">foreach</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ArgTile, Policy &gt; arg, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:aef0cf0bb08d269dfb07bde76aad6c6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to each tile of a sparse Array.  <a href="namespace_tiled_array.html#aef0cf0bb08d269dfb07bde76aad6c6f7">More...</a><br /></td></tr>
<tr class="separator:aef0cf0bb08d269dfb07bde76aad6c6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b65150f57fc9f96cf8dfcb6e31cda8"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy , typename Op &gt; </td></tr>
<tr class="memitem:a04b65150f57fc9f96cf8dfcb6e31cda8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt; Policy &gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a04b65150f57fc9f96cf8dfcb6e31cda8">foreach</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;arg, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:a04b65150f57fc9f96cf8dfcb6e31cda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to each tile of a sparse Array.  <a href="namespace_tiled_array.html#a04b65150f57fc9f96cf8dfcb6e31cda8">More...</a><br /></td></tr>
<tr class="separator:a04b65150f57fc9f96cf8dfcb6e31cda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4365ce44bf73340cd20ab4c6baab47cf"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy , typename Op , typename  = typename std::enable_if&lt;!TiledArray::detail::is_array&lt;              typename std::decay&lt;Op&gt;::type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a4365ce44bf73340cd20ab4c6baab47cf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt; Policy &gt;, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4365ce44bf73340cd20ab4c6baab47cf">foreach_inplace</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;arg, Op &amp;&amp;op, bool fence=true)</td></tr>
<tr class="memdesc:a4365ce44bf73340cd20ab4c6baab47cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify each tile of a sparse Array.  <a href="namespace_tiled_array.html#a4365ce44bf73340cd20ab4c6baab47cf">More...</a><br /></td></tr>
<tr class="separator:a4365ce44bf73340cd20ab4c6baab47cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e432d6e141518fa470444aec670b8b"><td class="memTemplParams" colspan="2">template&lt;typename ResultTile , typename LeftTile , typename RightTile , typename Policy , typename Op , typename  = typename std::enable_if&lt;              !std::is_same&lt;ResultTile, LeftTile&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a19e432d6e141518fa470444aec670b8b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt; Policy &gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ResultTile, Policy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a19e432d6e141518fa470444aec670b8b">foreach</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, Policy &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; RightTile, Policy &gt; &amp;right, Op &amp;&amp;op)</td></tr>
<tr class="separator:a19e432d6e141518fa470444aec670b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75b6a88be41fe4ea7e33c6cdc7fc684"><td class="memTemplParams" colspan="2">template&lt;typename LeftTile , typename RightTile , typename Policy , typename Op &gt; </td></tr>
<tr class="memitem:ae75b6a88be41fe4ea7e33c6cdc7fc684"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt; Policy &gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, Policy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ae75b6a88be41fe4ea7e33c6cdc7fc684">foreach</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, Policy &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; RightTile, Policy &gt; &amp;right, Op &amp;&amp;op)</td></tr>
<tr class="separator:ae75b6a88be41fe4ea7e33c6cdc7fc684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ad32552784efd15270c457abdb4320"><td class="memTemplParams" colspan="2">template&lt;typename LeftTile , typename RightTile , typename Policy , typename Op &gt; </td></tr>
<tr class="memitem:a19ad32552784efd15270c457abdb4320"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt; Policy &gt;, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a19ad32552784efd15270c457abdb4320">foreach_inplace</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, Policy &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; RightTile, Policy &gt; &amp;right, Op &amp;&amp;op, bool fence=true)</td></tr>
<tr class="memdesc:a19ad32552784efd15270c457abdb4320"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes two input tiles and put result into the left tile.  <a href="namespace_tiled_array.html#a19ad32552784efd15270c457abdb4320">More...</a><br /></td></tr>
<tr class="separator:a19ad32552784efd15270c457abdb4320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0f5832ba5cbada5c52869c3dbb722f"><td class="memTemplParams" colspan="2">template&lt;typename ResultTile , typename LeftTile , typename RightTile , typename Policy , typename Op , typename  = typename std::enable_if&lt;              !std::is_same&lt;ResultTile, LeftTile&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a2f0f5832ba5cbada5c52869c3dbb722f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt; Policy &gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ResultTile, Policy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a2f0f5832ba5cbada5c52869c3dbb722f">foreach</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, Policy &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; RightTile, Policy &gt; &amp;right, Op &amp;&amp;op, const <a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07">ShapeReductionMethod</a> shape_reduction=<a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07aaef12e903e606a4895a16b393bfdec8c">ShapeReductionMethod::Intersect</a>)</td></tr>
<tr class="separator:a2f0f5832ba5cbada5c52869c3dbb722f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1cc9d36909dfeac2e76d49d285bc41b"><td class="memTemplParams" colspan="2">template&lt;typename LeftTile , typename RightTile , typename Policy , typename Op &gt; </td></tr>
<tr class="memitem:aa1cc9d36909dfeac2e76d49d285bc41b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt; Policy &gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, Policy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa1cc9d36909dfeac2e76d49d285bc41b">foreach</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, Policy &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; RightTile, Policy &gt; &amp;right, Op &amp;&amp;op, const <a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07">ShapeReductionMethod</a> shape_reduction=<a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07aaef12e903e606a4895a16b393bfdec8c">ShapeReductionMethod::Intersect</a>)</td></tr>
<tr class="separator:aa1cc9d36909dfeac2e76d49d285bc41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b064d85072d8a9c1f3d579027de636"><td class="memTemplParams" colspan="2">template&lt;typename LeftTile , typename RightTile , typename Policy , typename Op &gt; </td></tr>
<tr class="memitem:a02b064d85072d8a9c1f3d579027de636"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt; Policy &gt;, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a02b064d85072d8a9c1f3d579027de636">foreach_inplace</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, Policy &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; RightTile, Policy &gt; &amp;right, Op &amp;&amp;op, const <a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07">ShapeReductionMethod</a> shape_reduction=<a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07aaef12e903e606a4895a16b393bfdec8c">ShapeReductionMethod::Intersect</a>, bool fence=true)</td></tr>
<tr class="memdesc:a02b064d85072d8a9c1f3d579027de636"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes two input tiles and put result into the left tile.  <a href="namespace_tiled_array.html#a02b064d85072d8a9c1f3d579027de636">More...</a><br /></td></tr>
<tr class="separator:a02b064d85072d8a9c1f3d579027de636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">TiledArray initialization.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions initialize <a class="el" href="namespace_tiled_array.html">TiledArray</a> and (if needed) MADWorld runtime. </p><dl class="section note"><dt>Note</dt><dd>the default World object is set to the object returned by these. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>MADWorld can only be initialized/finalized once, hence if <a class="el" href="namespace_tiled_array.html">TiledArray</a> initializes MADWorld it can also be initialized/finalized only once. </dd></dl>
</div></td></tr>
<tr class="memitem:aa273a954beb5f7b7fc4d94c17c0c774d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa273a954beb5f7b7fc4d94c17c0c774d">ta_abort</a> ()</td></tr>
<tr class="separator:aa273a954beb5f7b7fc4d94c17c0c774d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9592cd825cf934e8fa07f1f085bf247"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ad9592cd825cf934e8fa07f1f085bf247">ta_abort</a> (const std::string &amp;m)</td></tr>
<tr class="separator:ad9592cd825cf934e8fa07f1f085bf247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1265733604f5af60af78a9d7fa3ae4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a0f1265733604f5af60af78a9d7fa3ae4">finalize</a> ()</td></tr>
<tr class="separator:a0f1265733604f5af60af78a9d7fa3ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">TiledArray initialization.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions initialize <a class="el" href="namespace_tiled_array.html">TiledArray</a> and (if needed) MADWorld runtime. </p><dl class="section note"><dt>Note</dt><dd>the default World object is set to the object returned by these. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>MADWorld can only be initialized/finalized once, hence if <a class="el" href="namespace_tiled_array.html">TiledArray</a> initializes MADWorld it can also be initialized/finalized only once. </dd></dl>
</div></td></tr>
<tr class="memitem:a1890cfcad9af02c7bbe1022d0cb7faab"><td class="memItemLeft" align="right" valign="top">World &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a1890cfcad9af02c7bbe1022d0cb7faab">initialize</a> (int &amp;argc, char **&amp;argv, const SafeMPI::Intracomm &amp;comm, bool quiet=true)</td></tr>
<tr class="separator:a1890cfcad9af02c7bbe1022d0cb7faab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42672835ea9434bc06ea421dea37d815"><td class="memItemLeft" align="right" valign="top">World &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a42672835ea9434bc06ea421dea37d815">initialize</a> (int &amp;argc, char **&amp;argv, bool quiet=true)</td></tr>
<tr class="separator:a42672835ea9434bc06ea421dea37d815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b712918a811f515dd5b49ff2750062"><td class="memItemLeft" align="right" valign="top">World &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa1b712918a811f515dd5b49ff2750062">initialize</a> (int &amp;argc, char **&amp;argv, const MPI_Comm &amp;comm, bool quiet=true)</td></tr>
<tr class="separator:aa1b712918a811f515dd5b49ff2750062"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad73c8b5fc3cf99546cf08ec8c8d755fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad73c8b5fc3cf99546cf08ec8c8d755fd"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a> = <a class="el" href="struct_tiled_array_1_1is__dense.html">is_dense</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ad73c8b5fc3cf99546cf08ec8c8d755fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a1107cd349cbbc9598530c502f01cca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6a1107cd349cbbc9598530c502f01cca"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga6a1107cd349cbbc9598530c502f01cca">is_lazy_tile_v</a> = <a class="el" href="struct_tiled_array_1_1is__lazy__tile.html">is_lazy_tile</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga6a1107cd349cbbc9598530c502f01cca"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>is_lazy_tile_v&lt;T&gt;</code> is an alias for <code>is_lazy_tile&lt;T&gt;::value</code>  <a href="group___tile_interface.html#ga6a1107cd349cbbc9598530c502f01cca">More...</a><br /></td></tr>
<tr class="separator:ga6a1107cd349cbbc9598530c502f01cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8e5435cf629c2353463f34b28b70b4c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac8e5435cf629c2353463f34b28b70b4c"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gac8e5435cf629c2353463f34b28b70b4c">is_consumable_tile_v</a> = <a class="el" href="struct_tiled_array_1_1is__consumable__tile.html">is_consumable_tile</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:gac8e5435cf629c2353463f34b28b70b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>is_consumable_tile_v&lt;T&gt;</code> is an alias for <code>is_consumable_tile&lt;T&gt;::value</code>  <a href="group___tile_interface.html#gac8e5435cf629c2353463f34b28b70b4c">More...</a><br /></td></tr>
<tr class="separator:gac8e5435cf629c2353463f34b28b70b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf38dec6e494f090575f45ea9f5234c5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename SizeType  = std::size_t&gt; </td></tr>
<tr class="memitem:abf38dec6e494f090575f45ea9f5234c5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#abf38dec6e494f090575f45ea9f5234c5">initializer_list_rank_v</a></td></tr>
<tr class="memdesc:abf38dec6e494f090575f45ea9f5234c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable for retrieving the degree of nesting for an std::initializer_list.  <a href="namespace_tiled_array.html#abf38dec6e494f090575f45ea9f5234c5">More...</a><br /></td></tr>
<tr class="separator:abf38dec6e494f090575f45ea9f5234c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="adf28ccfd580f62de5342a9a1510e22e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf28ccfd580f62de5342a9a1510e22e9">&#9670;&nbsp;</a></span>Array</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned int  = 0, typename Tile  = Tensor&lt;T, Eigen::aligned_allocator&lt;T&gt; &gt;, typename Policy  = DensePolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">TiledArray::Array</a> = typedef <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00117">117</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a598c53efb66f9c18b8a6b5bcfbeaf8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598c53efb66f9c18b8a6b5bcfbeaf8f3">&#9670;&nbsp;</a></span>EigenMatrixXcd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;std::complex&lt;double&gt;, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt; <a class="el" href="namespace_tiled_array.html#a598c53efb66f9c18b8a6b5bcfbeaf8f3">TiledArray::EigenMatrixXcd</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00047">47</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="adde89f3f1e4ba23ddf9ce7b6e2db088f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde89f3f1e4ba23ddf9ce7b6e2db088f">&#9670;&nbsp;</a></span>EigenMatrixXcf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;std::complex&lt;float&gt;, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt; <a class="el" href="namespace_tiled_array.html#adde89f3f1e4ba23ddf9ce7b6e2db088f">TiledArray::EigenMatrixXcf</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00050">50</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="ac5db88c965b8d32f1f72d37d3dc3561c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5db88c965b8d32f1f72d37d3dc3561c">&#9670;&nbsp;</a></span>EigenMatrixXd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt; <a class="el" href="namespace_tiled_array.html#ac5db88c965b8d32f1f72d37d3dc3561c">TiledArray::EigenMatrixXd</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00042">42</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="aacdf44d8771941244661bf77cf07069e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdf44d8771941244661bf77cf07069e">&#9670;&nbsp;</a></span>EigenMatrixXf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt; <a class="el" href="namespace_tiled_array.html#aacdf44d8771941244661bf77cf07069e">TiledArray::EigenMatrixXf</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00044">44</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="ae5d1d4be6c1d3cef049c42490778da56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d1d4be6c1d3cef049c42490778da56">&#9670;&nbsp;</a></span>EigenMatrixXi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;int, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt; <a class="el" href="namespace_tiled_array.html#ae5d1d4be6c1d3cef049c42490778da56">TiledArray::EigenMatrixXi</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00052">52</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="afa83a358322961f1da1b50d5e28ae0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa83a358322961f1da1b50d5e28ae0ea">&#9670;&nbsp;</a></span>EigenMatrixXl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;long, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt; <a class="el" href="namespace_tiled_array.html#afa83a358322961f1da1b50d5e28ae0ea">TiledArray::EigenMatrixXl</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00054">54</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a19c2ebf917a509ec12deca6a13dd1904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c2ebf917a509ec12deca6a13dd1904">&#9670;&nbsp;</a></span>EigenVectorXcd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;std::complex&lt;double&gt;, 1, Eigen::Dynamic&gt; <a class="el" href="namespace_tiled_array.html#a19c2ebf917a509ec12deca6a13dd1904">TiledArray::EigenVectorXcd</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00057">57</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="abfe17eddb0710849aa9af552f4f85098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe17eddb0710849aa9af552f4f85098">&#9670;&nbsp;</a></span>EigenVectorXcf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;std::complex&lt;float&gt;, 1, Eigen::Dynamic&gt; <a class="el" href="namespace_tiled_array.html#abfe17eddb0710849aa9af552f4f85098">TiledArray::EigenVectorXcf</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00058">58</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="aa783ea4f581c1c1bb75f647d68c65a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa783ea4f581c1c1bb75f647d68c65a68">&#9670;&nbsp;</a></span>EigenVectorXd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;double, Eigen::Dynamic, 1&gt; <a class="el" href="namespace_tiled_array.html#aa783ea4f581c1c1bb75f647d68c65a68">TiledArray::EigenVectorXd</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00055">55</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a0c54f8e9145825b6155cf5389a9ee03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c54f8e9145825b6155cf5389a9ee03a">&#9670;&nbsp;</a></span>EigenVectorXf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;float, Eigen::Dynamic, 1&gt; <a class="el" href="namespace_tiled_array.html#a0c54f8e9145825b6155cf5389a9ee03a">TiledArray::EigenVectorXf</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00056">56</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="acb38a6b56111826e5b451528b939eb60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb38a6b56111826e5b451528b939eb60">&#9670;&nbsp;</a></span>EigenVectorXi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;int, Eigen::Dynamic, 1&gt; <a class="el" href="namespace_tiled_array.html#acb38a6b56111826e5b451528b939eb60">TiledArray::EigenVectorXi</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00059">59</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="aec5f429338b7707830ce0339ebaf6274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5f429338b7707830ce0339ebaf6274">&#9670;&nbsp;</a></span>EigenVectorXl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;long, Eigen::Dynamic, 1&gt; <a class="el" href="namespace_tiled_array.html#aec5f429338b7707830ce0339ebaf6274">TiledArray::EigenVectorXl</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00060">60</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a670509be08925c46286e374cdeee130e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670509be08925c46286e374cdeee130e">&#9670;&nbsp;</a></span>result_of_trace_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array.html#a670509be08925c46286e374cdeee130e">TiledArray::result_of_trace_t</a> = typedef decltype(<a class="el" href="group___tile_interface.html#ga72bc37c3b1bcb1f5bb7f630667243615">trace</a>(std::declval&lt;T&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper type for determining the result of taking the trace of a tensor</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of tensor for which we want to know the type resulting from tracing it. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="trace_8h_source.html#l00102">102</a> of file <a class="el" href="trace_8h_source.html">trace.h</a>.</p>

</div>
</div>
<a id="a14381436074bbf8eff68427766e395a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14381436074bbf8eff68427766e395a2">&#9670;&nbsp;</a></span>TArray</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TiledArray::TArray</a> = typedef <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;T, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt;T&gt; &gt;, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00093">93</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="aea17c71440d5a58110b7ade911cf1102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea17c71440d5a58110b7ade911cf1102">&#9670;&nbsp;</a></span>TArrayC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt;std::complex&lt;float&gt; &gt; <a class="el" href="namespace_tiled_array.html#aea17c71440d5a58110b7ade911cf1102">TiledArray::TArrayC</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00099">99</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a0b25748e8f1dd4d7421925264bbe4905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b25748e8f1dd4d7421925264bbe4905">&#9670;&nbsp;</a></span>TArrayD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt;double&gt; <a class="el" href="namespace_tiled_array.html#a0b25748e8f1dd4d7421925264bbe4905">TiledArray::TArrayD</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00094">94</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="aaeec85e445a8f0330f135292858a3cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeec85e445a8f0330f135292858a3cb4">&#9670;&nbsp;</a></span>TArrayF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt;float&gt; <a class="el" href="namespace_tiled_array.html#aaeec85e445a8f0330f135292858a3cb4">TiledArray::TArrayF</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00096">96</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a2d6a345559008046e6785aee9d35f11d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6a345559008046e6785aee9d35f11d">&#9670;&nbsp;</a></span>TArrayI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt;int&gt; <a class="el" href="namespace_tiled_array.html#a2d6a345559008046e6785aee9d35f11d">TiledArray::TArrayI</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00095">95</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a99743650f2570e83f35a0ba1958c9569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99743650f2570e83f35a0ba1958c9569">&#9670;&nbsp;</a></span>TArrayL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt;long&gt; <a class="el" href="namespace_tiled_array.html#a99743650f2570e83f35a0ba1958c9569">TiledArray::TArrayL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00097">97</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="aa010edfe058bd83377e3790741e14dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa010edfe058bd83377e3790741e14dee">&#9670;&nbsp;</a></span>TArrayZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt;std::complex&lt;double&gt; &gt; <a class="el" href="namespace_tiled_array.html#aa010edfe058bd83377e3790741e14dee">TiledArray::TArrayZ</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00098">98</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="ac685ca67ab67879d908e57681834604c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac685ca67ab67879d908e57681834604c">&#9670;&nbsp;</a></span>TensorC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;std::complex&lt;float&gt;, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt;std::complex&lt;float&gt; &gt; &gt; <a class="el" href="namespace_tiled_array.html#ac685ca67ab67879d908e57681834604c">TiledArray::TensorC</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00059">59</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a362559c766dfbca887fc6dff5523fb3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a362559c766dfbca887fc6dff5523fb3b">&#9670;&nbsp;</a></span>TensorConstMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_  = Range, typename OpResult  = Tensor&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array.html#a362559c766dfbca887fc6dff5523fb3b">TiledArray::TensorConstMap</a> = typedef <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt;typename std::add_const&lt;T&gt;::type, Range_, OpResult&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00048">48</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a id="a1950fa935cff5cb1415b58d822057f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1950fa935cff5cb1415b58d822057f23">&#9670;&nbsp;</a></span>TensorConstView</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array.html#a1950fa935cff5cb1415b58d822057f23">TiledArray::TensorConstView</a> = typedef <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt;typename std::add_const&lt;T&gt;::type, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l00044">44</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ac1a673c87e7624e63f641318f610a297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a673c87e7624e63f641318f610a297">&#9670;&nbsp;</a></span>TensorD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;double, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt;double&gt; &gt; <a class="el" href="namespace_tiled_array.html#ac1a673c87e7624e63f641318f610a297">TiledArray::TensorD</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00050">50</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a43b4522d34881253139d842d7345dcbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b4522d34881253139d842d7345dcbc">&#9670;&nbsp;</a></span>TensorF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;float, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt;float&gt; &gt; <a class="el" href="namespace_tiled_array.html#a43b4522d34881253139d842d7345dcbc">TiledArray::TensorF</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00052">52</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a7f58ff1caa878600bc482e36acb64060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f58ff1caa878600bc482e36acb64060">&#9670;&nbsp;</a></span>TensorI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;int, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt;int&gt; &gt; <a class="el" href="namespace_tiled_array.html#a7f58ff1caa878600bc482e36acb64060">TiledArray::TensorI</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00051">51</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a940148a41f1a9b47fabd83511d0ad11f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940148a41f1a9b47fabd83511d0ad11f">&#9670;&nbsp;</a></span>TensorL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;long, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt;long&gt; &gt; <a class="el" href="namespace_tiled_array.html#a940148a41f1a9b47fabd83511d0ad11f">TiledArray::TensorL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00053">53</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="acf8bdb4a9d561d001f7a34f49c077a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8bdb4a9d561d001f7a34f49c077a5c">&#9670;&nbsp;</a></span>TensorMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_  = Range, typename OpResult  = Tensor&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array.html#acf8bdb4a9d561d001f7a34f49c077a5c">TiledArray::TensorMap</a> = typedef <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt;T, Range_, OpResult&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00045">45</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a id="a59d2edc4ec73d986edc524386dab1f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d2edc4ec73d986edc524386dab1f9c">&#9670;&nbsp;</a></span>TensorView</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array.html#a59d2edc4ec73d986edc524386dab1f9c">TiledArray::TensorView</a> = typedef <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt;T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l00041">41</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="abe4438e1e4fac9c7ed76af5bae4a6aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4438e1e4fac9c7ed76af5bae4a6aff">&#9670;&nbsp;</a></span>TensorZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;std::complex&lt;double&gt;, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt;std::complex&lt;double&gt; &gt; &gt; <a class="el" href="namespace_tiled_array.html#abe4438e1e4fac9c7ed76af5bae4a6aff">TiledArray::TensorZ</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00056">56</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a073741f90126d4c17df3404a58f13fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073741f90126d4c17df3404a58f13fd4">&#9670;&nbsp;</a></span>time_point</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array.html#a073741f90126d4c17df3404a58f13fd4">TiledArray::time_point</a> = typedef std::chrono::high_resolution_clock::time_point</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="time_8h_source.html#l00033">33</a> of file <a class="el" href="time_8h_source.html">time.h</a>.</p>

</div>
</div>
<a id="a0231c1beab8d7e7c31c19aeceede50fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0231c1beab8d7e7c31c19aeceede50fd">&#9670;&nbsp;</a></span>TSpArray</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TiledArray::TSpArray</a> = typedef <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;T, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt;T&gt; &gt;, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00103">103</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="add9caaa3d2c9f944690670df6a1a08ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add9caaa3d2c9f944690670df6a1a08ed">&#9670;&nbsp;</a></span>TSpArrayC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt;std::complex&lt;float&gt; &gt; <a class="el" href="namespace_tiled_array.html#add9caaa3d2c9f944690670df6a1a08ed">TiledArray::TSpArrayC</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00110">110</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="abb0c4ccd3689f4dafb20c6d238690705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0c4ccd3689f4dafb20c6d238690705">&#9670;&nbsp;</a></span>TSpArrayD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt;double&gt; <a class="el" href="namespace_tiled_array.html#abb0c4ccd3689f4dafb20c6d238690705">TiledArray::TSpArrayD</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00105">105</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a6bd8165f08a44cf5a27efca786bee5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd8165f08a44cf5a27efca786bee5ac">&#9670;&nbsp;</a></span>TSpArrayF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt;float&gt; <a class="el" href="namespace_tiled_array.html#a6bd8165f08a44cf5a27efca786bee5ac">TiledArray::TSpArrayF</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00107">107</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a4dd7da1c48d18d477b9d0366e94d9b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd7da1c48d18d477b9d0366e94d9b10">&#9670;&nbsp;</a></span>TSpArrayI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt;int&gt; <a class="el" href="namespace_tiled_array.html#a4dd7da1c48d18d477b9d0366e94d9b10">TiledArray::TSpArrayI</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00106">106</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a51e13a617d7cc592f38124462d5a853d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e13a617d7cc592f38124462d5a853d">&#9670;&nbsp;</a></span>TSpArrayL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt;long&gt; <a class="el" href="namespace_tiled_array.html#a51e13a617d7cc592f38124462d5a853d">TiledArray::TSpArrayL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00108">108</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="aa157a11e4eb462e70e5fec1411acab8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa157a11e4eb462e70e5fec1411acab8c">&#9670;&nbsp;</a></span>TSpArrayZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt;std::complex&lt;double&gt; &gt; <a class="el" href="namespace_tiled_array.html#aa157a11e4eb462e70e5fec1411acab8c">TiledArray::TSpArrayZ</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00109">109</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a259e0df1635b302bf4f6b15c354dd0ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259e0df1635b302bf4f6b15c354dd0ae">&#9670;&nbsp;</a></span>ExecutionSpace</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_tiled_array.html#a259e0df1635b302bf4f6b15c354dd0ae">TiledArray::ExecutionSpace</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>enumerates the execution spaces </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a259e0df1635b302bf4f6b15c354dd0aea2b55387dd066c5bac646ac61543d152d"></a>CPU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a259e0df1635b302bf4f6b15c354dd0aeaa33b7755e5f9b504d2d038eaca4ff28d"></a>CUDA&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="platform_8h_source.html#l00058">58</a> of file <a class="el" href="platform_8h_source.html">platform.h</a>.</p>

</div>
</div>
<a id="a075713b9b2f21c1f7a54361922ff9d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075713b9b2f21c1f7a54361922ff9d13">&#9670;&nbsp;</a></span>MemorySpace</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_tiled_array.html#a075713b9b2f21c1f7a54361922ff9d13">TiledArray::MemorySpace</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>enumerates the memory spaces </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a075713b9b2f21c1f7a54361922ff9d13abbb93ef26e3c101ff11cdd21cab08a94"></a>Null&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a075713b9b2f21c1f7a54361922ff9d13a2b55387dd066c5bac646ac61543d152d"></a>CPU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a075713b9b2f21c1f7a54361922ff9d13aa33b7755e5f9b504d2d038eaca4ff28d"></a>CUDA&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a075713b9b2f21c1f7a54361922ff9d13a8deda018646e16512ca30acee5c0d1f6"></a>CUDA_UM&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="platform_8h_source.html#l00030">30</a> of file <a class="el" href="platform_8h_source.html">platform.h</a>.</p>

</div>
</div>
<a id="a89f64eadfb2120154cc1848d7fc02f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f64eadfb2120154cc1848d7fc02f66">&#9670;&nbsp;</a></span>OrdinalType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_tiled_array.html#a89f64eadfb2120154cc1848d7fc02f66">TiledArray::OrdinalType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specifies how coordinates are mapped to ordinal values</p><ul>
<li>RowMajor: stride decreases as mode index increases</li>
<li>ColMajor: stride increases with the mode index</li>
<li>Other: unknown or dynamic order </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a89f64eadfb2120154cc1848d7fc02f66abba47a7c03289a67ca347baa3f55be2f"></a>RowMajor&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a89f64eadfb2120154cc1848d7fc02f66a9e91437ff30e153a77db79d1a362893a"></a>ColMajor&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a89f64eadfb2120154cc1848d7fc02f66a6311ae17c1ee52b36e68aaf4ad066387"></a>Other&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a89f64eadfb2120154cc1848d7fc02f66a4bbb8f967da6d1a610596d7257179c2b"></a>Invalid&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="tensor_2type__traits_8h_source.html#l00324">324</a> of file <a class="el" href="tensor_2type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="aa1333af3bbdd6ac34ec64a4eef6e9e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1333af3bbdd6ac34ec64a4eef6e9e07">&#9670;&nbsp;</a></span>ShapeReductionMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07">TiledArray::ShapeReductionMethod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa1333af3bbdd6ac34ec64a4eef6e9e07aaef12e903e606a4895a16b393bfdec8c"></a>Union&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa1333af3bbdd6ac34ec64a4eef6e9e07a6faa907d79c8bb46a12bea5c8de76654"></a>Intersect&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00049">49</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a37032bc091e5e9452a6385ebbce0dc94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37032bc091e5e9452a6385ebbce0dc94">&#9670;&nbsp;</a></span>abs_max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::abs_max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dist__array_8h_source.html#l01635">1635</a> of file <a class="el" href="dist__array_8h_source.html">dist_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a37032bc091e5e9452a6385ebbce0dc94_cgraph.png" border="0" usemap="#anamespace_tiled_array_a37032bc091e5e9452a6385ebbce0dc94_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a37032bc091e5e9452a6385ebbce0dc94_cgraph" id="anamespace_tiled_array_a37032bc091e5e9452a6385ebbce0dc94_cgraph">
<area shape="rect" title=" " alt="" coords="5,42,160,69"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a05c44cde899d571534b6ff2e9d22ed75" title=" " alt="" coords="208,5,365,47"/>
<area shape="rect" href="namespace_tiled_array.html#ae6e2da9f3855369c97e61e9105cce50a" title=" " alt="" coords="224,71,349,98"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="413,64,571,105"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a37032bc091e5e9452a6385ebbce0dc94_icgraph.png" border="0" usemap="#anamespace_tiled_array_a37032bc091e5e9452a6385ebbce0dc94_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a37032bc091e5e9452a6385ebbce0dc94_icgraph" id="anamespace_tiled_array_a37032bc091e5e9452a6385ebbce0dc94_icgraph">
<area shape="rect" title=" " alt="" coords="267,71,421,97"/>
<area shape="rect" href="group___tile_interface.html#ga86214f440122e8aac85a93dce17e0d7d" title="Absolute maximum element of a tile." alt="" coords="35,5,189,32"/>
<area shape="rect" href="struct_tiled_array_1_1math_1_1linalg_1_1_conjugate_gradient_solver.html#a76d41343afbc8d219dcaafb4ab32a64e" title=" " alt="" coords="15,56,209,112"/>
<area shape="rect" href="class_tiled_array_1_1_abs_max_reduction.html#ad9c41c32c3fd91dc3f89cd2202b9e202" title=" " alt="" coords="5,137,219,178"/>
</map>
</div>

</div>
</div>
<a id="ad09edca89f7e0f6b29c03206118a9c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09edca89f7e0f6b29c03206118a9c49">&#9670;&nbsp;</a></span>abs_min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::abs_min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dist__array_8h_source.html#l01630">1630</a> of file <a class="el" href="dist__array_8h_source.html">dist_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ad09edca89f7e0f6b29c03206118a9c49_cgraph.png" border="0" usemap="#anamespace_tiled_array_ad09edca89f7e0f6b29c03206118a9c49_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ad09edca89f7e0f6b29c03206118a9c49_cgraph" id="anamespace_tiled_array_ad09edca89f7e0f6b29c03206118a9c49_cgraph">
<area shape="rect" title=" " alt="" coords="5,42,156,69"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a05c44cde899d571534b6ff2e9d22ed75" title=" " alt="" coords="204,5,361,47"/>
<area shape="rect" href="namespace_tiled_array.html#ae6e2da9f3855369c97e61e9105cce50a" title=" " alt="" coords="220,71,345,98"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="409,64,567,105"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ad09edca89f7e0f6b29c03206118a9c49_icgraph.png" border="0" usemap="#anamespace_tiled_array_ad09edca89f7e0f6b29c03206118a9c49_icgraph" alt=""/></div>
<map name="namespace_tiled_array_ad09edca89f7e0f6b29c03206118a9c49_icgraph" id="anamespace_tiled_array_ad09edca89f7e0f6b29c03206118a9c49_icgraph">
<area shape="rect" title=" " alt="" coords="263,71,413,97"/>
<area shape="rect" href="group___tile_interface.html#gac89ec1d5bad433cb8a9ee8612a6d88fd" title="Absolute mainimum element of a tile." alt="" coords="35,5,185,32"/>
<area shape="rect" href="struct_tiled_array_1_1math_1_1linalg_1_1_conjugate_gradient_solver.html#a76d41343afbc8d219dcaafb4ab32a64e" title=" " alt="" coords="13,56,207,112"/>
<area shape="rect" href="class_tiled_array_1_1_abs_min_reduction.html#a1df628e219703bf23d42ebf0ddb3e930" title=" " alt="" coords="5,137,215,178"/>
</map>
</div>

</div>
</div>
<a id="a0b185f3cd563766c7aeab90312c8b499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b185f3cd563766c7aeab90312c8b499">&#9670;&nbsp;</a></span>absmax_reduce_cuda_kernel_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T TiledArray::absmax_reduce_cuda_kernel_impl </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="reduce__kernel__impl_8h_source.html#l00096">96</a> of file <a class="el" href="reduce__kernel__impl_8h_source.html">reduce_kernel_impl.h</a>.</p>

</div>
</div>
<a id="a9f0da95cfc7fbabc2f3ad067081cd78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0da95cfc7fbabc2f3ad067081cd78a">&#9670;&nbsp;</a></span>absmin_reduce_cuda_kernel_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T TiledArray::absmin_reduce_cuda_kernel_impl </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="reduce__kernel__impl_8h_source.html#l00113">113</a> of file <a class="el" href="reduce__kernel__impl_8h_source.html">reduce_kernel_impl.h</a>.</p>

</div>
</div>
<a id="a87ca6bca2735b62e0eaf5cac4a3cba58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ca6bca2735b62e0eaf5cac4a3cba58">&#9670;&nbsp;</a></span>add() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Left , typename Right &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::add </td>
          <td>(</td>
          <td class="paramtype">const Left &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(left.add(right)) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> tile arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Left</td><td>The left-hand tile type </td></tr>
    <tr><td class="paramname">Right</td><td>The right-hand tile type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand argument to be added </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand argument to be added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tile that is equal to <code>(left + right)</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tile__interface_2add_8h_source.html#l00043">43</a> of file <a class="el" href="tile__interface_2add_8h_source.html">add.h</a>.</p>

</div>
</div>
<a id="ac6c4e84610468c5983826d1395efff7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c4e84610468c5983826d1395efff7f">&#9670;&nbsp;</a></span>add() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Left , typename Right , typename Perm , typename  = std::enable_if_t&lt;TiledArray::detail::is_permutation_v&lt;Perm&gt; &amp;&amp;                                detail::has_member_function_add_anyreturn_v&lt;                                    const Left, const Right&amp;, const Perm&amp;&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::add </td>
          <td>(</td>
          <td class="paramtype">const Left &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> and permute tile arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Left</td><td>The left-hand tile type </td></tr>
    <tr><td class="paramname">Right</td><td>The right-hand tile type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand argument to be added </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand argument to be added </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tile that is equal to <code>perm ^ (left + right)</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tile__interface_2add_8h_source.html#l00077">77</a> of file <a class="el" href="tile__interface_2add_8h_source.html">add.h</a>.</p>

</div>
</div>
<a id="a3f55826b650600d7dbea2e362f5520c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f55826b650600d7dbea2e362f5520c6">&#9670;&nbsp;</a></span>add() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::add </td>
          <td>(</td>
          <td class="paramtype">const Left &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> and scale tile arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Left</td><td>The left-hand tile type </td></tr>
    <tr><td class="paramname">Right</td><td>The right-hand tile type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand argument to be added </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand argument to be added </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tile that is equal to <code>(left + right) * factor</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tile__interface_2add_8h_source.html#l00060">60</a> of file <a class="el" href="tile__interface_2add_8h_source.html">add.h</a>.</p>

</div>
</div>
<a id="ac3130f476f94d3917efcc41f483ef731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3130f476f94d3917efcc41f483ef731">&#9670;&nbsp;</a></span>add() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Left , typename Right , typename Scalar , typename Perm , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::add </td>
          <td>(</td>
          <td class="paramtype">const Left &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a>, scale, and permute tile arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Left</td><td>The left-hand tile type </td></tr>
    <tr><td class="paramname">Right</td><td>The right-hand tile type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand argument to be added </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand argument to be added </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tile that is equal to <code>perm ^ (left + right) * factor</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tile__interface_2add_8h_source.html#l00095">95</a> of file <a class="el" href="tile__interface_2add_8h_source.html">add.h</a>.</p>

</div>
</div>
<a id="af7b6f318b11b3abb7986751995a880d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b6f318b11b3abb7986751995a880d0">&#9670;&nbsp;</a></span>add_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Result , typename Arg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Result&amp; TiledArray::add_to </td>
          <td>(</td>
          <td class="paramtype">Result &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> to the result tile. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Result</td><td>The result tile type </td></tr>
    <tr><td class="paramname">Arg</td><td>The argument tile type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The result tile </td></tr>
    <tr><td class="paramname">arg</td><td>The argument to be added to the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tile that is equal to <code>result[i] += arg[i]</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tile__interface_2add_8h_source.html#l00108">108</a> of file <a class="el" href="tile__interface_2add_8h_source.html">add.h</a>.</p>

</div>
</div>
<a id="a17ec71822bfc6ea2da939913f8ee8f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ec71822bfc6ea2da939913f8ee8f02">&#9670;&nbsp;</a></span>add_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Result , typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Result&amp; TiledArray::add_to </td>
          <td>(</td>
          <td class="paramtype">Result &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> and scale to the result tile. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Result</td><td>The result tile type </td></tr>
    <tr><td class="paramname">Arg</td><td>The argument tile type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The result tile </td></tr>
    <tr><td class="paramname">arg</td><td>The argument to be added to <code>result</code> </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tile that is equal to <code>(result[i] += arg[i]) *= factor</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tile__interface_2add_8h_source.html#l00124">124</a> of file <a class="el" href="tile__interface_2add_8h_source.html">add.h</a>.</p>

</div>
</div>
<a id="a095de0b56a3abbd7dba7cd9d0085088e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095de0b56a3abbd7dba7cd9d0085088e">&#9670;&nbsp;</a></span>array_from_il() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayType , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::array_from_il </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>il</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an <code>std::initializer_list</code> into a tiled array. </p>
<p>This function encapsulates the process of turning an <code>std::initializer_list</code> into a <a class="el" href="namespace_tiled_array.html">TiledArray</a> array. The resulting tensor will have a tiling consistent with the provided <a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array.">TiledRange</a>, <code>trange</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This function will raise a static assertion if you try to construct a rank 0 tensor (<em>i.e.</em>, you pass in a single element and not an <code>std::initializer_list</code>).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArrayType</td><td>The type of the array we are creating. Expected to be have an API akin to that of <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> </td></tr>
    <tr><td class="paramname">T</td><td>The type of the provided <code>std::initializer_list</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">world</td><td>The context in which the resulting tensor will live. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trange</td><td>The tiling for the resulting tensor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>The initializer_list containing the initial state of the tensor. <code>il</code> is assumed to be non-empty and in row-major form. The nesting of <code>il</code> will be used to determine the rank of the resulting tensor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created instance of type <code>ArrayType</code> whose state is derived from <code>il</code> and exists in the <code>world</code> context.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>if <code>il</code> contains no elements. If an exception is raised <code>world</code>, <code>trange</code>, and <code>il</code> are unchanged (strong throw guarantee). </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>If the provided <code>std::initializer_list</code> is not rectangular (<em>e.g.</em>, attempting to initialize a matrix with the value <code>{{1, 2}, {3, 4, 5}}</code>). If an exception is raised <code>world</code>, <code>trange</code>, and <code>il</code> are unchanged. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="initializer__list_8h_source.html#l00315">315</a> of file <a class="el" href="initializer__list_8h_source.html">initializer_list.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a095de0b56a3abbd7dba7cd9d0085088e_cgraph.png" border="0" usemap="#anamespace_tiled_array_a095de0b56a3abbd7dba7cd9d0085088e_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a095de0b56a3abbd7dba7cd9d0085088e_cgraph" id="anamespace_tiled_array_a095de0b56a3abbd7dba7cd9d0085088e_cgraph">
<area shape="rect" title="Converts an std::initializer_list into a tiled array." alt="" coords="5,13,188,39"/>
<area shape="rect" href="namespace_tiled_array.html#aa07853a9be617e5079dbc6768c6e72fc" title="Retrieves the specified element from an initializer_list." alt="" coords="236,5,393,47"/>
</map>
</div>

</div>
</div>
<a id="af9109c96280c540844ebe4e8ab8adecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9109c96280c540844ebe4e8ab8adecd">&#9670;&nbsp;</a></span>array_from_il() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayType , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::array_from_il </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>il</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an <code>std::initializer_list</code> into a single tile array. </p>
<p>This function encapsulates the process of turning an <code>std::initializer_list</code> into a <a class="el" href="namespace_tiled_array.html">TiledArray</a> array. The resulting tensor will consistent of a single tile which holds all of the values.</p>
<dl class="section note"><dt>Note</dt><dd>This function will raise a static assertion if you try to construct a rank 0 tensor (<em>i.e.</em>, you pass in a single element and not an <code>std::initializer_list</code>).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArrayType</td><td>The type of the array we are creating. Expected to be have an API akin to that of <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> </td></tr>
    <tr><td class="paramname">T</td><td>The type of the provided <code>std::initializer_list</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">world</td><td>The context in which the resulting tensor will live. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>The initializer_list containing the initial state of the tensor. <code>il</code> is assumed to be non-empty and in row-major form. The nesting of <code>il</code> will be used to determine the rank of the resulting tensor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created instance of type <code>ArrayType</code> whose state is derived from <code>il</code> and exists in the <code>world</code> context.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>if <code>il</code> contains no elements. If an exception is raised <code>world</code> and <code>il</code> are unchanged (strong throw guarantee). </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>If the provided <code>std::initializer_list</code> is not rectangular (<em>e.g.</em>, attempting to initialize a matrix with the value <code>{{1, 2}, {3, 4, 5}}</code>). If an exception is raised <code>world</code> and <code>il</code> are unchanged. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="initializer__list_8h_source.html#l00367">367</a> of file <a class="el" href="initializer__list_8h_source.html">initializer_list.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_af9109c96280c540844ebe4e8ab8adecd_cgraph.png" border="0" usemap="#anamespace_tiled_array_af9109c96280c540844ebe4e8ab8adecd_cgraph" alt=""/></div>
<map name="namespace_tiled_array_af9109c96280c540844ebe4e8ab8adecd_cgraph" id="anamespace_tiled_array_af9109c96280c540844ebe4e8ab8adecd_cgraph">
<area shape="rect" title="Converts an std::initializer_list into a single tile array." alt="" coords="5,13,188,39"/>
<area shape="rect" href="namespace_tiled_array.html#a8291483119dcf3831ee15dce5be0b85a" title="Creates a TiledRange for the provided initializer list." alt="" coords="236,5,405,47"/>
</map>
</div>

</div>
</div>
<a id="ae732935e243d742f37911ca9592ab851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae732935e243d742f37911ca9592ab851">&#9670;&nbsp;</a></span>array_to_btas_tensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy , typename Storage  = std::vector&lt;typename Tile::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">btas::Tensor&lt;typename <a class="el" href="class_tiled_array_1_1_tile.html#ada00b9498ca68cabc845d54c14f07695">Tile::value_type</a>, btas::DEFAULT::range, Storage&gt; TiledArray::array_to_btas_tensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">TiledArray::DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_rank</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">TiledArray::DistArray</a> object into a btas::Tensor object. </p>
<p>This function will copy the contents of <code>src</code> into a <code>btas::Tensor</code> object. The copy operation is done in parallel, and this function will block until all elements of <code>src</code> have been copied into the result array tiles. The size of <code>src.world()</code>.size() must be equal to 1 or <code>src</code> must be a replicated <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">TiledArray::DistArray</a>. Usage:</p><div class="fragment"><div class="line"> <a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::TArrayD</a></div>
<div class="line">array(world, trange);</div>
<div class="line"><span class="comment">// Set tiles of array ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> t = <a class="code" href="namespace_tiled_array.html#ae732935e243d742f37911ca9592ab851">array_to_btas_tensor</a>(array);</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a></td><td>the tile type of <code>src</code> </td></tr>
    <tr><td class="paramname">Policy</td><td>the policy type of <code>src</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The TiledArray::DistArray&lt;Tile,Policy&gt; object whose contents will be copied to the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>btas::Tensor</code> object that is a copy of <code>src</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When world size is greater than 1 and <code>src</code> is not replicated </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target_rank</td><td>the rank on which to create the BTAS tensor containing the data of <code>src</code> ; if <code>target_rank=-1</code> then create the BTAS tensor on every rank (this requires that <code><a class="el" href="namespace_tiled_array.html#a9a805e13069e3aa1ea4c09910c1bb1bf">src.is_replicated()</a>==true</code> ) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BTAS tensor object containing the data of <code>src</code> , if my rank equals <code>target_rank</code> or <code>target_rank==-1</code> , default-initialized BTAS tensor otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="conversions_2btas_8h_source.html#l00301">301</a> of file <a class="el" href="conversions_2btas_8h_source.html">btas.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ae732935e243d742f37911ca9592ab851_cgraph.png" border="0" usemap="#anamespace_tiled_array_ae732935e243d742f37911ca9592ab851_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ae732935e243d742f37911ca9592ab851_cgraph" id="anamespace_tiled_array_ae732935e243d742f37911ca9592ab851_cgraph">
<area shape="rect" title="Convert a TiledArray::DistArray object into a btas::Tensor object." alt="" coords="5,291,156,332"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a2ade24f4de11bf1d530e7873dfd19599" title="Find local or remote tile by index." alt="" coords="204,137,361,179"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#ab824f8b38418197da56e2e52d611681c" title="Check for zero tiles." alt="" coords="409,201,567,243"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a26ad3fc01bc940ec5be321058196d180" title="Process map accessor." alt="" coords="204,257,361,299"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a911b5f4183473c9c9300c370b90374df" title="Returns the number of tiles in the tensor." alt="" coords="204,323,361,364"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="204,388,361,429"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor." alt="" coords="204,453,361,495"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_array_impl.html#a7d58f40964ccb5a9be544414f987e258" title="Tile future accessor." alt="" coords="421,136,555,177"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_distributed_storage.html#a1f2ed572953ea119f4cfb8505fca50b6" title="Get local or remote element." alt="" coords="615,5,796,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a2c5ad33baf5e6d3778e685929ca78504" title="Query for a zero tile." alt="" coords="628,201,783,243"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#acc3da081fcb2fd124122dc750d182a96" title="Tiles range accessor." alt="" coords="615,71,796,112"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a1a16c42818cf3c0174187604ed457e79" title="Tiled range accessor." alt="" coords="630,136,781,177"/>
</map>
</div>

</div>
</div>
<a id="ad4ffc6de9b633a34e7d724191cd11f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ffc6de9b633a34e7d724191cd11f3f">&#9670;&nbsp;</a></span>array_to_eigen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy , unsigned int EigenStorageOrder = Eigen::ColMajor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename <a class="el" href="class_tiled_array_1_1_tile.html#ada00b9498ca68cabc845d54c14f07695">Tile::value_type</a>, Eigen::Dynamic, Eigen::Dynamic, EigenStorageOrder&gt; TiledArray::array_to_eigen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an Array object into an <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> matrix object. </p>
<p>This function will copy the content of an <code>Array</code> object into matrix. The copy operation is done in parallel, and this function will block until all elements of <code>array</code> have been copied into the result matrix. The size of world must be exactly equal to 1, or <code>array</code> must be a replicated object. Usage: </p><div class="fragment"><div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::Array&lt;double, 2&gt;</a> array(world, trange);</div>
<div class="line"><span class="comment">// Set tiles of array ...</span></div>
<div class="line"> </div>
<div class="line">Eigen::MatrixXd m = <a class="code" href="namespace_tiled_array.html#ad4ffc6de9b633a34e7d724191cd11f3f">array_to_eigen</a>(array);</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a></td><td>The array tile type </td></tr>
    <tr><td class="paramname">EigenStorageOrder</td><td>The storage order of the resulting Eigen::Matrix object; the default is Eigen::ColMajor, i.e. the column-major storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array to be converted. It must be replicated if using 2 or more World ranks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> matrix; it will contain same data on each World rank. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When world size is greater than 1 and <code>array</code> is not replicated. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the number of dimensions of <code>array</code> is not equal to 1 or 2. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00496">496</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ad4ffc6de9b633a34e7d724191cd11f3f_cgraph.png" border="0" usemap="#anamespace_tiled_array_ad4ffc6de9b633a34e7d724191cd11f3f_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ad4ffc6de9b633a34e7d724191cd11f3f_cgraph" id="anamespace_tiled_array_ad4ffc6de9b633a34e7d724191cd11f3f_cgraph">
<area shape="rect" title="Convert an Array object into an Eigen matrix object." alt="" coords="5,319,156,361"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#afe493525138ef355ba76900e56ae8cf2" title="Task function for assigning a tensor to an Eigen submatrix." alt="" coords="207,35,358,91"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a2ade24f4de11bf1d530e7873dfd19599" title="Find local or remote tile by index." alt="" coords="204,173,361,214"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#ab824f8b38418197da56e2e52d611681c" title="Check for zero tiles." alt="" coords="410,253,567,294"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a26ad3fc01bc940ec5be321058196d180" title="Process map accessor." alt="" coords="204,290,361,331"/>
<area shape="rect" href="namespace_tiled_array.html#ae6e2da9f3855369c97e61e9105cce50a" title=" " alt="" coords="220,356,345,383"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="410,374,567,415"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a911b5f4183473c9c9300c370b90374df" title="Returns the number of tiles in the tensor." alt="" coords="204,458,361,499"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor." alt="" coords="204,523,361,565"/>
<area shape="rect" href="namespace_tiled_array.html#a3f423f82e222f193a882c9ea1cb7567f" title="Copy the content of a tensor into an Eigen matrix block." alt="" coords="409,13,568,54"/>
<area shape="rect" href="namespace_tiled_array.html#a03e3bc36192ae1bb9b4f6e3da001023a" title="Construct a const Eigen::Map object for a given Tensor object." alt="" coords="623,5,791,32"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_array_impl.html#a7d58f40964ccb5a9be544414f987e258" title="Tile future accessor." alt="" coords="422,173,555,214"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_distributed_storage.html#a1f2ed572953ea119f4cfb8505fca50b6" title="Get local or remote element." alt="" coords="616,57,797,98"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a2c5ad33baf5e6d3778e685929ca78504" title="Query for a zero tile." alt="" coords="629,253,784,294"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#acc3da081fcb2fd124122dc750d182a96" title="Tiles range accessor." alt="" coords="616,122,797,163"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a1a16c42818cf3c0174187604ed457e79" title="Tiled range accessor." alt="" coords="631,187,782,229"/>
</map>
</div>

</div>
</div>
<a id="a6bdf2a8c0016b75f187be14d3dde68b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bdf2a8c0016b75f187be14d3dde68b4">&#9670;&nbsp;</a></span>assert_failed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::assert_failed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="error_8h_source.html#l00064">64</a> of file <a class="el" href="error_8h_source.html">error.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a6bdf2a8c0016b75f187be14d3dde68b4_cgraph.png" border="0" usemap="#anamespace_tiled_array_a6bdf2a8c0016b75f187be14d3dde68b4_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a6bdf2a8c0016b75f187be14d3dde68b4_cgraph" id="anamespace_tiled_array_a6bdf2a8c0016b75f187be14d3dde68b4_cgraph">
<area shape="rect" title=" " alt="" coords="5,35,141,76"/>
<area shape="rect" href="namespace_tiled_array.html#aad641711c98c1b64bdf7ad28cccfae69" title=" " alt="" coords="189,5,349,47"/>
<area shape="rect" href="namespace_tiled_array.html#aa273a954beb5f7b7fc4d94c17c0c774d" title=" " alt="" coords="194,71,345,98"/>
</map>
</div>

</div>
</div>
<a id="ace7fbc10ae58bc49609c93b31fa7d4e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7fbc10ae58bc49609c93b31fa7d4e1">&#9670;&nbsp;</a></span>btas_subtensor_to_tensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_ , typename Storage_ , typename Tensor_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::btas_subtensor_to_tensor </td>
          <td>(</td>
          <td class="paramtype">const btas::Tensor&lt; T, Range_, Storage_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tensor_ &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a block of a btas::Tensor into a <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">TiledArray::Tensor</a>. </p>
<p>A block of btas::Tensor <code>src</code> will be copied into <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">TiledArray::Tensor</a> <code>dst</code>. The block dimensions will be determined by the dimensions of the range of <code>dst</code> . </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor element type </td></tr>
    <tr><td class="paramname">Range_</td><td>The range type of the source btas::Tensor object </td></tr>
    <tr><td class="paramname">Storage_</td><td>The storage type of the source btas::Tensor object </td></tr>
    <tr><td class="paramname">Tensor_</td><td>A tensor type (e.g., <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">TiledArray::Tensor</a> or btas::Tensor, optionally wrapped into <a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">TiledArray::Tile</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The source object; its subblock defined by the {lower,upper} bounds <code>{dst.lobound()</code>,dst.upbound()} will be copied to <code>dst</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>The object that will contain the contents of the corresponding subblock of src </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the dimensions of <code>src</code> and <code>dst</code> do not match. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2btas_8h_source.html#l00060">60</a> of file <a class="el" href="conversions_2btas_8h_source.html">btas.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ace7fbc10ae58bc49609c93b31fa7d4e1_cgraph.png" border="0" usemap="#anamespace_tiled_array_ace7fbc10ae58bc49609c93b31fa7d4e1_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ace7fbc10ae58bc49609c93b31fa7d4e1_cgraph" id="anamespace_tiled_array_ace7fbc10ae58bc49609c93b31fa7d4e1_cgraph">
<area shape="rect" title="Copy a block of a btas::Tensor into a TiledArray::Tensor." alt="" coords="5,89,200,131"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ab4da186af12caf4000fd293eaf2c744e" title="Range lower bound accessor." alt="" coords="281,5,426,47"/>
<area shape="rect" href="namespace_tiled_array.html#a4fc8675b642f53bdab884e5a6c473103" title=" " alt="" coords="248,71,459,98"/>
<area shape="rect" href="namespace_tiled_array.html#a676ce2ab1b89d4f820aba886f9ce12a7" title=" " alt="" coords="269,122,437,149"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a45190dfcad5ef2b9af5b4aa000c844b0" title=" " alt="" coords="287,173,420,215"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ac1fe1f599524763265207c84e909dd15" title="Range lower bound data accessor." alt="" coords="507,5,652,47"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a2208a1aeda0c14164e2689ee284aace2" title=" " alt="" coords="700,13,875,39"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ace7fbc10ae58bc49609c93b31fa7d4e1_icgraph.png" border="0" usemap="#anamespace_tiled_array_ace7fbc10ae58bc49609c93b31fa7d4e1_icgraph" alt=""/></div>
<map name="namespace_tiled_array_ace7fbc10ae58bc49609c93b31fa7d4e1_icgraph" id="anamespace_tiled_array_ace7fbc10ae58bc49609c93b31fa7d4e1_icgraph">
<area shape="rect" title="Copy a block of a btas::Tensor into a TiledArray::Tensor." alt="" coords="241,13,436,54"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#aead432075c6c7f2e9f7c329c96bc4d4a" title=" " alt="" coords="5,5,193,61"/>
</map>
</div>

</div>
</div>
<a id="aa4eb781438f1d5ffec3f75b879ead8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4eb781438f1d5ffec3f75b879ead8c0">&#9670;&nbsp;</a></span>btas_tensor_to_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DistArray_ , typename T , typename Range , typename Storage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DistArray_ TiledArray::btas_tensor_to_array </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const btas::Tensor&lt; T, <a class="el" href="class_tiled_array_1_1_range.html">Range</a>, Storage &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replicated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a btas::Tensor object into a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">TiledArray::DistArray</a> object. </p>
<p>This function will copy the contents of <code>src</code> into a <code>DistArray_</code> object that is tiled according to the <code>trange</code> object. If the <code>DistArray_</code> object has sparse policy, a sparse map with large norm is created to ensure all the values from <code>src</code> copy to the <code>DistArray_</code> object. The copy operation is done in parallel, and this function will block until all elements of <code>src</code> have been copied into the result array tiles. The size of <code>world.size()</code> must be equal to 1 or <code>replicate</code> must be equal to <code>true</code> . If <code>replicate</code> is <code>true</code>, it is your responsibility to ensure that the data in <code>src</code> is identical on all nodes. Upon completion, if the <code>DistArray_</code> object has sparse policy <a class="el" href="namespace_tiled_array.html#ae9879b4e6b03e7be2b37f3b1e8c8a0f8" title="Truncate a dense Array.">truncate()</a> is called.<br  />
Usage: </p><div class="fragment"><div class="line">btas::Tensor&lt;double&gt; src(100, 100, 100);</div>
<div class="line"><span class="comment">// Fill src with data ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a range for the new array object</span></div>
<div class="line">std::vector&lt;std::size_t&gt; blocks;</div>
<div class="line"><span class="keywordflow">for</span>(std::size_t i = 0ul; i &lt;= 100ul; i += 10ul)</div>
<div class="line">  blocks.push_back(i);</div>
<div class="line">std::array&lt;TiledArray::TiledRange1, 3&gt; blocks3 =</div>
<div class="line">    {{ <a class="code" href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a>(blocks.begin(), blocks.end()),</div>
<div class="line">       <a class="code" href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a>(blocks.begin(), blocks.end()),</div>
<div class="line">       <a class="code" href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a>(blocks.begin(), blocks.end()) }};</div>
<div class="line"><a class="code" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> trange(blocks3.begin(), blocks3.end());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create an Array from the source btas::Tensor object</span></div>
<div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::TArrayD</a> array =</div>
<div class="line">    btas_tensor_to_array&lt;decltype(array)&gt;(world, trange, src);</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DistArray_</td><td>a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">TiledArray::DistArray</a> type </td></tr>
    <tr><td class="paramname">TArgs</td><td>the type pack in type btas::Tensor&lt;TArgs...&gt; of <code>src</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">world</td><td>The world where the result array will live </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trange</td><td>The tiled range of the new array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The btas::Tensor&lt;TArgs..&gt; object whose contents will be copied to the result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replicated</td><td><code>true</code> indicates that the result array should be a replicated array [default = false]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>DistArray_</code> object that is a copy of <code>src</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When world size is greater than 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If using 2 or more World ranks, set <code>replicated=true</code> and make sure <code>matrix</code> is the same on each rank! </dd></dl>

<p class="definition">Definition at line <a class="el" href="conversions_2btas_8h_source.html#l00212">212</a> of file <a class="el" href="conversions_2btas_8h_source.html">btas.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_aa4eb781438f1d5ffec3f75b879ead8c0_cgraph.png" border="0" usemap="#anamespace_tiled_array_aa4eb781438f1d5ffec3f75b879ead8c0_cgraph" alt=""/></div>
<map name="namespace_tiled_array_aa4eb781438f1d5ffec3f75b879ead8c0_cgraph" id="anamespace_tiled_array_aa4eb781438f1d5ffec3f75b879ead8c0_cgraph">
<area shape="rect" title="Convert a btas::Tensor object into a TiledArray::DistArray object." alt="" coords="5,180,177,221"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a968fbd936a1606e7885e0912a739f331" title="Access the element range." alt="" coords="228,5,397,47"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ae240375dff3cdc73e249dfa9ee91c1b4" title="Range extent accessor." alt="" coords="240,71,385,112"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a491195742ae543d2e53d2234bbd0b631" title="Rank accessor." alt="" coords="225,137,400,163"/>
<area shape="rect" href="namespace_tiled_array.html#ae6e2da9f3855369c97e61e9105cce50a" title=" " alt="" coords="250,187,375,214"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a1980b233eaa1fc559b62cc8affc2bd34" title="Access the tile range." alt="" coords="228,239,397,280"/>
<area shape="rect" href="namespace_tiled_array.html#ae9879b4e6b03e7be2b37f3b1e8c8a0f8" title="Truncate a dense Array." alt="" coords="237,305,388,331"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a63700b9c4ebc8c67f46325f77ed4cd2a" title="Range volume accessor." alt="" coords="240,356,385,397"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ad3a6a74a7146b195f299c49c843b6fa5" title="Range extent data accessor." alt="" coords="454,71,599,112"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a2208a1aeda0c14164e2689ee284aace2" title=" " alt="" coords="653,78,828,105"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="448,180,605,221"/>
</map>
</div>

</div>
</div>
<a id="aead4454c3584b960202d2390a0139c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead4454c3584b960202d2390a0139c33">&#9670;&nbsp;</a></span>clone() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::clone </td>
          <td>(</td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of <code>arg</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>The tile argument type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The tile argument to be permuted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A (deep) copy of <code>arg</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tile__interface_2clone_8h_source.html#l00040">40</a> of file <a class="el" href="tile__interface_2clone_8h_source.html">clone.h</a>.</p>

</div>
</div>
<a id="a7c9fa503cbbd6e5627b1e1878cf51141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9fa503cbbd6e5627b1e1878cf51141">&#9670;&nbsp;</a></span>clone() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy&gt; TiledArray::clone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a deep copy of an array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a></td><td>The tile type of the array </td></tr>
    <tr><td class="paramname">Policy</td><td>The policy of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The array to be cloned </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2clone_8h_source.html#l00043">43</a> of file <a class="el" href="conversions_2clone_8h_source.html">clone.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a7c9fa503cbbd6e5627b1e1878cf51141_cgraph.png" border="0" usemap="#anamespace_tiled_array_a7c9fa503cbbd6e5627b1e1878cf51141_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a7c9fa503cbbd6e5627b1e1878cf51141_cgraph" id="anamespace_tiled_array_a7c9fa503cbbd6e5627b1e1878cf51141_cgraph">
<area shape="rect" title="Create a deep copy of an array." alt="" coords="5,263,136,290"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a2ade24f4de11bf1d530e7873dfd19599" title="Find local or remote tile by index." alt="" coords="197,79,355,120"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#ab824f8b38418197da56e2e52d611681c" title="Check for zero tiles." alt="" coords="416,140,573,181"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a26ad3fc01bc940ec5be321058196d180" title="Process map accessor." alt="" coords="197,256,355,297"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a32ab8231e6a7ef385ac938d1f98c649e" title=" " alt="" coords="184,205,368,231"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a3140a5cda14c2ea5b5e7c654099f015d" title="Shape accessor." alt="" coords="197,321,355,363"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="197,387,355,428"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor." alt="" coords="197,452,355,493"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_array_impl.html#a7d58f40964ccb5a9be544414f987e258" title="Tile future accessor." alt="" coords="428,75,561,116"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_distributed_storage.html#a1f2ed572953ea119f4cfb8505fca50b6" title="Get local or remote element." alt="" coords="621,5,803,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a2c5ad33baf5e6d3778e685929ca78504" title="Query for a zero tile." alt="" coords="635,136,789,177"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#acc3da081fcb2fd124122dc750d182a96" title="Tiles range accessor." alt="" coords="621,71,803,112"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a1a16c42818cf3c0174187604ed457e79" title="Tiled range accessor." alt="" coords="637,201,787,243"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_array_impl.html#a3205617f6c181fc8857407704007622c" title="Set tile." alt="" coords="428,257,561,299"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_distributed_storage.html#aa74a42e37342f0c2a80f623ac077266e" title="Set element i with value." alt="" coords="622,267,802,308"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_array_impl.html#a35765a0668e9e787ef688eb76f28a94e" title=" " alt="" coords="625,333,799,389"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a7c9fa503cbbd6e5627b1e1878cf51141_icgraph.png" border="0" usemap="#anamespace_tiled_array_a7c9fa503cbbd6e5627b1e1878cf51141_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a7c9fa503cbbd6e5627b1e1878cf51141_icgraph" id="anamespace_tiled_array_a7c9fa503cbbd6e5627b1e1878cf51141_icgraph">
<area shape="rect" title="Create a deep copy of an array." alt="" coords="247,105,377,131"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a7f1586d7c20390d1a25c9f2a4432731b" title="Create a deep copy of this array." alt="" coords="23,5,181,47"/>
<area shape="rect" href="group___tile_interface.html#gaec378f0f4b197546fb0b69f16748bfa1" title="Create a copy of arg." alt="" coords="37,71,167,98"/>
<area shape="rect" href="class_tiled_array_1_1tile__interface_1_1_clone.html#a376265d1f2ebd6ba898c665f269cae01" title=" " alt="" coords="11,122,193,178"/>
<area shape="rect" href="struct_tiled_array_1_1math_1_1linalg_1_1_conjugate_gradient_solver.html#a76d41343afbc8d219dcaafb4ab32a64e" title=" " alt="" coords="5,202,199,258"/>
</map>
</div>

</div>
</div>
<a id="a69da144eff9ec6f1ad28eb45e4332509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69da144eff9ec6f1ad28eb45e4332509">&#9670;&nbsp;</a></span>column_major_buffer_to_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">A TiledArray::column_major_buffer_to_array </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename A::trange_type &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename A::value_type::value_type *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>replicated</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; typename A::pmap_interface &gt;&#160;</td>
          <td class="paramname"><em>pmap</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a column-major matrix buffer into an Array object. </p>
<p>This function will copy the content of <code>buffer</code> into an <code>Array</code> object that is tiled according to the <code>trange</code> object. The copy operation is done in parallel, and this function will block until all elements of <code>matrix</code> have been copied into the result array tiles. Each tile is created using the local contents of <code>matrix</code>, hence it is your responsibility to ensure that the data in <code>matrix</code> is distributed correctly among the ranks. If in doubt, you should replicate <code>matrix</code> among the ranks prior to calling this.</p>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keywordtype">double</span>* buffer = <span class="keyword">new</span> <span class="keywordtype">double</span>[100 * 100];</div>
<div class="line"><span class="comment">// Fill buffer with data ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a range for the new array object</span></div>
<div class="line">std::vector&lt;std::size_t&gt; blocks;</div>
<div class="line"><span class="keywordflow">for</span>(std::size_t i = 0ul; i &lt;= 100ul; i += 10ul)</div>
<div class="line">  blocks.push_back(i);</div>
<div class="line">std::array&lt;TiledArray::TiledRange1, 2&gt; blocks2 =</div>
<div class="line">    {{ <a class="code" href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a>(blocks.begin(), blocks.end()),</div>
<div class="line">       <a class="code" href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a>(blocks.begin(), blocks.end()) }};</div>
<div class="line"><a class="code" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> trange(blocks2.begin(), blocks2.end());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create an Array from an Eigen matrix.</span></div>
<div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::Array&lt;double, 2&gt;</a> array =</div>
<div class="line">    column_major_buffer_to_array&lt;TiledArray::Array&lt;double, 2&gt; &gt;(world,</div>
<div class="line">    trange, buffer, 100, 100);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">delete</span> [] buffer;</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>The world where the array will live </td></tr>
    <tr><td class="paramname">trange</td><td>The tiled range of the new array </td></tr>
    <tr><td class="paramname">buffer</td><td>The row-major matrix buffer to be copied </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in the matrix </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix </td></tr>
    <tr><td class="paramname">replicated</td><td>if true, the result will be replicated [default = true]. </td></tr>
    <tr><td class="paramname">pmap</td><td>the process map object [default=null]; initialized to the default if <code>replicated</code> is false, or a replicated pmap if <code>replicated</code> is true; ignored if <code>replicated</code> is true and <code>world.size()&gt;1</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>Array</code> object that is a copy of <code>matrix</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When <code>m</code> and <code>n</code> are not equal to the number of rows or columns in tiled range. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00662">662</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="acd1b198e655d9877e8251a2cfc50c70b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1b198e655d9877e8251a2cfc50c70b">&#9670;&nbsp;</a></span>concat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> TiledArray::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates two ranges. </p>
<p>Tiles of the second range are concatenated to the tiles of the first. For example:</p><div class="fragment"><div class="line"> assert(<a class="code" href="namespace_tiled_array.html#acd1b198e655d9877e8251a2cfc50c70b">concat</a>((TiledRange1{1, 3, 7, 9}),(TiledRange1{0, 3, 4,</div>
<div class="line">5})) == (TiledRange1{1, 3, 7, 9, 12, 13, 14}));</div>
<div class="line">assert(<a class="code" href="namespace_tiled_array.html#acd1b198e655d9877e8251a2cfc50c70b">concat</a>((TiledRange1{0, 3, 4, 5}),(TiledRange1{1, 3, 7, 9})) ==</div>
<div class="line">(TiledRange1{0, 3, 4, 5, 7, 11, 13})); </div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>first range</td></tr>
    <tr><td class="paramname">r2</td><td>second range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>concatenated range </dd></dl>

<p class="definition">Definition at line <a class="el" href="tiled__range1_8h_source.html#l00339">339</a> of file <a class="el" href="tiled__range1_8h_source.html">tiled_range1.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_acd1b198e655d9877e8251a2cfc50c70b_cgraph.png" border="0" usemap="#anamespace_tiled_array_acd1b198e655d9877e8251a2cfc50c70b_cgraph" alt=""/></div>
<map name="namespace_tiled_array_acd1b198e655d9877e8251a2cfc50c70b_cgraph" id="anamespace_tiled_array_acd1b198e655d9877e8251a2cfc50c70b_cgraph">
<area shape="rect" title="Concatenates two ranges." alt="" coords="5,78,144,105"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range1.html#ae15d391924b138b2225502d61b9ae893" title="Returns true if this range is empty (i.e. has no tiles)" alt="" coords="192,5,369,47"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range1.html#a3314705efaa7c7bb527b9db101961f09" title="Tile range accessor." alt="" coords="192,71,369,112"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range1.html#ac6bed372a0e9b8cc224226cccec8cd5b" title="Tile range extent accessor." alt="" coords="192,136,369,177"/>
</map>
</div>

</div>
</div>
<a id="add57a0e7f0bc424ea564f06022ce91a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add57a0e7f0bc424ea564f06022ce91a3">&#9670;&nbsp;</a></span>congruent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::congruent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the two ranges are congruent. </p>
<p>This function tests that the rank and extent of <code>r1</code> are equal to those of <code>r2</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>The first <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a> to compare </td></tr>
    <tr><td class="paramname">r2</td><td>The second <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a> to compare </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="external_2btas_8h_source.html#l00083">83</a> of file <a class="el" href="external_2btas_8h_source.html">btas.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_add57a0e7f0bc424ea564f06022ce91a3_cgraph.png" border="0" usemap="#anamespace_tiled_array_add57a0e7f0bc424ea564f06022ce91a3_cgraph" alt=""/></div>
<map name="namespace_tiled_array_add57a0e7f0bc424ea564f06022ce91a3_cgraph" id="anamespace_tiled_array_add57a0e7f0bc424ea564f06022ce91a3_cgraph">
<area shape="rect" title="Test if the two ranges are congruent." alt="" coords="5,5,167,32"/>
<area shape="rect" href="namespace_tiled_array.html#ad03979f84fd9f2823892518870a3c779" title="Test that two BlockRange objects are congruent." alt="" coords="215,5,393,32"/>
</map>
</div>

</div>
</div>
<a id="ad6b673ef5df86a644ff32bd1338cca8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b673ef5df86a644ff32bd1338cca8f">&#9670;&nbsp;</a></span>device_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* TiledArray::device_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1cpu__cuda__vector.html">cpu_cuda_vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cpu__cuda__vector_8h_source.html#l00198">198</a> of file <a class="el" href="cpu__cuda__vector_8h_source.html">cpu_cuda_vector.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ad6b673ef5df86a644ff32bd1338cca8f_cgraph.png" border="0" usemap="#anamespace_tiled_array_ad6b673ef5df86a644ff32bd1338cca8f_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ad6b673ef5df86a644ff32bd1338cca8f_cgraph" id="anamespace_tiled_array_ad6b673ef5df86a644ff32bd1338cca8f_cgraph">
<area shape="rect" title=" " alt="" coords="5,13,180,39"/>
<area shape="rect" href="class_tiled_array_1_1cpu__cuda__vector.html#a51d7f35f800085d40a307a23728144d6" title=" " alt="" coords="228,5,385,47"/>
<area shape="rect" href="class_tiled_array_1_1cpu__cuda__vector.html#a964c6d249f341c439f319e4bd765ced3" title=" " alt="" coords="433,5,591,47"/>
</map>
</div>

</div>
</div>
<a id="a0e7241efe0fc81610af58e14dff7a9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7241efe0fc81610af58e14dff7a9f7">&#9670;&nbsp;</a></span>device_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* TiledArray::device_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1cpu__cuda__vector.html">cpu_cuda_vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cpu__cuda__vector_8h_source.html#l00193">193</a> of file <a class="el" href="cpu__cuda__vector_8h_source.html">cpu_cuda_vector.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a0e7241efe0fc81610af58e14dff7a9f7_cgraph.png" border="0" usemap="#anamespace_tiled_array_a0e7241efe0fc81610af58e14dff7a9f7_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a0e7241efe0fc81610af58e14dff7a9f7_cgraph" id="anamespace_tiled_array_a0e7241efe0fc81610af58e14dff7a9f7_cgraph">
<area shape="rect" title=" " alt="" coords="5,13,180,39"/>
<area shape="rect" href="class_tiled_array_1_1cpu__cuda__vector.html#a51d7f35f800085d40a307a23728144d6" title=" " alt="" coords="228,5,385,47"/>
<area shape="rect" href="class_tiled_array_1_1cpu__cuda__vector.html#a964c6d249f341c439f319e4bd765ced3" title=" " alt="" coords="433,5,591,47"/>
</map>
</div>

</div>
</div>
<a id="a529e79017aae7ae9256a7c5a2ab15893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a529e79017aae7ae9256a7c5a2ab15893">&#9670;&nbsp;</a></span>diagonal_array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array , typename RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt;RandomAccessIterator&gt;::value, <a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a>&gt; TiledArray::diagonal_array </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> const &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>diagonals_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>diagonals_end</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a non-constant diagonal <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a>. </p>
<p>Creates an array whose only nonzero values are the (hyper)diagonal elements (i.e. (n,n,n, ..., n) ); the values of the diagonal elements are given by an input range </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Array</td><td>a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> type </td></tr>
    <tr><td class="paramname">RandomAccessIterator</td><td>an iterator over the range of diagonal elements</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">world</td><td>The world for the array</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trange</td><td>The trange for the array</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diagonals_begin</td><td>the begin iterator of the range of the diagonals</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diagonals_end</td><td>the end iterator of the range of the diagonals; if not given, default initialized and thus will not be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a constant diagonal <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="diagonal__array_8h_source.html#l00262">262</a> of file <a class="el" href="diagonal__array_8h_source.html">diagonal_array.h</a>.</p>

</div>
</div>
<a id="a8d2668989011ee62fa6314733cfc4a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2668989011ee62fa6314733cfc4a32">&#9670;&nbsp;</a></span>diagonal_array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array , typename T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> TiledArray::diagonal_array </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> const &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a constant diagonal <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a>. </p>
<p>Creates an array whose only nonzero values are the (hyper)diagonal elements (i.e. (n,n,n, ..., n) ), and they are all have the same value </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Policy</td><td>the policy type of the resulting <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> </td></tr>
    <tr><td class="paramname">T</td><td>a numeric type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">world</td><td>The world for the array</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trange</td><td>The trange for the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value of the diagonal elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a constant diagonal <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="diagonal__array_8h_source.html#l00230">230</a> of file <a class="el" href="diagonal__array_8h_source.html">diagonal_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a8d2668989011ee62fa6314733cfc4a32_cgraph.png" border="0" usemap="#anamespace_tiled_array_a8d2668989011ee62fa6314733cfc4a32_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a8d2668989011ee62fa6314733cfc4a32_cgraph" id="anamespace_tiled_array_a8d2668989011ee62fa6314733cfc4a32_cgraph">
<area shape="rect" title="Creates a constant diagonal DistArray." alt="" coords="5,764,157,805"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a33aa537f17e1c4de2e8abf7093e29699" title="computes shape data (i.e. Frobenius norms of the tiles) for a constant diagonal tensor" alt="" coords="215,855,349,896"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a808571423d2d6d551e9844f0b38369a8" title="Writes tiles of a constant diagonal array." alt="" coords="205,635,359,691"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#ae2c7d290f2fb4704eecc33b0894de068" title="Computes a range of the diagonal elements (if any) in a rank&#45;d Range." alt="" coords="425,643,558,684"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a0e4a2c7494c37bf43a7aa51387c8e596" title="Convert an element index to a tile index." alt="" coords="407,825,576,867"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#ac8c1d53822fd3da51824e4d97a11dd2a" title="The rank accessor." alt="" coords="633,851,803,892"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a968fbd936a1606e7885e0912a739f331" title="Access the element range." alt="" coords="407,760,576,801"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ae240375dff3cdc73e249dfa9ee91c1b4" title="Range extent accessor." alt="" coords="419,943,564,984"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a3b9b907038dcf65d86d1bc12811c8333" title="Construct a range for the tile indexed by the given ordinal index." alt="" coords="407,1008,576,1049"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a1980b233eaa1fc559b62cc8affc2bd34" title="Access the tile range." alt="" coords="633,1037,803,1079"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ac1fe1f599524763265207c84e909dd15" title="Range lower bound data accessor." alt="" coords="645,643,791,684"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a491195742ae543d2e53d2234bbd0b631" title="Rank accessor." alt="" coords="631,774,805,801"/>
<area shape="rect" href="namespace_tiled_array.html#ae6e2da9f3855369c97e61e9105cce50a" title=" " alt="" coords="655,591,781,618"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a7ee2666c973a1cc4a17845f6a410dbe9" title="Range upper bound data accessor." alt="" coords="645,708,791,749"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a2208a1aeda0c14164e2689ee284aace2" title=" " alt="" coords="860,715,1035,742"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="869,617,1026,659"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ad3a6a74a7146b195f299c49c843b6fa5" title="Range extent data accessor." alt="" coords="645,929,791,971"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a740c01f878f645a3ab53274c912e0b72" title="Initialize (local) tiles with a user provided functor." alt="" coords="413,296,570,337"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a8587157f8ad46d5da4f786b79110d0ab" title="End iterator factory function." alt="" coords="624,333,812,359"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a2ade24f4de11bf1d530e7873dfd19599" title="Find local or remote tile by index." alt="" coords="639,384,797,425"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a2c5ad33baf5e6d3778e685929ca78504" title="Query for a zero tile." alt="" coords="1096,435,1251,476"/>
<area shape="rect" href="namespace_tiled_array.html#aa44cdecfe02b2ca9f8134aed6c94f39c" title=" " alt="" coords="641,5,795,47"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a918e59bf6434157aa2ee5bc55ef7346e" title="Accessor for the (shared_ptr to) implementation object." alt="" coords="639,71,797,112"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a5453d5add8c76bda66060c5bbffafd29" title="Tensor process map accessor." alt="" coords="645,136,791,177"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a32ab8231e6a7ef385ac938d1f98c649e" title=" " alt="" coords="626,501,810,527"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#ab9ccdd9c8bdae8959099fa3bf1568b31" title="Accessor for the (weak_ptr to) implementation object." alt="" coords="639,201,797,243"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#aad3dc345429ff7e85c8f0d970d3038bd" title="World accessor." alt="" coords="645,267,791,308"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_array_impl.html#a7d58f40964ccb5a9be544414f987e258" title="Tile future accessor." alt="" coords="881,384,1014,425"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_distributed_storage.html#a1f2ed572953ea119f4cfb8505fca50b6" title="Get local or remote element." alt="" coords="1083,304,1264,345"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#acc3da081fcb2fd124122dc750d182a96" title="Tiles range accessor." alt="" coords="1083,369,1264,411"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a1a16c42818cf3c0174187604ed457e79" title="Tiled range accessor." alt="" coords="1098,500,1249,541"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_array_impl.html#a3205617f6c181fc8857407704007622c" title="Set tile." alt="" coords="881,552,1014,593"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_distributed_storage.html#aa74a42e37342f0c2a80f623ac077266e" title="Set element i with value." alt="" coords="1083,565,1263,607"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_array_impl.html#a35765a0668e9e787ef688eb76f28a94e" title=" " alt="" coords="1086,631,1261,687"/>
</map>
</div>

</div>
</div>
<a id="a56e8a14dc06218506b921b90d86bf622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e8a14dc06218506b921b90d86bf622">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dist__array_8h_source.html#l01640">1640</a> of file <a class="el" href="dist__array_8h_source.html">dist_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a56e8a14dc06218506b921b90d86bf622_cgraph.png" border="0" usemap="#anamespace_tiled_array_a56e8a14dc06218506b921b90d86bf622_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a56e8a14dc06218506b921b90d86bf622_cgraph" id="anamespace_tiled_array_a56e8a14dc06218506b921b90d86bf622_cgraph">
<area shape="rect" title=" " alt="" coords="5,42,123,69"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a05c44cde899d571534b6ff2e9d22ed75" title=" " alt="" coords="171,5,328,47"/>
<area shape="rect" href="namespace_tiled_array.html#ae6e2da9f3855369c97e61e9105cce50a" title=" " alt="" coords="187,71,312,98"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="376,64,533,105"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a56e8a14dc06218506b921b90d86bf622_icgraph.png" border="0" usemap="#anamespace_tiled_array_a56e8a14dc06218506b921b90d86bf622_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a56e8a14dc06218506b921b90d86bf622_icgraph" id="anamespace_tiled_array_a56e8a14dc06218506b921b90d86bf622_icgraph">
<area shape="rect" title=" " alt="" coords="237,35,355,61"/>
<area shape="rect" href="group___tile_interface.html#gaf71813b13896a29698efff4232719d70" title="Vector dot product of a tile." alt="" coords="39,5,156,32"/>
<area shape="rect" href="class_tiled_array_1_1_dot_reduction.html#ae9f6343d37bfa088e4a28896cac26f7a" title=" " alt="" coords="5,57,189,98"/>
</map>
</div>

</div>
</div>
<a id="a944424aad68a42848039f662a7eaaa57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944424aad68a42848039f662a7eaaa57">&#9670;&nbsp;</a></span>duration_in_ns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t TiledArray::duration_in_ns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array.html#a073741f90126d4c17df3404a58f13fd4">time_point</a> const &amp;&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array.html#a073741f90126d4c17df3404a58f13fd4">time_point</a> const &amp;&#160;</td>
          <td class="paramname"><em>t1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="time_8h_source.html#l00045">45</a> of file <a class="el" href="time_8h_source.html">time.h</a>.</p>

</div>
</div>
<a id="a005131306e7ea258c4b32acb596b099e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005131306e7ea258c4b32acb596b099e">&#9670;&nbsp;</a></span>duration_in_s()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double TiledArray::duration_in_s </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array.html#a073741f90126d4c17df3404a58f13fd4">time_point</a> const &amp;&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array.html#a073741f90126d4c17df3404a58f13fd4">time_point</a> const &amp;&#160;</td>
          <td class="paramname"><em>t1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="time_8h_source.html#l00041">41</a> of file <a class="el" href="time_8h_source.html">time.h</a>.</p>

</div>
</div>
<a id="a8766afb7352ed5fd13da1606e526fd6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8766afb7352ed5fd13da1606e526fd6b">&#9670;&nbsp;</a></span>eigen_map() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Eigen::StorageOptions Storage = Eigen::RowMajor, std::enable_if_t&lt; detail::is_contiguous_tensor_v&lt; T &gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Map&lt;const Eigen::Matrix&lt;typename T::value_type, Eigen::Dynamic, Eigen::Dynamic, Storage&gt;, Eigen::AutoAlign&gt; TiledArray::eigen_map </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a const Eigen::Map object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> object. </p>
<p>The dimensions of the result tensor are extracted from the tensor itself </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A contiguous tensor type, e.g. <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">TiledArray::Tensor</a> ; namely, <code><a class="el" href="namespace_tiled_array_1_1detail.html#a777fdd832b3e46e8d73323db6b3b32d3">TiledArray::detail::is_contiguous_tensor_v&lt;T&gt;</a></code> must be true </td></tr>
    <tr><td class="paramname">Storage</td><td>the tensor layout, either Eigen::RowMajor (default) or Eigen::ColMajor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor object, laid out according to Storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> matrix map for <code>tensor</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When <code>tensor</code> dimensions are not equal to 2 or 1. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00161">161</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a03e3bc36192ae1bb9b4f6e3da001023a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e3bc36192ae1bb9b4f6e3da001023a">&#9670;&nbsp;</a></span>eigen_map() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Eigen::StorageOptions Storage = Eigen::RowMajor, std::enable_if_t&lt; detail::is_contiguous_tensor_v&lt; T &gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Map&lt;const Eigen::Matrix&lt;typename T::value_type, Eigen::Dynamic, Eigen::Dynamic, Storage&gt;, Eigen::AutoAlign&gt; TiledArray::eigen_map </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a const Eigen::Map object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A contiguous tensor type, e.g. <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">TiledArray::Tensor</a> ; namely, <code><a class="el" href="namespace_tiled_array_1_1detail.html#a777fdd832b3e46e8d73323db6b3b32d3">TiledArray::detail::is_contiguous_tensor_v&lt;T&gt;</a></code> must be true </td></tr>
    <tr><td class="paramname">Storage</td><td>the tensor layout, either Eigen::RowMajor (default) or Eigen::ColMajor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor object, laid out according to Storage </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in the result matrix </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the result matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An m x n <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> matrix map for <code>tensor</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When m * n is not equal to <code>tensor</code> size </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00077">77</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a03e3bc36192ae1bb9b4f6e3da001023a_icgraph.png" border="0" usemap="#anamespace_tiled_array_a03e3bc36192ae1bb9b4f6e3da001023a_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a03e3bc36192ae1bb9b4f6e3da001023a_icgraph" id="anamespace_tiled_array_a03e3bc36192ae1bb9b4f6e3da001023a_icgraph">
<area shape="rect" title="Construct a const Eigen::Map object for a given Tensor object." alt="" coords="719,93,887,120"/>
<area shape="rect" href="namespace_tiled_array.html#ab7d37708c45657fc2af47759b65e607a" title="Copy a block of an Eigen matrix into a tensor." alt="" coords="458,13,663,54"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1linalg_1_1scalapack_1_1_block_cyclic_matrix.html#a79bdccd08fb030e045bf01fd764f5912" title=" " alt="" coords="451,79,671,135"/>
<area shape="rect" href="namespace_tiled_array.html#a3f423f82e222f193a882c9ea1cb7567f" title="Copy the content of a tensor into an Eigen matrix block." alt="" coords="481,159,640,201"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a5235a162fdccd242f61ab4fb2818bf83" title="Task function for converting Eigen submatrix to a tensor." alt="" coords="204,5,403,61"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#afe493525138ef355ba76900e56ae8cf2" title="Task function for assigning a tensor to an Eigen submatrix." alt="" coords="228,152,379,208"/>
<area shape="rect" href="namespace_tiled_array.html#ad4ffc6de9b633a34e7d724191cd11f3f" title="Convert an Array object into an Eigen matrix object." alt="" coords="5,159,156,201"/>
</map>
</div>

</div>
</div>
<a id="a537bd30ddd02a942483a30de7d24b8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537bd30ddd02a942483a30de7d24b8fa">&#9670;&nbsp;</a></span>eigen_map() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::enable_if_t&lt; detail::is_contiguous_tensor_v&lt; T &gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Map&lt; const Eigen::Matrix&lt;typename T::value_type, Eigen::Dynamic, 1&gt;, Eigen::AutoAlign&gt; TiledArray::eigen_map </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a const Eigen::Map object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A contiguous tensor type, e.g. <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">TiledArray::Tensor</a> ; namely, <code><a class="el" href="namespace_tiled_array_1_1detail.html#a777fdd832b3e46e8d73323db6b3b32d3">TiledArray::detail::is_contiguous_tensor_v&lt;T&gt;</a></code> must be true</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor object</td></tr>
    <tr><td class="paramname">n</td><td>The number of elements in the result matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An n element <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> vector map for <code>tensor</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When n is not equal to <code>tensor</code> size </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00120">120</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="ac760760f57ff14f177edfb7f3656968e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac760760f57ff14f177edfb7f3656968e">&#9670;&nbsp;</a></span>eigen_map() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Eigen::StorageOptions Storage = Eigen::RowMajor, std::enable_if_t&lt; detail::is_contiguous_tensor_v&lt; T &gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Map&lt;Eigen::Matrix&lt;typename T::value_type, Eigen::Dynamic, Eigen::Dynamic, Storage&gt;, Eigen::AutoAlign&gt; TiledArray::eigen_map </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an Eigen::Map object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> object. </p>
<p>The dimensions of the result tensor are extracted from the tensor itself </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A contiguous tensor type, e.g. <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">TiledArray::Tensor</a> ; namely, <code><a class="el" href="namespace_tiled_array_1_1detail.html#a777fdd832b3e46e8d73323db6b3b32d3">TiledArray::detail::is_contiguous_tensor_v&lt;T&gt;</a></code> must be true </td></tr>
    <tr><td class="paramname">Storage</td><td>the tensor layout, either Eigen::RowMajor (default) or Eigen::ColMajor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor object, laid out according to Storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> matrix map for <code>tensor</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">When</td><td><code>tensor</code> dimensions are not equal to 2 or 1. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00184">184</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="acb3193ab0ab6071c4b49f1001a8011a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3193ab0ab6071c4b49f1001a8011a4">&#9670;&nbsp;</a></span>eigen_map() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Eigen::StorageOptions Storage = Eigen::RowMajor, std::enable_if_t&lt; detail::is_contiguous_tensor_v&lt; T &gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Map&lt;Eigen::Matrix&lt;typename T::value_type, Eigen::Dynamic, Eigen::Dynamic, Storage&gt;, Eigen::AutoAlign&gt; TiledArray::eigen_map </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an Eigen::Map object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A contiguous tensor type, e.g. <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">TiledArray::Tensor</a> ; namely, <code><a class="el" href="namespace_tiled_array_1_1detail.html#a777fdd832b3e46e8d73323db6b3b32d3">TiledArray::detail::is_contiguous_tensor_v&lt;T&gt;</a></code> must be true </td></tr>
    <tr><td class="paramname">Storage</td><td>the tensor layout, either Eigen::RowMajor (default) or Eigen::ColMajor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor object, laid out according to Storage </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in the result matrix </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the result matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An m x n <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> matrix map for <code>tensor</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When m * n is not equal to <code>tensor</code> size </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00100">100</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a4b924855cb7d0183bbfb021e30ccc141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b924855cb7d0183bbfb021e30ccc141">&#9670;&nbsp;</a></span>eigen_map() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::enable_if_t&lt; detail::is_contiguous_tensor_v&lt; T &gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Map&lt;Eigen::Matrix&lt;typename T::value_type, Eigen::Dynamic, 1&gt;, Eigen::AutoAlign&gt; TiledArray::eigen_map </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an Eigen::Map object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensor type, e.g. <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">TiledArray::Tensor</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor object </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements in the result matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An n element <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> vector map for <code>tensor</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When n is not equal to <code>tensor</code> size </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00139">139</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="ab7d37708c45657fc2af47759b65e607a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d37708c45657fc2af47759b65e607a">&#9670;&nbsp;</a></span>eigen_submatrix_to_tensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Derived , std::enable_if_t&lt; detail::is_contiguous_tensor_v&lt; T &gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::eigen_submatrix_to_tensor </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a block of an <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> matrix into a tensor. </p>
<p>A block of <code>matrix</code> will be copied into <code>tensor</code>. The block dimensions will be determined by the dimensions of the tensor's range. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensor type, e.g. <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">TiledArray::Tensor</a> </td></tr>
    <tr><td class="paramname">Derived</td><td>The derived type of an <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The object that will be assigned the content of <code>tensor</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tensor</td><td>The object that will be assigned the content of <code>matrix</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the dimensions of <code>tensor</code> are not equal to 1 or 2. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the range of <code>tensor</code> is outside the range of <code>matrix</code> . </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00207">207</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ab7d37708c45657fc2af47759b65e607a_cgraph.png" border="0" usemap="#anamespace_tiled_array_ab7d37708c45657fc2af47759b65e607a_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ab7d37708c45657fc2af47759b65e607a_cgraph" id="anamespace_tiled_array_ab7d37708c45657fc2af47759b65e607a_cgraph">
<area shape="rect" title="Copy a block of an Eigen matrix into a tensor." alt="" coords="5,5,211,47"/>
<area shape="rect" href="namespace_tiled_array.html#a03e3bc36192ae1bb9b4f6e3da001023a" title="Construct a const Eigen::Map object for a given Tensor object." alt="" coords="259,13,427,39"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ab7d37708c45657fc2af47759b65e607a_icgraph.png" border="0" usemap="#anamespace_tiled_array_ab7d37708c45657fc2af47759b65e607a_icgraph" alt=""/></div>
<map name="namespace_tiled_array_ab7d37708c45657fc2af47759b65e607a_icgraph" id="anamespace_tiled_array_ab7d37708c45657fc2af47759b65e607a_icgraph">
<area shape="rect" title="Copy a block of an Eigen matrix into a tensor." alt="" coords="252,13,457,54"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a5235a162fdccd242f61ab4fb2818bf83" title="Task function for converting Eigen submatrix to a tensor." alt="" coords="5,5,204,61"/>
</map>
</div>

</div>
</div>
<a id="a4d23e5d8e0578276832bdbb6aac7e712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d23e5d8e0578276832bdbb6aac7e712">&#9670;&nbsp;</a></span>eigen_to_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">A TiledArray::eigen_to_array </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename A::trange_type &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replicated</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; typename A::pmap_interface &gt;&#160;</td>
          <td class="paramname"><em>pmap</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> matrix into an Array object. </p>
<p>This function will copy the content of <code>matrix</code> into an <code>Array</code> object that is tiled according to the <code>trange</code> object. The copy operation is done in parallel, and this function will block until all elements of <code>matrix</code> have been copied into the result array tiles. Each tile is created using the local contents of <code>matrix</code>, hence it is your responsibility to ensure that the data in <code>matrix</code> is distributed correctly among the ranks. If in doubt, you should replicate <code>matrix</code> among the ranks prior to calling this.</p>
<p>Usage: </p><div class="fragment"><div class="line">Eigen::MatrixXd m(100, 100);</div>
<div class="line"><span class="comment">// Fill m with data ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a range for the new array object</span></div>
<div class="line">std::vector&lt;std::size_t&gt; blocks;</div>
<div class="line"><span class="keywordflow">for</span>(std::size_t i = 0ul; i &lt;= 100ul; i += 10ul)</div>
<div class="line">  blocks.push_back(i);</div>
<div class="line">std::array&lt;TiledArray::TiledRange1, 2&gt; blocks2 =</div>
<div class="line">    {{ <a class="code" href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a>(blocks.begin(), blocks.end()),</div>
<div class="line">       <a class="code" href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a>(blocks.begin(), blocks.end()) }};</div>
<div class="line"><a class="code" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> trange(blocks2.begin(), blocks2.end());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create an Array from an Eigen matrix.</span></div>
<div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::Array&lt;double, 2&gt;</a> array =</div>
<div class="line">    eigen_to_array&lt;TiledArray::Array&lt;double, 2&gt; &gt;(world, trange, m);</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The array type </td></tr>
    <tr><td class="paramname">Derived</td><td>The <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> matrix derived type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>The world where the array will live </td></tr>
    <tr><td class="paramname">trange</td><td>The tiled range of the new array </td></tr>
    <tr><td class="paramname">matrix</td><td>The <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> matrix to be copied </td></tr>
    <tr><td class="paramname">replicated</td><td>if true, the result will be replicated [default = true]. </td></tr>
    <tr><td class="paramname">pmap</td><td>the process map object [default=null]; initialized to the default if <code>replicated</code> is false, or a replicated pmap if <code>replicated</code> is true; ignored if <code>replicated</code> is true and <code>world.size()&gt;1</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>Array</code> object that is a copy of <code>matrix</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00409">409</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="aad641711c98c1b64bdf7ad28cccfae69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad641711c98c1b64bdf7ad28cccfae69">&#9670;&nbsp;</a></span>exception_break()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::exception_break </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Place a break point on this function to stop before <a class="el" href="namespace_tiled_array.html">TiledArray</a> exceptions are thrown. </p>

<p class="definition">Definition at line <a class="el" href="error_8h_source.html#l00062">62</a> of file <a class="el" href="error_8h_source.html">error.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_aad641711c98c1b64bdf7ad28cccfae69_icgraph.png" border="0" usemap="#anamespace_tiled_array_aad641711c98c1b64bdf7ad28cccfae69_icgraph" alt=""/></div>
<map name="namespace_tiled_array_aad641711c98c1b64bdf7ad28cccfae69_icgraph" id="anamespace_tiled_array_aad641711c98c1b64bdf7ad28cccfae69_icgraph">
<area shape="rect" title=" " alt="" coords="189,5,349,47"/>
<area shape="rect" href="namespace_tiled_array.html#a6bdf2a8c0016b75f187be14d3dde68b4" title=" " alt="" coords="5,5,141,47"/>
</map>
</div>

</div>
</div>
<a id="a0f1265733604f5af60af78a9d7fa3ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1265733604f5af60af78a9d7fa3ae4">&#9670;&nbsp;</a></span>finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finalizes <a class="el" href="namespace_tiled_array.html">TiledArray</a> (and MADWorld runtime, if it had not been initialized when <a class="el" href="namespace_tiled_array.html#a1890cfcad9af02c7bbe1022d0cb7faab">TiledArray::initialize</a> was called). </p>

<p class="definition">Definition at line <a class="el" href="tiledarray_8cpp_source.html#l00118">118</a> of file <a class="el" href="tiledarray_8cpp_source.html">tiledarray.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a0f1265733604f5af60af78a9d7fa3ae4_cgraph.png" border="0" usemap="#anamespace_tiled_array_a0f1265733604f5af60af78a9d7fa3ae4_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a0f1265733604f5af60af78a9d7fa3ae4_cgraph" id="anamespace_tiled_array_a0f1265733604f5af60af78a9d7fa3ae4_cgraph">
<area shape="rect" title=" " alt="" coords="5,46,148,73"/>
<area shape="rect" href="namespace_tiled_array.html#a8bb41dd83ecdc33052c9c02eeda152e8" title=" " alt="" coords="202,5,373,47"/>
<area shape="rect" href="namespace_tiled_array.html#a8869aaf7a547c7f9870fb0d12cbdfd09" title=" " alt="" coords="196,71,379,112"/>
<area shape="rect" href="struct_tiled_array_1_1detail_1_1default__world.html#af83d72c429e45b6b67859fac623d6af7" title=" " alt="" coords="427,5,575,47"/>
<area shape="rect" href="namespace_tiled_array.html#a52e6e0c952abcd7466a0efdcbf305681" title=" " alt="" coords="623,13,783,39"/>
<area shape="rect" href="struct_tiled_array_1_1detail_1_1default__world.html#a8b208921f20466d1e807709942581396" title=" " alt="" coords="427,71,574,112"/>
</map>
</div>

</div>
</div>
<a id="ab38811364e6ac3b5c0a5ac02ae19ddac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38811364e6ac3b5c0a5ac02ae19ddac">&#9670;&nbsp;</a></span>finalized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::finalized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="namespace_tiled_array.html">TiledArray</a> has been finalized at least once </dd></dl>

<p class="definition">Definition at line <a class="el" href="tiledarray_8cpp_source.html#l00066">66</a> of file <a class="el" href="tiledarray_8cpp_source.html">tiledarray.cpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ab38811364e6ac3b5c0a5ac02ae19ddac_icgraph.png" border="0" usemap="#anamespace_tiled_array_ab38811364e6ac3b5c0a5ac02ae19ddac_icgraph" alt=""/></div>
<map name="namespace_tiled_array_ab38811364e6ac3b5c0a5ac02ae19ddac_icgraph" id="anamespace_tiled_array_ab38811364e6ac3b5c0a5ac02ae19ddac_icgraph">
<area shape="rect" title=" " alt="" coords="405,5,556,32"/>
<area shape="rect" href="namespace_tiled_array.html#a1890cfcad9af02c7bbe1022d0cb7faab" title=" " alt="" coords="205,5,357,32"/>
<area shape="rect" href="namespace_tiled_array.html#a42672835ea9434bc06ea421dea37d815" title=" " alt="" coords="5,5,157,32"/>
</map>
</div>

</div>
</div>
<a id="ae700b3b3135e46316e8c2c035e018e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae700b3b3135e46316e8c2c035e018e4b">&#9670;&nbsp;</a></span>flatten_il()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename OutputItr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::flatten_il </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputItr&#160;</td>
          <td class="paramname"><em>out_itr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens the contents of a (possibly nested) initializer_list into the provided buffer. </p>
<p>This function is used to flatten a (possibly nested) <code>std::initializer_list</code> into a buffer provided by the user. The flattening occurs by iterating over the layers of the <code>std::initializer_list</code> in a depth-first manner. As the initializer_list is flattened the data is copied into the container associated with <code>out_itr</code>. It is assumed that the container associated with <code>out_itr</code> is already allocated or that <code>out_itr</code> will internally allocate the memory on-the-fly (<em>e.g.</em> <code>std::back_insert_iterator</code>).</p>
<p>This function works with empty <code>std::initializer_list</code> instances (you will get back <code>out_itr</code> unchanged and the corresponding container is unchanged) as well as single tensor elements (<em>i.e.</em>, initializing a scalar); in the latter case the buffer corresponding to <code>out_itr</code> must contain room for at least one element as the element will be copied to the buffer.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Expected to be the type of a tensor element (<em>i.e.</em> float, double, <em>etc.</em>) or a (possibly nested) <code>std::initializer_list</code> of tensor elements. </td></tr>
    <tr><td class="paramname">OutputItr</td><td>The type of an iterator which can be used to fill a container. It must satisfy the concept of Output Iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>The <code>std::initializer_list</code> we are flattening. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out_itr</td><td>An iterator pointing to the first element where data should be copied to. Memory in the destination container is assumed to be pre-allocated otherwise @</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>out_itr</code> pointing to just past the last element inserted by this function.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>If the provided <code>std::initializer_list</code> is not rectangular (<em>e.g.</em>, attempting to initialize a matrix with the value <code>{{1, 2}, {3, 4, 5}}</code>). If an exception is thrown <code>il</code> and <code>out_itr</code> are in their original state (strong throw guarantee). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="initializer__list_8h_source.html#l00205">205</a> of file <a class="el" href="initializer__list_8h_source.html">initializer_list.h</a>.</p>

</div>
</div>
<a id="a7945ee30f3a11a878035bb9e89dfe958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7945ee30f3a11a878035bb9e89dfe958">&#9670;&nbsp;</a></span>foreach() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultTile , typename ArgTile , typename Policy , typename Op , typename  = typename std::enable_if&lt;              !std::is_same&lt;ResultTile, ArgTile&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if_t&lt;<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt;Policy&gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;ResultTile, Policy&gt; &gt; TiledArray::foreach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ArgTile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a function to each tile of a dense Array. </p>
<p>This function uses an <code>Array</code> object to generate a new <code>Array</code> where the output tiles are a function of the input tiles. Users must provide a function/functor that initializes the tiles for the new <code>Array</code> object. For example, if we want to create a new array with were each element is equal to the square root of the corresponding element of the original array: </p><div class="fragment"><div class="line"><a class="code" href="namespace_tiled_array.html#abb0c4ccd3689f4dafb20c6d238690705">TSpArrayD</a> out_array =</div>
<div class="line">    <span class="keywordflow">foreach</span>(in_array, [=] (<span class="keyword">auto</span>&amp; out_tile,</div>
<div class="line">                           <span class="keyword">const</span> <span class="keyword">auto</span>&amp; in_tile) {</div>
<div class="line">      out_tile = in_tile.unary([=] (<span class="keyword">const</span> <span class="keywordtype">double</span> value) -&gt; <span class="keywordtype">double</span></div>
<div class="line">          { <span class="keywordflow">return</span> std::sqrt(value); });</div>
<div class="line">    });</div>
</div><!-- fragment --><p> The expected signature of the tile operation is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> op(ResultTile&amp; result_tile,</div>
<div class="line">        <span class="keyword">const</span> ArgTile&amp; arg_tile);</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultTile</td><td>The tile type of the result array </td></tr>
    <tr><td class="paramname">ArgTile</td><td>The tile type of <code>arg</code> </td></tr>
    <tr><td class="paramname">Policy</td><td>The policy type of <code>arg</code>; <code>is_dense_v&lt;Policy&gt;</code> must be true </td></tr>
    <tr><td class="paramname">Op</td><td><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The tile function </td></tr>
    <tr><td class="paramname">arg</td><td>The argument array </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00425">425</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>

</div>
</div>
<a id="aef0cf0bb08d269dfb07bde76aad6c6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0cf0bb08d269dfb07bde76aad6c6f7">&#9670;&nbsp;</a></span>foreach() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultTile , typename ArgTile , typename Policy , typename Op , typename  = typename std::enable_if&lt;              !std::is_same&lt;ResultTile, ArgTile&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if_t&lt;!<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt;Policy&gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;ResultTile, Policy&gt; &gt; TiledArray::foreach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ArgTile, Policy &gt;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a function to each tile of a sparse Array. </p>
<p>This function uses an <code>Array</code> object to generate a new <code>Array</code> where the output tiles are a function of the input tiles. Users must provide a function/functor that initializes the tiles for the new <code>Array</code> object. For example, if we want to create a new array with were each element is equal to the square root of the corresponding element of the original array: </p><div class="fragment"><div class="line"><a class="code" href="namespace_tiled_array.html#abb0c4ccd3689f4dafb20c6d238690705">TSpArrayD</a> out_array =</div>
<div class="line">    <span class="keywordflow">foreach</span>(in_array, [] (<span class="keyword">auto</span>&amp; out_tile,</div>
<div class="line">                          <span class="keyword">const</span> <span class="keyword">auto</span>&amp; in_tile) -&gt; <span class="keywordtype">float</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordtype">double</span> norm_squared = 0.0;</div>
<div class="line">      out_tile = in_tile.unary([&amp;] (<span class="keyword">const</span> <span class="keywordtype">double</span> value) -&gt; <span class="keywordtype">double</span> {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> result = std::sqrt(value);</div>
<div class="line">        norm_squared += result * result;</div>
<div class="line">        <span class="keywordflow">return</span> result;</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">return</span> std::sqrt(norm_squared);</div>
<div class="line">    });</div>
</div><!-- fragment --><p> The expected signature of the tile operation is: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> op(ResultTile&amp; result_tile,</div>
<div class="line">         <span class="keyword">const</span> Tile&amp; arg_tile);</div>
</div><!-- fragment --><p> where in the case of standard Policy (i.e. <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a>) the return value of <code>op</code> is the 2-norm (Frobenius norm) of the result tile. </p><dl class="section note"><dt>Note</dt><dd>This function should not be used to initialize the tiles of an array object. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultTile</td><td>The tile type of the result </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a></td><td>The tile type of <code>arg</code> </td></tr>
    <tr><td class="paramname">Policy</td><td>The policy type of <code>arg</code>; <code>is_dense_v&lt;Policy&gt;</code> must be false </td></tr>
    <tr><td class="paramname">Op</td><td><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The argument array</td></tr>
    <tr><td class="paramname">op</td><td>The tile function </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00524">524</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>

</div>
</div>
<a id="a19e432d6e141518fa470444aec670b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e432d6e141518fa470444aec670b8b">&#9670;&nbsp;</a></span>foreach() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultTile , typename LeftTile , typename RightTile , typename Policy , typename Op , typename  = typename std::enable_if&lt;              !std::is_same&lt;ResultTile, LeftTile&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if_t&lt;<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt;Policy&gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;ResultTile, Policy&gt; &gt; TiledArray::foreach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; RightTile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply a function to each tile of dense Arrays The following function takes two input tiles </p>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00602">602</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>

</div>
</div>
<a id="ae75b6a88be41fe4ea7e33c6cdc7fc684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75b6a88be41fe4ea7e33c6cdc7fc684">&#9670;&nbsp;</a></span>foreach() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LeftTile , typename RightTile , typename Policy , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if_t&lt;<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt;Policy&gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;LeftTile, Policy&gt; &gt; TiledArray::foreach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; RightTile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specialization of foreach&lt;ResultTile,ArgTile,Op&gt; for the case <code>ResultTile</code> == <code>ArgTile</code> </p>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00613">613</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>

</div>
</div>
<a id="a2f0f5832ba5cbada5c52869c3dbb722f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0f5832ba5cbada5c52869c3dbb722f">&#9670;&nbsp;</a></span>foreach() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultTile , typename LeftTile , typename RightTile , typename Policy , typename Op , typename  = typename std::enable_if&lt;              !std::is_same&lt;ResultTile, LeftTile&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if_t&lt;!<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt;Policy&gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;ResultTile, Policy&gt; &gt; TiledArray::foreach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; RightTile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07">ShapeReductionMethod</a>&#160;</td>
          <td class="paramname"><em>shape_reduction</em> = <code><a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07aaef12e903e606a4895a16b393bfdec8c">ShapeReductionMethod::Intersect</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply a function to each tile of sparse Arrays The following function takes two input tiles </p>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00640">640</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>

</div>
</div>
<a id="aa1cc9d36909dfeac2e76d49d285bc41b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1cc9d36909dfeac2e76d49d285bc41b">&#9670;&nbsp;</a></span>foreach() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LeftTile , typename RightTile , typename Policy , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if_t&lt;!<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt;Policy&gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;LeftTile, Policy&gt; &gt; TiledArray::foreach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; RightTile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07">ShapeReductionMethod</a>&#160;</td>
          <td class="paramname"><em>shape_reduction</em> = <code><a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07aaef12e903e606a4895a16b393bfdec8c">ShapeReductionMethod::Intersect</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specialization of foreach&lt;ResultTile,ArgTile,Op&gt; for the case <code>ResultTile</code> == <code>ArgTile</code> </p>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00653">653</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>

</div>
</div>
<a id="ac84773a24f4220b460b21d539df9f69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84773a24f4220b460b21d539df9f69c">&#9670;&nbsp;</a></span>foreach() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt;Policy&gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy&gt; &gt; TiledArray::foreach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a function to each tile of a dense Array. </p>
<p>Specialization of foreach&lt;ResultTile,ArgTile,Op&gt; for the case <code>ResultTile</code> == <code>ArgTile</code> </p>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00436">436</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>

</div>
</div>
<a id="a04b65150f57fc9f96cf8dfcb6e31cda8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b65150f57fc9f96cf8dfcb6e31cda8">&#9670;&nbsp;</a></span>foreach() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt;Policy&gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy&gt; &gt; TiledArray::foreach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a function to each tile of a sparse Array. </p>
<p>Specialization of foreach&lt;ResultTile,ArgTile,Op&gt; for the case <code>ResultTile</code> == <code>ArgTile</code> </p>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00535">535</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>

</div>
</div>
<a id="a19ad32552784efd15270c457abdb4320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ad32552784efd15270c457abdb4320">&#9670;&nbsp;</a></span>foreach_inplace() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LeftTile , typename RightTile , typename Policy , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt;Policy&gt;, void&gt; TiledArray::foreach_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; RightTile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fence</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function takes two input tiles and put result into the left tile. </p>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00622">622</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a19ad32552784efd15270c457abdb4320_cgraph.png" border="0" usemap="#anamespace_tiled_array_a19ad32552784efd15270c457abdb4320_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a19ad32552784efd15270c457abdb4320_cgraph" id="anamespace_tiled_array_a19ad32552784efd15270c457abdb4320_cgraph">
<area shape="rect" title="This function takes two input tiles and put result into the left tile." alt="" coords="5,5,151,47"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor." alt="" coords="199,5,356,47"/>
</map>
</div>

</div>
</div>
<a id="a02b064d85072d8a9c1f3d579027de636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02b064d85072d8a9c1f3d579027de636">&#9670;&nbsp;</a></span>foreach_inplace() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LeftTile , typename RightTile , typename Policy , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt;Policy&gt;, void&gt; TiledArray::foreach_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; RightTile, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07">ShapeReductionMethod</a>&#160;</td>
          <td class="paramname"><em>shape_reduction</em> = <code><a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07aaef12e903e606a4895a16b393bfdec8c">ShapeReductionMethod::Intersect</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fence</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function takes two input tiles and put result into the left tile. </p>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00664">664</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a02b064d85072d8a9c1f3d579027de636_cgraph.png" border="0" usemap="#anamespace_tiled_array_a02b064d85072d8a9c1f3d579027de636_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a02b064d85072d8a9c1f3d579027de636_cgraph" id="anamespace_tiled_array_a02b064d85072d8a9c1f3d579027de636_cgraph">
<area shape="rect" title="This function takes two input tiles and put result into the left tile." alt="" coords="5,5,151,47"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor." alt="" coords="199,5,356,47"/>
</map>
</div>

</div>
</div>
<a id="ac8e69c84228fd78ec135151a5747532c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e69c84228fd78ec135151a5747532c">&#9670;&nbsp;</a></span>foreach_inplace() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy , typename Op , typename  = typename std::enable_if&lt;!TiledArray::detail::is_array&lt;              typename std::decay&lt;Op&gt;::type&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt;Policy&gt;, void&gt; TiledArray::foreach_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fence</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify each tile of a dense Array. </p>
<p>This function modifies the tile data of <code>Array</code> object. Users must provide a function/functor that modifies the tile data. For example, if we want to modify the elements of the array to be equal to the square root of the original value: </p><div class="fragment"><div class="line"><span class="keywordflow">foreach</span>(array, [] (<a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::TensorD</a>&amp; tile) {</div>
<div class="line">  tile.<a class="code" href="class_tiled_array_1_1_tensor.html#af23df0d855cd33e6e977bd39e780ca9a">inplace_unary</a>([&amp;] (<span class="keywordtype">double</span>&amp; value) { value = std::sqrt(value); });</div>
<div class="line">});</div>
</div><!-- fragment --><p> The expected signature of the tile operation is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> op(Tile&amp; tile);</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a></td><td>The tile type of <code>arg</code> </td></tr>
    <tr><td class="paramname">Policy</td><td>The policy type of <code>arg</code>; <code>is_dense_v&lt;Policy&gt;</code> must be true </td></tr>
    <tr><td class="paramname">Op</td><td>Mutating tile operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The argument array to be modified </td></tr>
    <tr><td class="paramname">op</td><td>The mutating tile function </td></tr>
    <tr><td class="paramname">fence</td><td>A flag that indicates fencing behavior. If <code>true</code> this function will fence before data is modified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function fences by default to avoid data race conditions. Only disable the fence if you can ensure, the data is not being read by another thread. </dd>
<dd>
If there is a another copy of <code>arg</code> that was created via (or arg was created by) the <code>Array</code> copy constructor or copy assignment operator, this function will modify the data of that array since the data of a tile is held in a <code>std::shared_ptr</code>. If you need to ensure other copies of the data are not modified or this behavior causes problems in your application, use the <code><a class="el" href="namespace_tiled_array.html#a7945ee30f3a11a878035bb9e89dfe958" title="Apply a function to each tile of a dense Array.">TiledArray::foreach</a></code> function instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00476">476</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ac8e69c84228fd78ec135151a5747532c_cgraph.png" border="0" usemap="#anamespace_tiled_array_ac8e69c84228fd78ec135151a5747532c_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ac8e69c84228fd78ec135151a5747532c_cgraph" id="anamespace_tiled_array_ac8e69c84228fd78ec135151a5747532c_cgraph">
<area shape="rect" title="Modify each tile of a dense Array." alt="" coords="5,5,151,47"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor." alt="" coords="199,5,356,47"/>
</map>
</div>

</div>
</div>
<a id="a4365ce44bf73340cd20ab4c6baab47cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4365ce44bf73340cd20ab4c6baab47cf">&#9670;&nbsp;</a></span>foreach_inplace() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy , typename Op , typename  = typename std::enable_if&lt;!TiledArray::detail::is_array&lt;              typename std::decay&lt;Op&gt;::type&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt;Policy&gt;, void&gt; TiledArray::foreach_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fence</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify each tile of a sparse Array. </p>
<p>This function modifies the tile data of <code>Array</code> object. Users must provide a function/functor that modifies the tile data in place. For example, if we want to modify the elements of the array to be equal to the square root of the original value: </p><div class="fragment"><div class="line"><span class="keywordflow">foreach</span>(array, [] (<span class="keyword">auto</span>&amp; tile) -&gt; <span class="keywordtype">float</span> {</div>
<div class="line">  <span class="keywordtype">double</span> norm_squared = 0.0;</div>
<div class="line">  tile.<a class="code" href="class_tiled_array_1_1_tensor.html#af23df0d855cd33e6e977bd39e780ca9a">inplace_unary</a>([&amp;] (<span class="keywordtype">double</span>&amp; value) {</div>
<div class="line">    norm_squared += value; <span class="comment">// Assume value &gt;= 0</span></div>
<div class="line">    value = std::sqrt(value);</div>
<div class="line">  });</div>
<div class="line">  <span class="keywordflow">return</span> std::sqrt(norm_squared);</div>
<div class="line">});</div>
</div><!-- fragment --><p> The expected signature of the tile operation is: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> op(Tile&amp; tile);</div>
</div><!-- fragment --><p> where for the standard Policy (i.e. <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a>) the return value of <code>op</code> is the 2-norm (Frobenius norm) of the tile. </p><dl class="section note"><dt>Note</dt><dd>This function should not be used to initialize the tiles of an array object. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a></td><td>The tile type of <code>arg</code> </td></tr>
    <tr><td class="paramname">Policy</td><td>The policy type of <code>arg</code>; <code>is_dense_v&lt;Policy&gt;</code> must be false </td></tr>
    <tr><td class="paramname">Op</td><td><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The argument array to be modified </td></tr>
    <tr><td class="paramname">op</td><td>The mutating tile function </td></tr>
    <tr><td class="paramname">fence</td><td>A flag that indicates fencing behavior. If <code>true</code> this function will fence before data is modified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function fences by default to avoid data race conditions. Only disable the fence if you can ensure, the data is not being read by another thread. </dd>
<dd>
If there is a another copy of <code>arg</code> that was created via (or arg was created by) the <code>Array</code> copy constructor or copy assignment operator, this function will modify the data of that array since the data of a tile is held in a <code>std::shared_ptr</code>. If you need to ensure other copies of the data are not modified or this behavior causes problems in your application, use the <code><a class="el" href="namespace_tiled_array.html#a7945ee30f3a11a878035bb9e89dfe958" title="Apply a function to each tile of a dense Array.">TiledArray::foreach</a></code> function instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00584">584</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a4365ce44bf73340cd20ab4c6baab47cf_cgraph.png" border="0" usemap="#anamespace_tiled_array_a4365ce44bf73340cd20ab4c6baab47cf_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a4365ce44bf73340cd20ab4c6baab47cf_cgraph" id="anamespace_tiled_array_a4365ce44bf73340cd20ab4c6baab47cf_cgraph">
<area shape="rect" title="Modify each tile of a sparse Array." alt="" coords="5,5,151,47"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor." alt="" coords="199,5,356,47"/>
</map>
</div>

</div>
</div>
<a id="ac602cf7316f1296d1f59f76975f5cdfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac602cf7316f1296d1f59f76975f5cdfb">&#9670;&nbsp;</a></span>fuse_vector_of_arrays_tiles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">TA::DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy&gt; TiledArray::fuse_vector_of_arrays_tiles </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>global_world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_tiled_array_1_1_dist_array.html">TA::DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>array_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>fused_dim_extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>array_trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fuses a vector of <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> objects, each with the same <a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array.">TiledRange</a> into a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> with 1 more dimensions </p>
<p>The leading dimension of the resulting array is the vector dimension, and will be blocked by @block_size .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">global_world</td><td>the world in which the result will live and across which this is invoked. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">array_vec</td><td>a vector of <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> objects; every element of <code>arrays</code> must have the same <a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array.">TiledRange</a> object and live in the same world. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fused_dim_extent</td><td>the extent of the resulting (fused) mode; equals the total number of arrays in a fused <code>arrays</code> (sum of <code>arrays.size()</code> on each rank) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_size</td><td>the block size for the "vector" dimension of the tiled range of the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>arrays</code> fused into a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective function. It assumes that it is invoked across <code>global_world</code>, but the subarrays are "local" to each rank and distributed in tilewise-round-robin fashion. The result will live in <code>global_world</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_tiled_array_1_1detail.html#a716b4de519b8ce66cdf12b9e6578f30b" title="fuses the SparseShape objects of a tilewise-round-robin distributed vector of Arrays into single Spar...">detail::fuse_vector_of_shapes_tiles</a> TODO rename to fuse_tilewise_vector_of_arrays </dd></dl>
<p>copy the data from a sequence of tiles</p>
<p>write to blocks of fused_array</p>

<p class="definition">Definition at line <a class="el" href="vector__of__arrays_8h_source.html#l00289">289</a> of file <a class="el" href="vector__of__arrays_8h_source.html">vector_of_arrays.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ac602cf7316f1296d1f59f76975f5cdfb_cgraph.png" border="0" usemap="#anamespace_tiled_array_ac602cf7316f1296d1f59f76975f5cdfb_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ac602cf7316f1296d1f59f76975f5cdfb_cgraph" id="anamespace_tiled_array_ac602cf7316f1296d1f59f76975f5cdfb_cgraph">
<area shape="rect" title="fuses a vector of DistArray objects, each with the same TiledRange into a DistArray with 1 more dimen..." alt="" coords="5,491,177,533"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1dist__subarray__vec.html#a179f3b1aba92e11760bbaaa431d82410" title=" " alt="" coords="259,95,407,151"/>
<area shape="rect" href="class_tiled_array_1_1_tile.html#ae3505402edb0ddce41a6f04de6e82c59" title="Data direct access." alt="" coords="254,175,411,201"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ae240375dff3cdc73e249dfa9ee91c1b4" title="Range extent accessor." alt="" coords="260,226,405,267"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a716b4de519b8ce66cdf12b9e6578f30b" title="fuses the SparseShape objects of a tilewise&#45;round&#45;robin distributed vector of Arrays into single Spar..." alt="" coords="225,291,440,333"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="750,415,907,457"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a1980b233eaa1fc559b62cc8affc2bd34" title="Access the tile range." alt="" coords="505,357,674,398"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#ab824f8b38418197da56e2e52d611681c" title="Check for zero tiles." alt="" coords="511,590,668,631"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#ada724a31400bb94f55097560394438de" title="Factory function for tiles." alt="" coords="266,626,399,667"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a26ad3fc01bc940ec5be321058196d180" title="Process map accessor." alt="" coords="254,691,411,733"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a3f0780ab65ca5778bd4ee8f2783a082a" title="prepends an extra dimension to a TRange" alt="" coords="241,757,425,798"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a32ab8231e6a7ef385ac938d1f98c649e" title=" " alt="" coords="241,575,425,601"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_size_array.html#acca3c890ec0aeacf730d251a54105ac4" title=" " alt="" coords="266,822,399,863"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a63700b9c4ebc8c67f46325f77ed4cd2a" title="Range volume accessor." alt="" coords="260,887,405,929"/>
<area shape="rect" href="namespace_tiled_array.html#aea673bd36f494b9b4c040ea0e09c00bd" title=" " alt="" coords="260,473,405,500"/>
<area shape="rect" href="class_tiled_array_1_1_tile.html#a0736062c5f5f96f07bcff8a302b2c372" title=" " alt="" coords="505,5,674,32"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ad3a6a74a7146b195f299c49c843b6fa5" title="Range extent data accessor." alt="" coords="517,57,662,98"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a2208a1aeda0c14164e2689ee284aace2" title=" " alt="" coords="741,64,916,91"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range1.html#a804300d74a4872393801144e33ad9963" title="Returns an iterator to the first tile in the range." alt="" coords="501,174,678,215"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a9270d658412efce71cde14a4e9488664" title="Data direct access." alt="" coords="520,291,659,333"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a42bfd3b3ccab2835c75af773050444b7" title="Accessor of the tiled range for one of the dimensions." alt="" coords="488,123,691,149"/>
<area shape="rect" href="namespace_tiled_array.html#ae6e2da9f3855369c97e61e9105cce50a" title=" " alt="" coords="527,240,652,267"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#ac8c1d53822fd3da51824e4d97a11dd2a" title="The rank accessor." alt="" coords="744,115,913,157"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a2c5ad33baf5e6d3778e685929ca78504" title="Query for a zero tile." alt="" coords="751,545,906,586"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a9ab6d42af2997036d41180dfd5439544" title="Tile dimension boundary array accessor." alt="" coords="505,773,674,814"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_array_impl.html#a3205617f6c181fc8857407704007622c" title="Set tile." alt="" coords="523,655,656,697"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a1a16c42818cf3c0174187604ed457e79" title="Tiled range accessor." alt="" coords="753,757,904,798"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_distributed_storage.html#aa74a42e37342f0c2a80f623ac077266e" title="Set element i with value." alt="" coords="739,691,919,733"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_array_impl.html#a35765a0668e9e787ef688eb76f28a94e" title=" " alt="" coords="741,611,916,667"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a911b5f4183473c9c9300c370b90374df" title="Returns the number of tiles in the tensor." alt="" coords="511,525,668,566"/>
</map>
</div>

</div>
</div>
<a id="a8bb41dd83ecdc33052c9c02eeda152e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb41dd83ecdc33052c9c02eeda152e8">&#9670;&nbsp;</a></span>get_default_world()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">World&amp; TiledArray::get_default_world </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Accesses the default World. </p><dl class="section return"><dt>Returns</dt><dd>the current default World </dd></dl>

<p class="definition">Definition at line <a class="el" href="madness_8h_source.html#l00090">90</a> of file <a class="el" href="madness_8h_source.html">madness.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a8bb41dd83ecdc33052c9c02eeda152e8_cgraph.png" border="0" usemap="#anamespace_tiled_array_a8bb41dd83ecdc33052c9c02eeda152e8_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a8bb41dd83ecdc33052c9c02eeda152e8_cgraph" id="anamespace_tiled_array_a8bb41dd83ecdc33052c9c02eeda152e8_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,176,47"/>
<area shape="rect" href="struct_tiled_array_1_1detail_1_1default__world.html#af83d72c429e45b6b67859fac623d6af7" title=" " alt="" coords="224,5,372,47"/>
<area shape="rect" href="namespace_tiled_array.html#a52e6e0c952abcd7466a0efdcbf305681" title=" " alt="" coords="420,13,580,39"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a8bb41dd83ecdc33052c9c02eeda152e8_icgraph.png" border="0" usemap="#anamespace_tiled_array_a8bb41dd83ecdc33052c9c02eeda152e8_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a8bb41dd83ecdc33052c9c02eeda152e8_icgraph" id="anamespace_tiled_array_a8bb41dd83ecdc33052c9c02eeda152e8_icgraph">
<area shape="rect" title=" " alt="" coords="537,282,708,323"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_blk_tsr_expr_base.html#a4233158dc2d8f961fbe420397cdc715c" title=" " alt="" coords="229,5,489,61"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_expr.html#a7ee981b74753b06503d84a87f6118b96" title="Evaluate this object and assign it to tsr." alt="" coords="263,85,455,141"/>
<area shape="rect" href="namespace_tiled_array.html#a0f1265733604f5af60af78a9d7fa3ae4" title=" " alt="" coords="288,165,431,192"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_leaf_engine.html#a5d1422aed6e6267f7e5181c72f430890" title="Initialize the index list of this expression." alt="" coords="267,217,451,258"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_binary_engine.html#a64dfe59ebc2de023122bbdfaf6332c45" title="Initialize result tensor structure." alt="" coords="265,282,454,323"/>
<area shape="rect" href="namespace_tiled_array_1_1meta.html#ace9a963ccf9b32466d2b8e98a6e3f702" title=" " alt="" coords="269,348,450,375"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_expr_trace_target.html#ab9aaa499580ec90c3f61c902a1e7e60c" title="Start the expression trace." alt="" coords="250,399,469,441"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_expr.html#adf842b116f8e63fb855d5eadabb75d37" title=" " alt="" coords="263,465,455,521"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a688f0fd56017f86cec0a631a0b967706" title="deserialize local contents of a DistArray from an Archive object" alt="" coords="281,546,438,587"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_mult_engine.html#ac0edb2ca29c0404ede453de194a103af" title="Initialize result tensor structure." alt="" coords="5,246,181,287"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_scal_mult_engine.html#a0138742cea6f55a6f058a7fe4ee8ff57" title="Initialize result tensor structure." alt="" coords="6,312,181,368"/>
</map>
</div>

</div>
</div>
<a id="aa07853a9be617e5079dbc6768c6e72fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07853a9be617e5079dbc6768c6e72fc">&#9670;&nbsp;</a></span>get_elem_from_il()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::get_elem_from_il </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the specified element from an initializer_list. </p>
<p>Given an initializer_list with <img class="formulaInl" alt="$N$" src="form_51.png"/> nestings, <code>il</code>, and an <img class="formulaInl" alt="$N$" src="form_51.png"/> element index, <code>idx</code>, this function will return the element which is offset <code>idx[i]</code> along the <img class="formulaInl" alt="$i$" src="form_0.png"/>-th mode of <code>il</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the container holding the index. Assumed to be a random access container whose elements are of an integral type. </td></tr>
    <tr><td class="paramname">U</td><td>Assumed to be a scalar type (<em>e.g.</em> float, double, <em>etc.</em>) or a (possibly nested) <code>std::initializer_list</code> of scalar types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The desired element's offsets along each mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>The initializer list we are retrieving the value from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Used internally to keep track of how many levels of recursion have occurred. Defaults to 0 and should not be modified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested element.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>if the number of elements in <code>idx</code> does not equal the nesting of <code>il</code>. Strong throw guarantee. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>if the offset along a mode is greater than the length of the mode. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="initializer__list_8h_source.html#l00259">259</a> of file <a class="el" href="initializer__list_8h_source.html">initializer_list.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_aa07853a9be617e5079dbc6768c6e72fc_icgraph.png" border="0" usemap="#anamespace_tiled_array_aa07853a9be617e5079dbc6768c6e72fc_icgraph" alt=""/></div>
<map name="namespace_tiled_array_aa07853a9be617e5079dbc6768c6e72fc_icgraph" id="anamespace_tiled_array_aa07853a9be617e5079dbc6768c6e72fc_icgraph">
<area shape="rect" title="Retrieves the specified element from an initializer_list." alt="" coords="236,5,393,47"/>
<area shape="rect" href="namespace_tiled_array.html#a095de0b56a3abbd7dba7cd9d0085088e" title="Converts an std::initializer_list into a tiled array." alt="" coords="5,13,188,39"/>
</map>
</div>

</div>
</div>
<a id="ac03207b3ecd61bae1b8ad439f583dc2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03207b3ecd61bae1b8ad439f583dc2b">&#9670;&nbsp;</a></span>ignore_tile_position() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::ignore_tile_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reports whether tile positions are checked in binary array operations. These checks are disabled if preprocessor symbol <code>NDEBUG</code> is defined. By default, tile positions are checked. </p><dl class="section return"><dt>Returns</dt><dd>if true, tile positions will be ignored in binary array operations. </dd></dl>

<p class="definition">Definition at line <a class="el" href="utility_8h_source.html#l00090">90</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ac03207b3ecd61bae1b8ad439f583dc2b_cgraph.png" border="0" usemap="#anamespace_tiled_array_ac03207b3ecd61bae1b8ad439f583dc2b_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ac03207b3ecd61bae1b8ad439f583dc2b_cgraph" id="anamespace_tiled_array_ac03207b3ecd61bae1b8ad439f583dc2b_cgraph">
<area shape="rect" title=" " alt="" coords="5,13,143,54"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#aa8d036f88ab05ca2cbd5c2e10175d93c" title=" " alt="" coords="191,5,349,61"/>
</map>
</div>

</div>
</div>
<a id="ab0b271d3125f302d86bcfbfae903a907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b271d3125f302d86bcfbfae903a907">&#9670;&nbsp;</a></span>ignore_tile_position() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::ignore_tile_position </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Controls whether tile positions are checked in binary array operations. These checks are disabled if preprocessor symbol <code>NDEBUG</code> is defined. By default, tile positions are checked. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>if true, tile positions will be ignored in binary array operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>this function should be called following a fence from the main thread only. </dd></dl>

<p class="definition">Definition at line <a class="el" href="utility_8h_source.html#l00081">81</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ab0b271d3125f302d86bcfbfae903a907_cgraph.png" border="0" usemap="#anamespace_tiled_array_ab0b271d3125f302d86bcfbfae903a907_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ab0b271d3125f302d86bcfbfae903a907_cgraph" id="anamespace_tiled_array_ab0b271d3125f302d86bcfbfae903a907_cgraph">
<area shape="rect" title=" " alt="" coords="5,13,143,54"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#aa8d036f88ab05ca2cbd5c2e10175d93c" title=" " alt="" coords="191,5,349,61"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ab0b271d3125f302d86bcfbfae903a907_icgraph.png" border="0" usemap="#anamespace_tiled_array_ab0b271d3125f302d86bcfbfae903a907_icgraph" alt=""/></div>
<map name="namespace_tiled_array_ab0b271d3125f302d86bcfbfae903a907_icgraph" id="anamespace_tiled_array_ab0b271d3125f302d86bcfbfae903a907_icgraph">
<area shape="rect" title=" " alt="" coords="456,68,593,109"/>
<area shape="rect" href="namespacebtas.html#a48efb9fdd3f5acac9f55e9aabf683173" title=" " alt="" coords="271,46,371,73"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#ae91166d3998a0f1ea70bd76ea3a4fcab" title="Contract this tensor with other." alt="" coords="233,97,408,139"/>
<area shape="rect" href="class_tiled_array_1_1_sparse_shape.html#aa31679be37deccd633495b5901868d3b" title=" " alt="" coords="5,5,185,47"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#af12cb6d7375f20c89f8a42327efe2fa5" title="Contract two tensors and accumulate the scaled result to this tensor." alt="" coords="8,71,183,112"/>
</map>
</div>

</div>
</div>
<a id="a7aa78fc16b2d0cae8227821ab85d635a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa78fc16b2d0cae8227821ab85d635a">&#9670;&nbsp;</a></span>in_memory_space()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MemorySpace Space, typename T , typename HostAlloc , typename DeviceAlloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::in_memory_space </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1cpu__cuda__vector.html">cpu_cuda_vector</a>&lt; T, HostAlloc, DeviceAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cpu__cuda__vector_8h_source.html#l00162">162</a> of file <a class="el" href="cpu__cuda__vector_8h_source.html">cpu_cuda_vector.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a7aa78fc16b2d0cae8227821ab85d635a_cgraph.png" border="0" usemap="#anamespace_tiled_array_a7aa78fc16b2d0cae8227821ab85d635a_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a7aa78fc16b2d0cae8227821ab85d635a_cgraph" id="anamespace_tiled_array_a7aa78fc16b2d0cae8227821ab85d635a_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,176,47"/>
<area shape="rect" href="namespace_tiled_array.html#acd16fab45a79047fe90a8ba765185a1d" title=" " alt="" coords="224,13,369,39"/>
</map>
</div>

</div>
</div>
<a id="a42672835ea9434bc06ea421dea37d815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42672835ea9434bc06ea421dea37d815">&#9670;&nbsp;</a></span>initialize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">World&amp; TiledArray::initialize </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&amp;&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>quiet</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>if <a class="el" href="namespace_tiled_array.html">TiledArray</a> initialized MADWorld and <a class="el" href="namespace_tiled_array.html#a0f1265733604f5af60af78a9d7fa3ae4">TiledArray::finalize()</a> had been called </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="initialize_8h_source.html#l00038">38</a> of file <a class="el" href="initialize_8h_source.html">initialize.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a42672835ea9434bc06ea421dea37d815_cgraph.png" border="0" usemap="#anamespace_tiled_array_a42672835ea9434bc06ea421dea37d815_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a42672835ea9434bc06ea421dea37d815_cgraph" id="anamespace_tiled_array_a42672835ea9434bc06ea421dea37d815_cgraph">
<area shape="rect" title=" " alt="" coords="5,56,157,83"/>
<area shape="rect" href="namespace_tiled_array.html#a1890cfcad9af02c7bbe1022d0cb7faab" title=" " alt="" coords="205,56,357,83"/>
<area shape="rect" href="namespace_tiled_array.html#ab38811364e6ac3b5c0a5ac02ae19ddac" title=" " alt="" coords="415,5,565,32"/>
<area shape="rect" href="namespace_tiled_array.html#a52e6e0c952abcd7466a0efdcbf305681" title=" " alt="" coords="410,56,570,83"/>
<area shape="rect" href="namespace_tiled_array.html#a1553ba04e597fc346a2313ab175f37b4" title="Sets the default World to world ." alt="" coords="405,107,575,149"/>
<area shape="rect" href="struct_tiled_array_1_1detail_1_1default__world.html#a8b208921f20466d1e807709942581396" title=" " alt="" coords="623,107,769,149"/>
</map>
</div>

</div>
</div>
<a id="aa1b712918a811f515dd5b49ff2750062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b712918a811f515dd5b49ff2750062">&#9670;&nbsp;</a></span>initialize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">World&amp; TiledArray::initialize </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&amp;&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>quiet</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>if <a class="el" href="namespace_tiled_array.html">TiledArray</a> initialized MADWorld and <a class="el" href="namespace_tiled_array.html#a0f1265733604f5af60af78a9d7fa3ae4">TiledArray::finalize()</a> had been called </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="initialize_8h_source.html#l00042">42</a> of file <a class="el" href="initialize_8h_source.html">initialize.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_aa1b712918a811f515dd5b49ff2750062_cgraph.png" border="0" usemap="#anamespace_tiled_array_aa1b712918a811f515dd5b49ff2750062_cgraph" alt=""/></div>
<map name="namespace_tiled_array_aa1b712918a811f515dd5b49ff2750062_cgraph" id="anamespace_tiled_array_aa1b712918a811f515dd5b49ff2750062_cgraph">
<area shape="rect" title=" " alt="" coords="5,56,157,83"/>
<area shape="rect" href="namespace_tiled_array.html#a1890cfcad9af02c7bbe1022d0cb7faab" title=" " alt="" coords="205,56,357,83"/>
<area shape="rect" href="namespace_tiled_array.html#ab38811364e6ac3b5c0a5ac02ae19ddac" title=" " alt="" coords="415,5,565,32"/>
<area shape="rect" href="namespace_tiled_array.html#a52e6e0c952abcd7466a0efdcbf305681" title=" " alt="" coords="410,56,570,83"/>
<area shape="rect" href="namespace_tiled_array.html#a1553ba04e597fc346a2313ab175f37b4" title="Sets the default World to world ." alt="" coords="405,107,575,149"/>
<area shape="rect" href="struct_tiled_array_1_1detail_1_1default__world.html#a8b208921f20466d1e807709942581396" title=" " alt="" coords="623,107,769,149"/>
</map>
</div>

</div>
</div>
<a id="a1890cfcad9af02c7bbe1022d0cb7faab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1890cfcad9af02c7bbe1022d0cb7faab">&#9670;&nbsp;</a></span>initialize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TiledArray::World &amp; TiledArray::initialize </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&amp;&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SafeMPI::Intracomm &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>quiet</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>if <a class="el" href="namespace_tiled_array.html">TiledArray</a> initialized MADWorld and <a class="el" href="namespace_tiled_array.html#a0f1265733604f5af60af78a9d7fa3ae4">TiledArray::finalize()</a> had been called </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tiledarray_8cpp_source.html#l00080">80</a> of file <a class="el" href="tiledarray_8cpp_source.html">tiledarray.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a1890cfcad9af02c7bbe1022d0cb7faab_cgraph.png" border="0" usemap="#anamespace_tiled_array_a1890cfcad9af02c7bbe1022d0cb7faab_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a1890cfcad9af02c7bbe1022d0cb7faab_cgraph" id="anamespace_tiled_array_a1890cfcad9af02c7bbe1022d0cb7faab_cgraph">
<area shape="rect" title=" " alt="" coords="5,56,157,83"/>
<area shape="rect" href="namespace_tiled_array.html#ab38811364e6ac3b5c0a5ac02ae19ddac" title=" " alt="" coords="215,5,365,32"/>
<area shape="rect" href="namespace_tiled_array.html#a52e6e0c952abcd7466a0efdcbf305681" title=" " alt="" coords="210,56,370,83"/>
<area shape="rect" href="namespace_tiled_array.html#a1553ba04e597fc346a2313ab175f37b4" title="Sets the default World to world ." alt="" coords="205,107,375,149"/>
<area shape="rect" href="struct_tiled_array_1_1detail_1_1default__world.html#a8b208921f20466d1e807709942581396" title=" " alt="" coords="423,107,569,149"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a1890cfcad9af02c7bbe1022d0cb7faab_icgraph.png" border="0" usemap="#anamespace_tiled_array_a1890cfcad9af02c7bbe1022d0cb7faab_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a1890cfcad9af02c7bbe1022d0cb7faab_icgraph" id="anamespace_tiled_array_a1890cfcad9af02c7bbe1022d0cb7faab_icgraph">
<area shape="rect" title=" " alt="" coords="205,5,357,32"/>
<area shape="rect" href="namespace_tiled_array.html#a42672835ea9434bc06ea421dea37d815" title=" " alt="" coords="5,5,157,32"/>
</map>
</div>

</div>
</div>
<a id="a52e6e0c952abcd7466a0efdcbf305681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e6e0c952abcd7466a0efdcbf305681">&#9670;&nbsp;</a></span>initialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::initialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="namespace_tiled_array.html">TiledArray</a> (and, necessarily, MADWorld runtime) is in an initialized state </dd></dl>

<p class="definition">Definition at line <a class="el" href="tiledarray_8cpp_source.html#l00063">63</a> of file <a class="el" href="tiledarray_8cpp_source.html">tiledarray.cpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a52e6e0c952abcd7466a0efdcbf305681_icgraph.png" border="0" usemap="#anamespace_tiled_array_a52e6e0c952abcd7466a0efdcbf305681_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a52e6e0c952abcd7466a0efdcbf305681_icgraph" id="anamespace_tiled_array_a52e6e0c952abcd7466a0efdcbf305681_icgraph">
<area shape="rect" title=" " alt="" coords="956,319,1116,345"/>
<area shape="rect" href="struct_tiled_array_1_1detail_1_1default__world.html#af83d72c429e45b6b67859fac623d6af7" title=" " alt="" coords="758,282,906,323"/>
<area shape="rect" href="namespace_tiled_array.html#a1890cfcad9af02c7bbe1022d0cb7faab" title=" " alt="" coords="756,348,908,375"/>
<area shape="rect" href="namespace_tiled_array.html#a8bb41dd83ecdc33052c9c02eeda152e8" title=" " alt="" coords="537,282,708,323"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_blk_tsr_expr_base.html#a4233158dc2d8f961fbe420397cdc715c" title=" " alt="" coords="229,5,489,61"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_expr.html#a7ee981b74753b06503d84a87f6118b96" title="Evaluate this object and assign it to tsr." alt="" coords="263,85,455,141"/>
<area shape="rect" href="namespace_tiled_array.html#a0f1265733604f5af60af78a9d7fa3ae4" title=" " alt="" coords="288,165,431,192"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_leaf_engine.html#a5d1422aed6e6267f7e5181c72f430890" title="Initialize the index list of this expression." alt="" coords="267,217,451,258"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_binary_engine.html#a64dfe59ebc2de023122bbdfaf6332c45" title="Initialize result tensor structure." alt="" coords="265,282,454,323"/>
<area shape="rect" href="namespace_tiled_array_1_1meta.html#ace9a963ccf9b32466d2b8e98a6e3f702" title=" " alt="" coords="269,348,450,375"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_expr_trace_target.html#ab9aaa499580ec90c3f61c902a1e7e60c" title="Start the expression trace." alt="" coords="250,399,469,441"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_expr.html#adf842b116f8e63fb855d5eadabb75d37" title=" " alt="" coords="263,465,455,521"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a688f0fd56017f86cec0a631a0b967706" title="deserialize local contents of a DistArray from an Archive object" alt="" coords="281,546,438,587"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_mult_engine.html#ac0edb2ca29c0404ede453de194a103af" title="Initialize result tensor structure." alt="" coords="5,246,181,287"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_scal_mult_engine.html#a0138742cea6f55a6f058a7fe4ee8ff57" title="Initialize result tensor structure." alt="" coords="6,312,181,368"/>
<area shape="rect" href="namespace_tiled_array.html#a42672835ea9434bc06ea421dea37d815" title=" " alt="" coords="547,348,699,375"/>
</map>
</div>

</div>
</div>
<a id="a4e9cfa02e15bfbaaba9fa2e11d73d527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e9cfa02e15bfbaaba9fa2e11d73d527">&#9670;&nbsp;</a></span>inner() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::inner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_bipartite_permutation.html">BipartitePermutation</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="permutation_8h_source.html#l00829">829</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a4e9cfa02e15bfbaaba9fa2e11d73d527_cgraph.png" border="0" usemap="#anamespace_tiled_array_a4e9cfa02e15bfbaaba9fa2e11d73d527_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a4e9cfa02e15bfbaaba9fa2e11d73d527_cgraph" id="anamespace_tiled_array_a4e9cfa02e15bfbaaba9fa2e11d73d527_cgraph">
<area shape="rect" title=" " alt="" coords="5,13,135,39"/>
<area shape="rect" href="class_tiled_array_1_1_bipartite_permutation.html#ae1b3c045dda91632951977a99a22621e" title=" " alt="" coords="183,5,415,47"/>
</map>
</div>

</div>
</div>
<a id="a17ff448a634f3c75cf737cdcfdb667df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ff448a634f3c75cf737cdcfdb667df">&#9670;&nbsp;</a></span>inner() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::inner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="permutation_8h_source.html#l00813">813</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a17ff448a634f3c75cf737cdcfdb667df_icgraph.png" border="0" usemap="#anamespace_tiled_array_a17ff448a634f3c75cf737cdcfdb667df_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a17ff448a634f3c75cf737cdcfdb667df_icgraph" id="anamespace_tiled_array_a17ff448a634f3c75cf737cdcfdb667df_icgraph">
<area shape="rect" title=" " alt="" coords="247,143,376,170"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#affe584326250186e9764756598f7eefd" title="Use a binary, element wise operation to construct a new, permuted tensor." alt="" coords="13,5,191,47"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a414d53dd49a11ae4a6e67907a5daa521" title="Create a permuted copy of this tensor." alt="" coords="9,71,195,112"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aebc5c8b00cc397f5ba32ea426d1ddcc3" title=" " alt="" coords="5,136,199,177"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a97bb481eb9dc1357f2c8816fc456e3bf" title="Construct a permuted tensor copy." alt="" coords="15,201,189,243"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aab51b68f811fbe0fbb29909202ad3b30" title="Use a unary, element wise operation to construct a new, permuted tensor." alt="" coords="15,267,189,308"/>
</map>
</div>

</div>
</div>
<a id="a2108251710c269618bbdf6291f16a340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2108251710c269618bbdf6291f16a340">&#9670;&nbsp;</a></span>inner_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::inner_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dist__array_8h_source.html#l01647">1647</a> of file <a class="el" href="dist__array_8h_source.html">dist_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a2108251710c269618bbdf6291f16a340_cgraph.png" border="0" usemap="#anamespace_tiled_array_a2108251710c269618bbdf6291f16a340_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a2108251710c269618bbdf6291f16a340_cgraph" id="anamespace_tiled_array_a2108251710c269618bbdf6291f16a340_cgraph">
<area shape="rect" title=" " alt="" coords="5,42,191,69"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a05c44cde899d571534b6ff2e9d22ed75" title=" " alt="" coords="239,5,396,47"/>
<area shape="rect" href="namespace_tiled_array.html#ae6e2da9f3855369c97e61e9105cce50a" title=" " alt="" coords="255,71,380,98"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="444,64,601,105"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a2108251710c269618bbdf6291f16a340_icgraph.png" border="0" usemap="#anamespace_tiled_array_a2108251710c269618bbdf6291f16a340_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a2108251710c269618bbdf6291f16a340_icgraph" id="anamespace_tiled_array_a2108251710c269618bbdf6291f16a340_icgraph">
<area shape="rect" title=" " alt="" coords="732,111,917,137"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1linalg_1_1_d_i_i_s.html#a7785ec26d7d007cf4f4d1f0fddf303fe" title=" " alt="" coords="469,5,684,61"/>
<area shape="rect" href="struct_tiled_array_1_1math_1_1linalg_1_1_conjugate_gradient_solver.html#a76d41343afbc8d219dcaafb4ab32a64e" title=" " alt="" coords="5,41,199,97"/>
<area shape="rect" href="group___tile_interface.html#gac817534360dc7eb173c22113bc49522f" title="Vector inner product of a tile." alt="" coords="484,136,669,163"/>
<area shape="rect" href="class_tiled_array_1_1_inner_product_reduction.html#aeb0e3c839f596a9ad5cf626ba6fee0f0" title=" " alt="" coords="487,187,666,229"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1linalg_1_1_d_i_i_s.html#abf98aae362b3e309c5cfa170ae305ba2" title=" " alt="" coords="247,17,421,58"/>
</map>
</div>

</div>
</div>
<a id="a5762956a37a733db3ef580528de953c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5762956a37a733db3ef580528de953c4">&#9670;&nbsp;</a></span>inner_size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::inner_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_bipartite_permutation.html">BipartitePermutation</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="permutation_8h_source.html#l00833">833</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a5762956a37a733db3ef580528de953c4_cgraph.png" border="0" usemap="#anamespace_tiled_array_a5762956a37a733db3ef580528de953c4_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a5762956a37a733db3ef580528de953c4_cgraph" id="anamespace_tiled_array_a5762956a37a733db3ef580528de953c4_cgraph">
<area shape="rect" title=" " alt="" coords="5,13,168,39"/>
<area shape="rect" href="class_tiled_array_1_1_bipartite_permutation.html#a1c008d05b548c56f123a9c595d593303" title=" " alt="" coords="216,5,448,47"/>
</map>
</div>

</div>
</div>
<a id="a9cadfa975cfa7318b9a6e8a96fe6e038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cadfa975cfa7318b9a6e8a96fe6e038">&#9670;&nbsp;</a></span>inner_size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::inner_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="permutation_8h_source.html#l00822">822</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a9cadfa975cfa7318b9a6e8a96fe6e038_icgraph.png" border="0" usemap="#anamespace_tiled_array_a9cadfa975cfa7318b9a6e8a96fe6e038_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a9cadfa975cfa7318b9a6e8a96fe6e038_icgraph" id="anamespace_tiled_array_a9cadfa975cfa7318b9a6e8a96fe6e038_icgraph">
<area shape="rect" title=" " alt="" coords="280,235,443,262"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a83ef14e0a09d55fee40c40fbf5ac58b2" title="Use a binary, element wise operation to construct a new, permuted tensor." alt="" coords="32,5,205,47"/>
<area shape="rect" href="class_tiled_array_1_1tile__interface_1_1_permute.html#aeeeb5ea0a11df85dbad5b77b226d4ee4" title=" " alt="" coords="25,71,212,127"/>
<area shape="rect" href="class_tiled_array_1_1tile__interface_1_1_permute_3_01_result_00_01_arg_00_01typename_01std_1_1en7a77b7348979b0dc049d9f5c087f4759.html#a2bfaca68b8ca7207e07aa9b41c414fe2" title=" " alt="" coords="5,151,232,251"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a414d53dd49a11ae4a6e67907a5daa521" title="Create a permuted copy of this tensor." alt="" coords="25,275,212,316"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a97bb481eb9dc1357f2c8816fc456e3bf" title="Construct a permuted tensor copy." alt="" coords="31,340,206,381"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a1f907f15ed5a44df959cfccc950368ac" title="Use a unary, element wise operation to construct a new, permuted tensor." alt="" coords="34,405,203,447"/>
</map>
</div>

</div>
</div>
<a id="a4bf3ee231866723665a23c1669e4c754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf3ee231866723665a23c1669e4c754">&#9670;&nbsp;</a></span>invoke_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename Result  = typename TiledArray::eval_trait&lt;                            madness::remove_fcvr_t&lt;Arg&gt;&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::invoke_cast </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invokes <a class="el" href="class_tiled_array_1_1_cast.html" title="Tile cast operation.">TiledArray::Cast</a> to cast/convert the argument to type Result. The operation may be nonblocking, if needed. The cast may involve zero, one, or more conversions, depending on the implementation of Cast&lt;&gt;, and the properties of types Arg and Result. </p>

<p class="definition">Definition at line <a class="el" href="cast_8h_source.html#l00176">176</a> of file <a class="el" href="cast_8h_source.html">cast.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a4bf3ee231866723665a23c1669e4c754_cgraph.png" border="0" usemap="#anamespace_tiled_array_a4bf3ee231866723665a23c1669e4c754_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a4bf3ee231866723665a23c1669e4c754_cgraph" id="anamespace_tiled_array_a4bf3ee231866723665a23c1669e4c754_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,179,32"/>
<area shape="rect" href="namespace_tiled_array_1_1meta.html#a7e24a3a0114c0167e9023e781f5de64b" title=" " alt="" coords="227,5,408,32"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a4bf3ee231866723665a23c1669e4c754_icgraph.png" border="0" usemap="#anamespace_tiled_array_a4bf3ee231866723665a23c1669e4c754_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a4bf3ee231866723665a23c1669e4c754_icgraph" id="anamespace_tiled_array_a4bf3ee231866723665a23c1669e4c754_icgraph">
<area shape="rect" title=" " alt="" coords="253,78,427,105"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_unary_wrapper.html#a4ab57577339f9b945fc7a1d95bf78909" title="Consume a lazy tile." alt="" coords="10,5,201,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_unary_wrapper.html#aec85c9c535243c6a7abf1bad6fa53930" title="Evaluate a lazy tile." alt="" coords="7,71,204,112"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_binary_wrapper.html#afb1011caf19968139b97d806150370f5" title="Evaluate two lazy tiles." alt="" coords="5,136,205,177"/>
</map>
</div>

</div>
</div>
<a id="ad03979f84fd9f2823892518870a3c779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03979f84fd9f2823892518870a3c779">&#9670;&nbsp;</a></span>is_congruent() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::is_congruent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that two <a class="el" href="class_tiled_array_1_1_block_range.html" title="Range that references a subblock of another range.">BlockRange</a> objects are congruent. </p>
<p>This function tests that the rank, extent of <code>r1</code> is equal to that of <code>r2</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>The first <a class="el" href="class_tiled_array_1_1_block_range.html" title="Range that references a subblock of another range.">BlockRange</a> to compare </td></tr>
    <tr><td class="paramname">r2</td><td>The second <a class="el" href="class_tiled_array_1_1_block_range.html" title="Range that references a subblock of another range.">BlockRange</a> to compare </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="block__range_8h_source.html#l00400">400</a> of file <a class="el" href="block__range_8h_source.html">block_range.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ad03979f84fd9f2823892518870a3c779_icgraph.png" border="0" usemap="#anamespace_tiled_array_ad03979f84fd9f2823892518870a3c779_icgraph" alt=""/></div>
<map name="namespace_tiled_array_ad03979f84fd9f2823892518870a3c779_icgraph" id="anamespace_tiled_array_ad03979f84fd9f2823892518870a3c779_icgraph">
<area shape="rect" title="Test that two BlockRange objects are congruent." alt="" coords="232,56,411,83"/>
<area shape="rect" href="namespace_tiled_array.html#add57a0e7f0bc424ea564f06022ce91a3" title="Test if the two ranges are congruent." alt="" coords="14,5,175,32"/>
<area shape="rect" href="namespace_tiled_array.html#ad2e14ddddf19c527c4f5625446721622" title="Test that BlockRange and Range are congruent." alt="" coords="5,56,184,83"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a0b9a43dfee2749874d4677ea89ab4188" title="Test that the ranges of a pair of tensors are congruent." alt="" coords="16,107,173,149"/>
</map>
</div>

</div>
</div>
<a id="ad2e14ddddf19c527c4f5625446721622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e14ddddf19c527c4f5625446721622">&#9670;&nbsp;</a></span>is_congruent() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::is_congruent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that <a class="el" href="class_tiled_array_1_1_block_range.html" title="Range that references a subblock of another range.">BlockRange</a> and <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a> are congruent. </p>
<p>This function tests that the rank, extent of <code>r1</code> is equal to that of <code>r2</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>The <a class="el" href="class_tiled_array_1_1_block_range.html" title="Range that references a subblock of another range.">BlockRange</a> to compare </td></tr>
    <tr><td class="paramname">r2</td><td>The <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a> to compare </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="block__range_8h_source.html#l00412">412</a> of file <a class="el" href="block__range_8h_source.html">block_range.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ad2e14ddddf19c527c4f5625446721622_cgraph.png" border="0" usemap="#anamespace_tiled_array_ad2e14ddddf19c527c4f5625446721622_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ad2e14ddddf19c527c4f5625446721622_cgraph" id="anamespace_tiled_array_ad2e14ddddf19c527c4f5625446721622_cgraph">
<area shape="rect" title="Test that BlockRange and Range are congruent." alt="" coords="5,5,184,32"/>
<area shape="rect" href="namespace_tiled_array.html#ad03979f84fd9f2823892518870a3c779" title="Test that two BlockRange objects are congruent." alt="" coords="232,5,411,32"/>
</map>
</div>

</div>
</div>
<a id="aeabeb45688b0531ba26077d27b7bcef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeabeb45688b0531ba26077d27b7bcef6">&#9670;&nbsp;</a></span>is_congruent() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::is_congruent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a> and <a class="el" href="class_tiled_array_1_1_block_range.html" title="Range that references a subblock of another range.">BlockRange</a> are congruent. </p>
<p>This function tests that the rank, extent of <code>r1</code> is equal to that of <code>r2</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>The <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a> to compare </td></tr>
    <tr><td class="paramname">r2</td><td>The <a class="el" href="class_tiled_array_1_1_block_range.html" title="Range that references a subblock of another range.">BlockRange</a> to compare </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="block__range_8h_source.html#l00423">423</a> of file <a class="el" href="block__range_8h_source.html">block_range.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_aeabeb45688b0531ba26077d27b7bcef6_cgraph.png" border="0" usemap="#anamespace_tiled_array_aeabeb45688b0531ba26077d27b7bcef6_cgraph" alt=""/></div>
<map name="namespace_tiled_array_aeabeb45688b0531ba26077d27b7bcef6_cgraph" id="anamespace_tiled_array_aeabeb45688b0531ba26077d27b7bcef6_cgraph">
<area shape="rect" title="Test that Range and BlockRange are congruent." alt="" coords="5,5,184,32"/>
<area shape="rect" href="namespace_tiled_array.html#ad03979f84fd9f2823892518870a3c779" title="Test that two BlockRange objects are congruent." alt="" coords="232,5,411,32"/>
</map>
</div>

</div>
</div>
<a id="a2d7540b327326cb346b3348c695994db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7540b327326cb346b3348c695994db">&#9670;&nbsp;</a></span>is_congruent() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::is_congruent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test the two ranges are congruent. </p>
<p>This function tests that the rank and extent of <code>r1</code> are equal to those of <code>r2</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>The first <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a> to compare </td></tr>
    <tr><td class="paramname">r2</td><td>The second <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a> to compare </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="range_8h_source.html#l01301">1301</a> of file <a class="el" href="range_8h_source.html">range.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a2d7540b327326cb346b3348c695994db_cgraph.png" border="0" usemap="#anamespace_tiled_array_a2d7540b327326cb346b3348c695994db_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a2d7540b327326cb346b3348c695994db_cgraph" id="anamespace_tiled_array_a2d7540b327326cb346b3348c695994db_cgraph">
<area shape="rect" title="Test the two ranges are congruent." alt="" coords="5,42,184,69"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ad3a6a74a7146b195f299c49c843b6fa5" title="Range extent data accessor." alt="" coords="247,5,392,47"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a491195742ae543d2e53d2234bbd0b631" title="Rank accessor." alt="" coords="232,71,407,98"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a2208a1aeda0c14164e2689ee284aace2" title=" " alt="" coords="455,13,629,39"/>
</map>
</div>

</div>
</div>
<a id="a561b5e3eb2632a9fb93a06880c83f74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561b5e3eb2632a9fb93a06880c83f74c">&#9670;&nbsp;</a></span>is_congruent() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::is_congruent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that two <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> objects are congruent. </p>
<p>This function tests that the tile sizes of the two ranges coincide. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a></td><td>The range type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>an <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> object </td></tr>
    <tr><td class="paramname">r2</td><td>an <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> object </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tiled__range1_8h_source.html#l00362">362</a> of file <a class="el" href="tiled__range1_8h_source.html">tiled_range1.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a561b5e3eb2632a9fb93a06880c83f74c_cgraph.png" border="0" usemap="#anamespace_tiled_array_a561b5e3eb2632a9fb93a06880c83f74c_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a561b5e3eb2632a9fb93a06880c83f74c_cgraph" id="anamespace_tiled_array_a561b5e3eb2632a9fb93a06880c83f74c_cgraph">
<area shape="rect" title="Test that two TiledRange1 objects are congruent." alt="" coords="5,42,184,69"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range1.html#a804300d74a4872393801144e33ad9963" title="Returns an iterator to the first tile in the range." alt="" coords="248,5,425,47"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range1.html#a7325e80dbe95df50fbee3baa8669f54a" title="Returns an iterator to the end of the range." alt="" coords="232,71,441,98"/>
</map>
</div>

</div>
</div>
<a id="adf33eeb75439cdafef2d84e62d6e7fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf33eeb75439cdafef2d84e62d6e7fba">&#9670;&nbsp;</a></span>is_contiguous() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::is_contiguous </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tests whether a range is contiguous, i.e. whether its ordinal values form a contiguous range </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>a <a class="el" href="class_tiled_array_1_1_block_range.html" title="Range that references a subblock of another range.">BlockRange</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true since <a class="el" href="class_tiled_array_1_1_block_range.html" title="Range that references a subblock of another range.">TiledArray::BlockRange</a> is contiguous by definition </dd></dl>

<p class="definition">Definition at line <a class="el" href="block__range_8h_source.html#l00443">443</a> of file <a class="el" href="block__range_8h_source.html">block_range.h</a>.</p>

</div>
</div>
<a id="aec6721abfa16c73293afcaf6e4451601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6721abfa16c73293afcaf6e4451601">&#9670;&nbsp;</a></span>is_contiguous() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::is_contiguous </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tests whether a range is contiguous, i.e. whether its ordinal values form a contiguous range </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>a <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true since <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">TiledArray::Range</a> is contiguous by definition </dd></dl>

<p class="definition">Definition at line <a class="el" href="range_8h_source.html#l01312">1312</a> of file <a class="el" href="range_8h_source.html">range.h</a>.</p>

</div>
</div>
<a id="a9a805e13069e3aa1ea4c09910c1bb1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a805e13069e3aa1ea4c09910c1bb1bf">&#9670;&nbsp;</a></span>is_replicated() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool TiledArray::is_replicated </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dense_shape.html">DenseShape</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dense__shape_8h_source.html#l00386">386</a> of file <a class="el" href="dense__shape_8h_source.html">dense_shape.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a9a805e13069e3aa1ea4c09910c1bb1bf_icgraph.png" border="0" usemap="#anamespace_tiled_array_a9a805e13069e3aa1ea4c09910c1bb1bf_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a9a805e13069e3aa1ea4c09910c1bb1bf_icgraph" id="anamespace_tiled_array_a9a805e13069e3aa1ea4c09910c1bb1bf_icgraph">
<area shape="rect" title=" " alt="" coords="1256,275,1435,302"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#ab6d6a8154d95e480234a02493bf618cc" title=" " alt="" coords="1039,235,1197,276"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#ab0aa44b396071f6da395954263bd233f" title="Constructor." alt="" coords="1028,300,1208,341"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg_1_1detail.html#a94db369e97ef287f9107427256c715d4" title=" " alt="" coords="805,235,980,276"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg_1_1non__distributed.html#ab6b2484d01f802539ec4eea55b4c9b44" title="Compute the Cholesky factorization of a HPD rank&#45;2 tensor." alt="" coords="540,5,736,47"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg_1_1non__distributed.html#a7ec45055eb979e6039b8d4652ef4b90f" title=" " alt="" coords="228,332,471,373"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg_1_1non__distributed.html#af2304bac4099bc46326b27d67052033a" title=" " alt="" coords="519,71,757,112"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg_1_1non__distributed.html#a8f7f4852273a4f7de7ef13895efc910f" title="Solve the standard eigenvalue problem with LAPACK." alt="" coords="551,136,725,177"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg_1_1non__distributed.html#a863afa905daf50b3e0147933520f6294" title="Invert a matrix via LU." alt="" coords="549,201,727,243"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg_1_1non__distributed.html#a2bb0de5144ab3c4ed84dbbc8c32f3082" title="Solve a linear system via LU factorization." alt="" coords="541,267,735,308"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg_1_1non__distributed.html#ae993de79e1e40701e9cd441a70a0a06f" title=" " alt="" coords="551,383,725,439"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg_1_1non__distributed.html#a2911a1fc73b5129d3ea27a74cb7a9a24" title="Compute the singular value decomposition (SVD) via ScaLAPACK." alt="" coords="551,464,725,505"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg.html#a6ee83ee2082f3287a5d0d13c0009717f" title=" " alt="" coords="5,332,180,373"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg.html#a4f66f85a44e6de95414ad3a9a439b370" title=" " alt="" coords="262,71,437,112"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg.html#a4dab8a36df73ce6826bbde2d90fcae32" title=" " alt="" coords="262,136,437,177"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg.html#a84d29616e3b53dac86550f06d6138238" title=" " alt="" coords="262,201,437,243"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg.html#a93a99f1af595afdc1f3d6f5826d95fd4" title=" " alt="" coords="262,267,437,308"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg_1_1non__distributed.html#a26c97daa8adcaac3aea41c2406281efc" title="Compute the Cholesky factorization of a HPD rank&#45;2 tensor." alt="" coords="251,463,447,504"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg_1_1non__distributed.html#a84fe33125833e1851862dfec9d474349" title="Compute the inverse of the Cholesky factor of an HPD rank&#45;2 tensor. Optionally return the Cholesky fa..." alt="" coords="236,397,463,439"/>
</map>
</div>

</div>
</div>
<a id="a55a3b9976b8eacacfa0517e6bdc7c44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a3b9976b8eacacfa0517e6bdc7c44d">&#9670;&nbsp;</a></span>is_replicated() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::is_replicated </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_sparse_shape.html">SparseShape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>collective bitwise-compare-reduce for <a class="el" href="class_tiled_array_1_1_sparse_shape.html" title="Frobenius-norm-based sparse shape.">SparseShape</a> objects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">world</td><td>the World object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>the <a class="el" href="class_tiled_array_1_1_sparse_shape.html" title="Frobenius-norm-based sparse shape.">SparseShape</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>shape</code> is bitwise identical across <code>world</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>must be invoked on every rank of World </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__shape_8h_source.html#l01622">1622</a> of file <a class="el" href="sparse__shape_8h_source.html">sparse_shape.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a55a3b9976b8eacacfa0517e6bdc7c44d_cgraph.png" border="0" usemap="#anamespace_tiled_array_a55a3b9976b8eacacfa0517e6bdc7c44d_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a55a3b9976b8eacacfa0517e6bdc7c44d_cgraph" id="anamespace_tiled_array_a55a3b9976b8eacacfa0517e6bdc7c44d_cgraph">
<area shape="rect" title="collective bitwise&#45;compare&#45;reduce for SparseShape objects" alt="" coords="5,111,184,138"/>
<area shape="rect" href="class_tiled_array_1_1_sparse_shape.html#adb1bfeb045c67d93118696bb61db67f7" title="Data accessor." alt="" coords="232,5,412,47"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a9270d658412efce71cde14a4e9488664" title="Data direct access." alt="" coords="253,71,391,112"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#ab27ca10b5f528a0625e1eacd76106880" title="Tensor dimension size accessor." alt="" coords="253,136,391,177"/>
<area shape="rect" href="namespace_tiled_array.html#aea673bd36f494b9b4c040ea0e09c00bd" title=" " alt="" coords="249,202,395,229"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a911b5f4183473c9c9300c370b90374df" title="Returns the number of tiles in the tensor." alt="" coords="460,161,617,203"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="460,227,617,268"/>
</map>
</div>

</div>
</div>
<a id="afeb19e7ec84d171ded4638b990d3387b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb19e7ec84d171ded4638b990d3387b">&#9670;&nbsp;</a></span>launch_gdb_xterm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::launch_gdb_xterm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use this to launch GNU debugger in xterm. </p>

<p class="definition">Definition at line <a class="el" href="bug_8cpp_source.html#l00357">357</a> of file <a class="el" href="bug_8cpp_source.html">bug.cpp</a>.</p>

</div>
</div>
<a id="ab99d473ae1db21c29a59983dcb29d8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99d473ae1db21c29a59983dcb29d8bc">&#9670;&nbsp;</a></span>launch_lldb_xterm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::launch_lldb_xterm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use this to launch LLVM debugger in xterm. </p>

<p class="definition">Definition at line <a class="el" href="bug_8cpp_source.html#l00362">362</a> of file <a class="el" href="bug_8cpp_source.html">bug.cpp</a>.</p>

</div>
</div>
<a id="a7cd3d9c18d8f36108c03e6ef9429144f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd3d9c18d8f36108c03e6ef9429144f">&#9670;&nbsp;</a></span>make_array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array , typename Op , typename std::enable_if&lt; is_dense&lt; Array &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> TiledArray::make_array </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_tiled_array_1_1detail.html#a06e12c23ae1ad65ad65ef54b041abb37">detail::trange_t</a>&lt; <a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="namespace_tiled_array_1_1detail.html#a11981ec4cf6f0e145fe51fa42c93ec10">detail::pmap_t</a>&lt; <a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>pmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct dense Array. </p>
<p>Construct sparse Array.</p>
<p>This function is used to construct a <code><a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a></code> object. Users must provide a world object, tiled range object, and function/functor that generates the tiles for the new array object. For example, if we want to create an array with were the elements are equal to <code>1</code>: </p><div class="fragment"><div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::TArray&lt;double&gt;</a> out_array =</div>
<div class="line">    make_array&lt;TiledArray::TArray&lt;double&gt; &gt;(world, trange, pmap,</div>
<div class="line">          [=] (<a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>&amp; tile, <span class="keyword">const</span> <a class="code" href="class_tiled_array_1_1_range.html">TiledArray::Range</a>&amp;</div>
<div class="line">          range) {</div>
<div class="line">            tile = <a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>(range);</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; it : tile)</div>
<div class="line">              *it = 1;</div>
<div class="line">          });</div>
</div><!-- fragment --><p> Note that the result is default constructed before (contains no data) and must be initialized inside the function/functor with the provided range object. The expected signature of the tile operation is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> op(tile_t&amp; tile, <span class="keyword">const</span> range_t&amp; range);</div>
</div><!-- fragment --><p> where <code>tile_t</code> and <code>range_t</code> are your tile type and tile range type, respectively. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Array</td><td>The <code><a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a></code> type </td></tr>
    <tr><td class="paramname">Op</td><td><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>The world where the array will live </td></tr>
    <tr><td class="paramname">trange</td><td>The tiled range of the array </td></tr>
    <tr><td class="paramname">op</td><td>The tile function/functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array object of type <code>Array</code></dd></dl>
<p>This function is used to construct a <code><a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a></code> object. Users must provide a world object, tiled range object, process map, and function/ functor that generates the tiles for the new array object. For example, if we want to create an array with all elements equal to <code>1</code>: </p><div class="fragment"><div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::TSpArray&lt;double&gt;</a> array =</div>
<div class="line">    make_array&lt;TiledArray::TSpArray&lt;double&gt; &gt;(world, trange, pmap,</div>
<div class="line">          [=] (<a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>&amp; tile, <span class="keyword">const</span> <a class="code" href="class_tiled_array_1_1_range.html">TiledArray::Range</a>&amp;</div>
<div class="line">          range) -&gt; <span class="keywordtype">double</span> {</div>
<div class="line">            tile = <a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>(range);</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; it : tile)</div>
<div class="line">              *it = 1;</div>
<div class="line">            <span class="keywordflow">return</span> tile.norm();</div>
<div class="line">          });</div>
</div><!-- fragment --><p> You may choose not to initialize a tile inside the tile initialization function (not shown in the example) by returning <code>0</code> for the tile norm. Note that the result is default constructed before (contains no data) and must be initialized inside the function/functor with the provided range object unless the returned tile norm is zero. The expected signature of the tile operation is: </p><div class="fragment"><div class="line"><a class="code" href="namespace_tiled_array_1_1detail.html#a8a4894269f42087aba45c572ad95aae0">value_t</a> op(tile_t&amp; tile, <span class="keyword">const</span> range_t&amp; range);</div>
</div><!-- fragment --><p> where <code>value_t</code>, <code>tile_t</code> and <code>range_t</code> are your tile value type, tile type, and tile range type, respectively. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Array</td><td>The <code><a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a></code> type </td></tr>
    <tr><td class="paramname">Op</td><td><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>The world where the array will live </td></tr>
    <tr><td class="paramname">trange</td><td>The tiled range of the array </td></tr>
    <tr><td class="paramname">pmap</td><td>A shared pointer to the array process map </td></tr>
    <tr><td class="paramname">op</td><td>The tile function/functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array object of type <code>Array</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="make__array_8h_source.html#l00073">73</a> of file <a class="el" href="make__array_8h_source.html">make_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a7cd3d9c18d8f36108c03e6ef9429144f_cgraph.png" border="0" usemap="#anamespace_tiled_array_a7cd3d9c18d8f36108c03e6ef9429144f_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a7cd3d9c18d8f36108c03e6ef9429144f_cgraph" id="anamespace_tiled_array_a7cd3d9c18d8f36108c03e6ef9429144f_cgraph">
<area shape="rect" title="Construct dense Array." alt="" coords="5,158,179,185"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a26ad3fc01bc940ec5be321058196d180" title="Process map accessor." alt="" coords="240,121,397,163"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a32ab8231e6a7ef385ac938d1f98c649e" title=" " alt="" coords="227,187,411,214"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_array_impl.html#a3205617f6c181fc8857407704007622c" title="Set tile." alt="" coords="459,144,592,185"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a1a16c42818cf3c0174187604ed457e79" title="Tiled range accessor." alt="" coords="655,217,805,259"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a2c5ad33baf5e6d3778e685929ca78504" title="Query for a zero tile." alt="" coords="653,5,807,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_distributed_storage.html#aa74a42e37342f0c2a80f623ac077266e" title="Set element i with value." alt="" coords="640,71,820,112"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_array_impl.html#a35765a0668e9e787ef688eb76f28a94e" title=" " alt="" coords="643,137,817,193"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a7cd3d9c18d8f36108c03e6ef9429144f_icgraph.png" border="0" usemap="#anamespace_tiled_array_a7cd3d9c18d8f36108c03e6ef9429144f_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a7cd3d9c18d8f36108c03e6ef9429144f_icgraph" id="anamespace_tiled_array_a7cd3d9c18d8f36108c03e6ef9429144f_icgraph">
<area shape="rect" title="Construct dense Array." alt="" coords="228,13,401,39"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg_1_1non__distributed.html#a2911a1fc73b5129d3ea27a74cb7a9a24" title="Compute the singular value decomposition (SVD) via ScaLAPACK." alt="" coords="5,5,180,47"/>
</map>
</div>

</div>
</div>
<a id="ad73ea2d1e2e1b222f741f94a3f949e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73ea2d1e2e1b222f741f94a3f949e1c">&#9670;&nbsp;</a></span>make_array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> TiledArray::make_array </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_tiled_array_1_1detail.html#a06e12c23ae1ad65ad65ef54b041abb37">detail::trange_t</a>&lt; <a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an Array. </p>
<p>This function is used to construct a <code><a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a></code> object. Users must provide a world object, tiled range object, and function/functor that generates the tiles for the new array object. For example, if we want to create an array with were the elements are equal to <code>1</code>: </p><div class="fragment"><div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::TSpArray&lt;double&gt;</a> array =</div>
<div class="line">    make_array&lt;TiledArray::TSpArray&lt;double&gt; &gt;(world, trange,</div>
<div class="line">          [=] (<a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>&amp; tile, <span class="keyword">const</span> <a class="code" href="class_tiled_array_1_1_range.html">TiledArray::Range</a>&amp;</div>
<div class="line">          range) -&gt; <span class="keywordtype">double</span> {</div>
<div class="line">            tile = <a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>(range);</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; it : tile)</div>
<div class="line">              *it = 1;</div>
<div class="line">            <span class="keywordflow">return</span> tile.norm();</div>
<div class="line">          });</div>
</div><!-- fragment --><p> For sparse arrays, you may choose not to initialize a tile inside the tile initialization (not shown in the example) by returning <code>0</code> for the tile norm. Note that the result is default constructed before (contains no data) and must be initialized inside the function/functor with the provided range object unless the returned tile norm is zero. The expected signature of the tile operation is: </p><div class="fragment"><div class="line"><a class="code" href="namespace_tiled_array_1_1detail.html#a8a4894269f42087aba45c572ad95aae0">value_t</a> op(tile_t&amp; tile, <span class="keyword">const</span> range_t&amp; range);</div>
</div><!-- fragment --><p> where <code>value_t</code>, <code>tile_t</code> and <code>range_t</code> are your tile value type, tile type, and tile range type, respectively. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Array</td><td>The <code><a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a></code> type </td></tr>
    <tr><td class="paramname">Op</td><td><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>The world where the array will live </td></tr>
    <tr><td class="paramname">trange</td><td>The tiled range of the array </td></tr>
    <tr><td class="paramname">op</td><td>The tile function/functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array object of type <code>Array</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="make__array_8h_source.html#l00222">222</a> of file <a class="el" href="make__array_8h_source.html">make_array.h</a>.</p>

</div>
</div>
<a id="a4fc8675b642f53bdab884e5a6c473103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc8675b642f53bdab884e5a6c473103">&#9670;&nbsp;</a></span>make_const_map() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_  = Range, typename OpResult  = Tensor&lt;T&gt;, typename Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a362559c766dfbca887fc6dff5523fb3b">TensorConstMap</a>&lt;T, Range_, OpResult&gt; TiledArray::make_const_map </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00098">98</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a4fc8675b642f53bdab884e5a6c473103_icgraph.png" border="0" usemap="#anamespace_tiled_array_a4fc8675b642f53bdab884e5a6c473103_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a4fc8675b642f53bdab884e5a6c473103_icgraph" id="anamespace_tiled_array_a4fc8675b642f53bdab884e5a6c473103_icgraph">
<area shape="rect" title=" " alt="" coords="484,61,695,88"/>
<area shape="rect" href="namespace_tiled_array.html#ace7fbc10ae58bc49609c93b31fa7d4e1" title="Copy a block of a btas::Tensor into a TiledArray::Tensor." alt="" coords="241,17,436,58"/>
<area shape="rect" href="namespace_tiled_array.html#ad8cb3eac6d5a72fae3c98b4d78f5b77a" title="Copy a block of a btas::Tensor into a TiledArray::Tensor." alt="" coords="265,86,413,127"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#aead432075c6c7f2e9f7c329c96bc4d4a" title=" " alt="" coords="5,5,193,61"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#aae305e910ce674d71f550e104c354cb5" title="Task function for assigning a tensor to an Eigen submatrix." alt="" coords="24,85,175,141"/>
</map>
</div>

</div>
</div>
<a id="a04aee79763cf537e55a3a4805978860e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04aee79763cf537e55a3a4805978860e">&#9670;&nbsp;</a></span>make_const_map() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_  = Range, typename OpResult  = Tensor&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a362559c766dfbca887fc6dff5523fb3b">TensorConstMap</a>&lt;T, Range_, OpResult&gt; TiledArray::make_const_map </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00105">105</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a id="a6e1dbc423a60cd4dc28b579d248408fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1dbc423a60cd4dc28b579d248408fb">&#9670;&nbsp;</a></span>make_const_map() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_ , typename OpResult  = Tensor&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a362559c766dfbca887fc6dff5523fb3b">TensorConstMap</a>&lt;T, std::decay_t&lt;Range_&gt;, OpResult&gt; TiledArray::make_const_map </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Range_ &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00113">113</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a id="a61c3e42482ba47e674bb8b56e0e9428d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c3e42482ba47e674bb8b56e0e9428d">&#9670;&nbsp;</a></span>make_const_map() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_ , typename OpResult  = Tensor&lt;T&gt;, typename Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a362559c766dfbca887fc6dff5523fb3b">TensorConstMap</a>&lt;T, Range_, OpResult&gt; TiledArray::make_const_map </td>
          <td>(</td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00121">121</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a id="aef4a56fbb5e457904a047ba0ebbceb7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4a56fbb5e457904a047ba0ebbceb7e">&#9670;&nbsp;</a></span>make_const_map() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_ , typename OpResult  = Tensor&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a362559c766dfbca887fc6dff5523fb3b">TensorConstMap</a>&lt;T, Range_, OpResult&gt; TiledArray::make_const_map </td>
          <td>(</td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00128">128</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a id="ae7fe8e8790e1238ab0e7f47ef78a7d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7fe8e8790e1238ab0e7f47ef78a7d2c">&#9670;&nbsp;</a></span>make_const_map() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_ , typename OpResult  = Tensor&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a362559c766dfbca887fc6dff5523fb3b">TensorConstMap</a>&lt;T, std::decay_t&lt;Range_&gt;, OpResult&gt; TiledArray::make_const_map </td>
          <td>(</td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Range_ &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00136">136</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a id="ab318ad5c5c3986ad9886c8c6fd6301f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab318ad5c5c3986ad9886c8c6fd6301f7">&#9670;&nbsp;</a></span>make_device_storage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::make_device_storage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1cpu__cuda__vector.html">cpu_cuda_vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cpu__cuda__vector_8h_source.html#l00187">187</a> of file <a class="el" href="cpu__cuda__vector_8h_source.html">cpu_cuda_vector.h</a>.</p>

</div>
</div>
<a id="a69bfbeb46b2175bef60689e6c813d2c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69bfbeb46b2175bef60689e6c813d2c3">&#9670;&nbsp;</a></span>make_map() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_  = Range, typename OpResult  = Tensor&lt;T&gt;, typename Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a362559c766dfbca887fc6dff5523fb3b">TensorConstMap</a>&lt;T, Range_, OpResult&gt; TiledArray::make_map </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00074">74</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a id="a894dfdb7e721f1e7f50ac49555412636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894dfdb7e721f1e7f50ac49555412636">&#9670;&nbsp;</a></span>make_map() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_  = Range, typename OpResult  = Tensor&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a362559c766dfbca887fc6dff5523fb3b">TensorConstMap</a>&lt;T, Range_, OpResult&gt; TiledArray::make_map </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00082">82</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a id="aa1be30c56b5b6bf89be779ab1103d23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1be30c56b5b6bf89be779ab1103d23c">&#9670;&nbsp;</a></span>make_map() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_ , typename OpResult  = Tensor&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a362559c766dfbca887fc6dff5523fb3b">TensorConstMap</a>&lt;T, std::decay_t&lt;Range_&gt;, OpResult&gt; TiledArray::make_map </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Range_ &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00090">90</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a id="a676ce2ab1b89d4f820aba886f9ce12a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676ce2ab1b89d4f820aba886f9ce12a7">&#9670;&nbsp;</a></span>make_map() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_  = Range, typename OpResult  = Tensor&lt;T&gt;, typename Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#acf8bdb4a9d561d001f7a34f49c077a5c">TensorMap</a>&lt;T, Range_, OpResult&gt; TiledArray::make_map </td>
          <td>(</td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00053">53</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a676ce2ab1b89d4f820aba886f9ce12a7_icgraph.png" border="0" usemap="#anamespace_tiled_array_a676ce2ab1b89d4f820aba886f9ce12a7_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a676ce2ab1b89d4f820aba886f9ce12a7_icgraph" id="anamespace_tiled_array_a676ce2ab1b89d4f820aba886f9ce12a7_icgraph">
<area shape="rect" title=" " alt="" coords="509,123,677,149"/>
<area shape="rect" href="namespace_tiled_array.html#ace7fbc10ae58bc49609c93b31fa7d4e1" title="Copy a block of a btas::Tensor into a TiledArray::Tensor." alt="" coords="254,13,449,54"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#ae91166d3998a0f1ea70bd76ea3a4fcab" title="Contract this tensor with other." alt="" coords="264,78,439,119"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1linalg_1_1scalapack_1_1_block_cyclic_matrix.html#a79bdccd08fb030e045bf01fd764f5912" title=" " alt="" coords="241,144,461,200"/>
<area shape="rect" href="namespace_tiled_array.html#ad8cb3eac6d5a72fae3c98b4d78f5b77a" title="Copy a block of a btas::Tensor into a TiledArray::Tensor." alt="" coords="277,225,425,266"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#aead432075c6c7f2e9f7c329c96bc4d4a" title=" " alt="" coords="5,5,193,61"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#aae305e910ce674d71f550e104c354cb5" title="Task function for assigning a tensor to an Eigen submatrix." alt="" coords="24,217,175,273"/>
</map>
</div>

</div>
</div>
<a id="a3ae62f2e2cc4456fa20849bfa583edd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae62f2e2cc4456fa20849bfa583edd8">&#9670;&nbsp;</a></span>make_map() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_  = Range, typename OpResult  = Tensor&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#acf8bdb4a9d561d001f7a34f49c077a5c">TensorMap</a>&lt;T, Range_, OpResult&gt; TiledArray::make_map </td>
          <td>(</td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00060">60</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a id="a46ca6f02c32be6cf9e395e79b6d15521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ca6f02c32be6cf9e395e79b6d15521">&#9670;&nbsp;</a></span>make_map() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_ , typename OpResult  = Tensor&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#acf8bdb4a9d561d001f7a34f49c077a5c">TensorMap</a>&lt;T, std::decay_t&lt;Range_&gt;, OpResult&gt; TiledArray::make_map </td>
          <td>(</td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Range_ &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00067">67</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a id="aa44cdecfe02b2ca9f8134aed6c94f39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44cdecfe02b2ca9f8134aed6c94f39c">&#9670;&nbsp;</a></span>make_op_shared_handle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::make_op_shared_handle </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wraps Op into a shallow-copy copyable handle if Op is an rvalue ref makes an owning handle otherwise makes an non-owning handle </p>

<p class="definition">Definition at line <a class="el" href="function_8h_source.html#l00129">129</a> of file <a class="el" href="function_8h_source.html">function.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_aa44cdecfe02b2ca9f8134aed6c94f39c_icgraph.png" border="0" usemap="#anamespace_tiled_array_aa44cdecfe02b2ca9f8134aed6c94f39c_icgraph" alt=""/></div>
<map name="namespace_tiled_array_aa44cdecfe02b2ca9f8134aed6c94f39c_icgraph" id="anamespace_tiled_array_aa44cdecfe02b2ca9f8134aed6c94f39c_icgraph">
<area shape="rect" title=" " alt="" coords="621,64,776,105"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a9ad764271dc2e35268ab009b2dbdb140" title="base implementation of dense TiledArray::foreach" alt="" coords="428,5,561,47"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a415c792db252572ee66bf3dc6e8827e6" title="Initialize elements of local, non&#45;zero tiles with a user provided functor." alt="" coords="211,60,368,101"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a740c01f878f645a3ab53274c912e0b72" title="Initialize (local) tiles with a user provided functor." alt="" coords="416,125,573,167"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a6b595f4d2779d8e232a305d774afe3cc" title=" " alt="" coords="5,60,163,101"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a3ae16a62d1f3a7f64f67a80b6ccad8bb" title="Fill all local tiles with the specified value." alt="" coords="211,125,368,167"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a8c268a352be16fc597e6ad2c7d6a7560" title="Writes tiles of a nonconstant diagonal array." alt="" coords="213,191,366,247"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a808571423d2d6d551e9844f0b38369a8" title="Writes tiles of a constant diagonal array." alt="" coords="213,271,366,327"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#aae66e276e71df6dc2472bbd3026062ac" title="Fill all local tiles with the specified value." alt="" coords="5,125,163,167"/>
<area shape="rect" href="namespace_tiled_array.html#a8d2668989011ee62fa6314733cfc4a32" title="Creates a constant diagonal DistArray." alt="" coords="8,279,160,320"/>
</map>
</div>

</div>
</div>
<a id="a5ec660a9421bf4776cd585846131a8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec660a9421bf4776cd585846131a8b3">&#9670;&nbsp;</a></span>make_shared_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1shared__function.html">shared_function</a>&lt;std::decay_t&lt;F&gt; &gt; TiledArray::make_shared_function </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="function_8h_source.html#l00039">39</a> of file <a class="el" href="function_8h_source.html">function.h</a>.</p>

</div>
</div>
<a id="a0f71d75add02ed829ddc72f0a5e19e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f71d75add02ed829ddc72f0a5e19e83">&#9670;&nbsp;</a></span>max_reduce_cuda_kernel_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T TiledArray::max_reduce_cuda_kernel_impl </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="reduce__kernel__impl_8h_source.html#l00080">80</a> of file <a class="el" href="reduce__kernel__impl_8h_source.html">reduce_kernel_impl.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a0f71d75add02ed829ddc72f0a5e19e83_cgraph.png" border="0" usemap="#anamespace_tiled_array_a0f71d75add02ed829ddc72f0a5e19e83_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a0f71d75add02ed829ddc72f0a5e19e83_cgraph" id="anamespace_tiled_array_a0f71d75add02ed829ddc72f0a5e19e83_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,181,47"/>
<area shape="rect" href="namespace_tiled_array.html#a3bc356474566d00f7de7b22b0ce8b108" title="T = reduce(T* arg)" alt="" coords="229,5,372,47"/>
</map>
</div>

</div>
</div>
<a id="ae1deaffe62f8c644f5e3dc2e21789771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1deaffe62f8c644f5e3dc2e21789771">&#9670;&nbsp;</a></span>min_reduce_cuda_kernel_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T TiledArray::min_reduce_cuda_kernel_impl </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="reduce__kernel__impl_8h_source.html#l00088">88</a> of file <a class="el" href="reduce__kernel__impl_8h_source.html">reduce_kernel_impl.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ae1deaffe62f8c644f5e3dc2e21789771_cgraph.png" border="0" usemap="#anamespace_tiled_array_ae1deaffe62f8c644f5e3dc2e21789771_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ae1deaffe62f8c644f5e3dc2e21789771_cgraph" id="anamespace_tiled_array_ae1deaffe62f8c644f5e3dc2e21789771_cgraph">
<area shape="rect" title=" " alt="" coords="5,27,177,69"/>
<area shape="rect" href="kronecker__delta_8h.html#a08a5e38335a5bd02f089294968dfc391" title=" " alt="" coords="271,5,322,32"/>
<area shape="rect" href="namespace_tiled_array.html#a3bc356474566d00f7de7b22b0ce8b108" title="T = reduce(T* arg)" alt="" coords="225,57,368,98"/>
</map>
</div>

</div>
</div>
<a id="a3d1996e1acc93771802b143a34c44208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1996e1acc93771802b143a34c44208">&#9670;&nbsp;</a></span>mult_cuda_kernel_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::mult_cuda_kernel_impl </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>result[i] = arg1[i] * arg2[i] </p>

<p class="definition">Definition at line <a class="el" href="mult__kernel__impl_8h_source.html#l00048">48</a> of file <a class="el" href="mult__kernel__impl_8h_source.html">mult_kernel_impl.h</a>.</p>

</div>
</div>
<a id="aa970ec287c852074d963f780cf149824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa970ec287c852074d963f780cf149824">&#9670;&nbsp;</a></span>mult_to_cuda_kernel_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::mult_to_cuda_kernel_impl </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>result[i] = result[i] * arg[i] </p>

<p class="definition">Definition at line <a class="el" href="mult__kernel__impl_8h_source.html#l00035">35</a> of file <a class="el" href="mult__kernel__impl_8h_source.html">mult_kernel_impl.h</a>.</p>

</div>
</div>
<a id="a736de0045a7f48b5df63e3137260e40b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736de0045a7f48b5df63e3137260e40b">&#9670;&nbsp;</a></span>norm2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::norm2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dist__array_8h_source.html#l01660">1660</a> of file <a class="el" href="dist__array_8h_source.html">dist_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a736de0045a7f48b5df63e3137260e40b_cgraph.png" border="0" usemap="#anamespace_tiled_array_a736de0045a7f48b5df63e3137260e40b_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a736de0045a7f48b5df63e3137260e40b_cgraph" id="anamespace_tiled_array_a736de0045a7f48b5df63e3137260e40b_cgraph">
<area shape="rect" title=" " alt="" coords="5,42,144,69"/>
<area shape="rect" href="namespace_tiled_array.html#a2208f3d88d7e5293d2fc6b1fc01768fd" title=" " alt="" coords="192,42,381,69"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a05c44cde899d571534b6ff2e9d22ed75" title=" " alt="" coords="429,5,587,47"/>
<area shape="rect" href="namespace_tiled_array.html#ae6e2da9f3855369c97e61e9105cce50a" title=" " alt="" coords="445,71,571,98"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="635,64,792,105"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a736de0045a7f48b5df63e3137260e40b_icgraph.png" border="0" usemap="#anamespace_tiled_array_a736de0045a7f48b5df63e3137260e40b_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a736de0045a7f48b5df63e3137260e40b_icgraph" id="anamespace_tiled_array_a736de0045a7f48b5df63e3137260e40b_icgraph">
<area shape="rect" title=" " alt="" coords="247,20,385,47"/>
<area shape="rect" href="struct_tiled_array_1_1math_1_1linalg_1_1_conjugate_gradient_solver.html#a76d41343afbc8d219dcaafb4ab32a64e" title=" " alt="" coords="5,5,199,61"/>
</map>
</div>

</div>
</div>
<a id="a28ed2ff1e65aebae0733ebc4b73e17bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ed2ff1e65aebae0733ebc4b73e17bf">&#9670;&nbsp;</a></span>now()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a073741f90126d4c17df3404a58f13fd4">time_point</a> TiledArray::now </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="time_8h_source.html#l00035">35</a> of file <a class="el" href="time_8h_source.html">time.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a28ed2ff1e65aebae0733ebc4b73e17bf_icgraph.png" border="0" usemap="#anamespace_tiled_array_a28ed2ff1e65aebae0733ebc4b73e17bf_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a28ed2ff1e65aebae0733ebc4b73e17bf_icgraph" id="anamespace_tiled_array_a28ed2ff1e65aebae0733ebc4b73e17bf_icgraph">
<area shape="rect" title=" " alt="" coords="232,5,355,32"/>
<area shape="rect" href="namespace_tiled_array.html#a982f4ff04f86f6ea1bd32d0f8046d479" title=" " alt="" coords="5,5,184,32"/>
</map>
</div>

</div>
</div>
<a id="a00b32d073bbd4bff28bbbe63b3016c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b32d073bbd4bff28bbbe63b3016c5e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_bipartite_permutation.html">BipartitePermutation</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_bipartite_permutation.html">BipartitePermutation</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_permutation.html" title="Permutation of a sequence of objects indexed by base-0 indices.">Permutation</a> inequality operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>The left-hand permutation to be compared </td></tr>
    <tr><td class="paramname">p2</td><td>The right-hand permutation to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if all elements of <code>p1</code> and <code>p2</code> are equal and the partition sizes match, otherwise <code>true</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="permutation_8h_source.html#l00806">806</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>

</div>
</div>
<a id="ab8a725f292ae8f27a3d142e19bedca1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a725f292ae8f27a3d142e19bedca1e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool TiledArray::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dense_shape.html">DenseShape</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dense_shape.html">DenseShape</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dense__shape_8h_source.html#l00382">382</a> of file <a class="el" href="dense__shape_8h_source.html">dense_shape.h</a>.</p>

</div>
</div>
<a id="abc410382ebb92ab3373034a9b54a9a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc410382ebb92ab3373034a9b54a9a78">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a> inequality comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>The first range to be compared </td></tr>
    <tr><td class="paramname">r2</td><td>The second range to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> when <code>r1</code> does not represent the same range as <code>r2</code>, otherwise <code>false</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="range_8h_source.html#l01275">1275</a> of file <a class="el" href="range_8h_source.html">range.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_abc410382ebb92ab3373034a9b54a9a78_cgraph.png" border="0" usemap="#anamespace_tiled_array_abc410382ebb92ab3373034a9b54a9a78_cgraph" alt=""/></div>
<map name="namespace_tiled_array_abc410382ebb92ab3373034a9b54a9a78_cgraph" id="anamespace_tiled_array_abc410382ebb92ab3373034a9b54a9a78_cgraph">
<area shape="rect" title="Range inequality comparison." alt="" coords="5,42,172,69"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ac1fe1f599524763265207c84e909dd15" title="Range lower bound data accessor." alt="" coords="235,5,380,47"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a491195742ae543d2e53d2234bbd0b631" title="Rank accessor." alt="" coords="220,71,395,98"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a2208a1aeda0c14164e2689ee284aace2" title=" " alt="" coords="443,13,617,39"/>
</map>
</div>

</div>
</div>
<a id="a3316fbfa5aa7fe5314bf54670d198bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3316fbfa5aa7fe5314bf54670d198bee">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l02168">2168</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="abc317c0fc817305f509add105ee3cd44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc317c0fc817305f509add105ee3cd44">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> inequality comparison. </p>

<p class="definition">Definition at line <a class="el" href="tile_8h_source.html#l01650">1650</a> of file <a class="el" href="tile_8h_source.html">tile.h</a>.</p>

</div>
</div>
<a id="a4282e9e655ef9479b267ac1975d77eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4282e9e655ef9479b267ac1975d77eb6">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiled__range_8h_source.html#l00344">344</a> of file <a class="el" href="tiled__range_8h_source.html">tiled_range.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a4282e9e655ef9479b267ac1975d77eb6_cgraph.png" border="0" usemap="#anamespace_tiled_array_a4282e9e655ef9479b267ac1975d77eb6_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a4282e9e655ef9479b267ac1975d77eb6_cgraph" id="anamespace_tiled_array_a4282e9e655ef9479b267ac1975d77eb6_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,172,32"/>
<area shape="rect" href="namespace_tiled_array.html#a3442799c758651ce6586418d2cf09b24" title="BlockRange equality comparison." alt="" coords="220,5,393,32"/>
</map>
</div>

</div>
</div>
<a id="a49a6fdebe3f7dff3beb2637c2c48809f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a6fdebe3f7dff3beb2637c2c48809f">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator. </p>

<p class="definition">Definition at line <a class="el" href="tiled__range1_8h_source.html#l00318">318</a> of file <a class="el" href="tiled__range1_8h_source.html">tiled_range1.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a49a6fdebe3f7dff3beb2637c2c48809f_cgraph.png" border="0" usemap="#anamespace_tiled_array_a49a6fdebe3f7dff3beb2637c2c48809f_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a49a6fdebe3f7dff3beb2637c2c48809f_cgraph" id="anamespace_tiled_array_a49a6fdebe3f7dff3beb2637c2c48809f_cgraph">
<area shape="rect" title="Inequality operator." alt="" coords="5,5,172,32"/>
<area shape="rect" href="namespace_tiled_array.html#a3442799c758651ce6586418d2cf09b24" title="BlockRange equality comparison." alt="" coords="220,5,393,32"/>
</map>
</div>

</div>
</div>
<a id="a050b0409972cf113c9f70e26fa9cc181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050b0409972cf113c9f70e26fa9cc181">&#9670;&nbsp;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespace_tiled_array.html#a075713b9b2f21c1f7a54361922ff9d13">MemorySpace</a> TiledArray::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array.html#a075713b9b2f21c1f7a54361922ff9d13">MemorySpace</a>&#160;</td>
          <td class="paramname"><em>space1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array.html#a075713b9b2f21c1f7a54361922ff9d13">MemorySpace</a>&#160;</td>
          <td class="paramname"><em>space2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>intersection of <code>space1</code> and <code>space2</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="platform_8h_source.html#l00043">43</a> of file <a class="el" href="platform_8h_source.html">platform.h</a>.</p>

</div>
</div>
<a id="a2b1fa4c93060bc503429e3527f2993ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1fa4c93060bc503429e3527f2993ad">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array.">TiledRange</a> permutation operator. </p>
<p>This function will permute the range. Note: only tiles that are not being used by other objects will be permuted. The owner of those objects are </p>

<p class="definition">Definition at line <a class="el" href="tiled__range_8h_source.html#l00326">326</a> of file <a class="el" href="tiled__range_8h_source.html">tiled_range.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a2b1fa4c93060bc503429e3527f2993ad_cgraph.png" border="0" usemap="#anamespace_tiled_array_a2b1fa4c93060bc503429e3527f2993ad_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a2b1fa4c93060bc503429e3527f2993ad_cgraph" id="anamespace_tiled_array_a2b1fa4c93060bc503429e3527f2993ad_cgraph">
<area shape="rect" title="TiledRange permutation operator." alt="" coords="5,101,164,127"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a9ab6d42af2997036d41180dfd5439544" title="Tile dimension boundary array accessor." alt="" coords="215,5,385,47"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a491195742ae543d2e53d2234bbd0b631" title="Rank accessor." alt="" coords="213,71,387,98"/>
<area shape="rect" href="class_tiled_array_1_1_permutation.html#aacb3f970f21779e9a6c2024790dc7270" title="Domain size accessor." alt="" coords="212,123,388,164"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a1980b233eaa1fc559b62cc8affc2bd34" title="Access the tile range." alt="" coords="215,188,385,229"/>
</map>
</div>

</div>
</div>
<a id="a5a142539c899a3ad3c1b357dfd27933a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a142539c899a3ad3c1b357dfd27933a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::container::small_vector&lt;T, N&gt; TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::container::small_vector&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>permute a <code>boost::container::small_vector&lt;T&gt;</code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the vector </td></tr>
    <tr><td class="paramname">N</td><td>The max static size of the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation </td></tr>
    <tr><td class="paramname">v</td><td>The vector to be permuted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A permuted copy of <code>v</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the dimension of the permutation is not equal to the size of <code>v</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="permutation_8h_source.html#l00563">563</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a5a142539c899a3ad3c1b357dfd27933a_cgraph.png" border="0" usemap="#anamespace_tiled_array_a5a142539c899a3ad3c1b357dfd27933a_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a5a142539c899a3ad3c1b357dfd27933a_cgraph" id="anamespace_tiled_array_a5a142539c899a3ad3c1b357dfd27933a_cgraph">
<area shape="rect" title="permute a boost::container::small_vector&lt;T&gt;" alt="" coords="5,46,164,73"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a2cd1e7c394cfe8c14fe1419e4320b97d" title="Create a permuted copy of an array." alt="" coords="233,5,367,47"/>
<area shape="rect" href="class_tiled_array_1_1_permutation.html#aacb3f970f21779e9a6c2024790dc7270" title="Domain size accessor." alt="" coords="212,71,388,112"/>
</map>
</div>

</div>
</div>
<a id="a678f80db611a7af38027953b96bc8f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678f80db611a7af38027953b96bc8f0d">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_range.html">Range</a> TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a permuted range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation to be applied to the range </td></tr>
    <tr><td class="paramname">r</td><td>The range to be permuted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A permuted copy of <code>r</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="range_8h_source.html#l01242">1242</a> of file <a class="el" href="range_8h_source.html">range.h</a>.</p>

</div>
</div>
<a id="a586be997af3bd421583c8fd36c4e95f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586be997af3bd421583c8fd36c4e95f2">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, N &gt; TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_permute.html" title="Permute a tile.">Permute</a> a <code>std::array</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the array </td></tr>
    <tr><td class="paramname">N</td><td>The size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation </td></tr>
    <tr><td class="paramname">a</td><td>The array to be permuted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A permuted copy of <code>a</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the dimension of the permutation is not equal to the size of <code>a</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="permutation_8h_source.html#l00492">492</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a586be997af3bd421583c8fd36c4e95f2_cgraph.png" border="0" usemap="#anamespace_tiled_array_a586be997af3bd421583c8fd36c4e95f2_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a586be997af3bd421583c8fd36c4e95f2_cgraph" id="anamespace_tiled_array_a586be997af3bd421583c8fd36c4e95f2_cgraph">
<area shape="rect" title="Permute a std::array." alt="" coords="5,46,164,73"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a2cd1e7c394cfe8c14fe1419e4320b97d" title="Create a permuted copy of an array." alt="" coords="233,5,367,47"/>
<area shape="rect" href="class_tiled_array_1_1_permutation.html#aacb3f970f21779e9a6c2024790dc7270" title="Domain size accessor." alt="" coords="212,71,388,112"/>
</map>
</div>

</div>
</div>
<a id="a3db915cc9b57726c63e876d1260c50dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db915cc9b57726c63e876d1260c50dc">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>permute a <code>std::vector&lt;T&gt;</code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the vector </td></tr>
    <tr><td class="paramname">A</td><td>The allocator type of the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation </td></tr>
    <tr><td class="paramname">v</td><td>The vector to be permuted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A permuted copy of <code>v</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the dimension of the permutation is not equal to the size of <code>v</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="permutation_8h_source.html#l00528">528</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a3db915cc9b57726c63e876d1260c50dc_cgraph.png" border="0" usemap="#anamespace_tiled_array_a3db915cc9b57726c63e876d1260c50dc_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a3db915cc9b57726c63e876d1260c50dc_cgraph" id="anamespace_tiled_array_a3db915cc9b57726c63e876d1260c50dc_cgraph">
<area shape="rect" title="permute a std::vector&lt;T&gt;" alt="" coords="5,46,164,73"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a2cd1e7c394cfe8c14fe1419e4320b97d" title="Create a permuted copy of an array." alt="" coords="233,5,367,47"/>
<area shape="rect" href="class_tiled_array_1_1_permutation.html#aacb3f970f21779e9a6c2024790dc7270" title="Domain size accessor." alt="" coords="212,71,388,112"/>
</map>
</div>

</div>
</div>
<a id="a5b58b8591b03eebae61c177036697562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b58b8591b03eebae61c177036697562">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a permuted copy of <code>arg</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The argument tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation to be applied to <code>arg</code> </td></tr>
    <tr><td class="paramname">arg</td><td>The argument tensor to be permuted </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00135">135</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a5b58b8591b03eebae61c177036697562_cgraph.png" border="0" usemap="#anamespace_tiled_array_a5b58b8591b03eebae61c177036697562_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a5b58b8591b03eebae61c177036697562_cgraph" id="anamespace_tiled_array_a5b58b8591b03eebae61c177036697562_cgraph">
<area shape="rect" title="Create a permuted copy of arg." alt="" coords="5,5,164,32"/>
<area shape="rect" href="namespace_tiled_array.html#a1bd2736a88698132f314b8a6e34aec67" title=" " alt="" coords="212,5,363,32"/>
</map>
</div>

</div>
</div>
<a id="a35cf85d544ef5cea5a232dc86766d80c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35cf85d544ef5cea5a232dc86766d80c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *MADNESS_RESTRICT const&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_permute.html" title="Permute a tile.">Permute</a> a memory buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the memory buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation </td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to the memory buffer to be permuted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A permuted copy of the memory buffer as a <code>std::vector</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="permutation_8h_source.html#l00595">595</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a35cf85d544ef5cea5a232dc86766d80c_cgraph.png" border="0" usemap="#anamespace_tiled_array_a35cf85d544ef5cea5a232dc86766d80c_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a35cf85d544ef5cea5a232dc86766d80c_cgraph" id="anamespace_tiled_array_a35cf85d544ef5cea5a232dc86766d80c_cgraph">
<area shape="rect" title="Permute a memory buffer." alt="" coords="5,13,164,39"/>
<area shape="rect" href="class_tiled_array_1_1_permutation.html#aacb3f970f21779e9a6c2024790dc7270" title="Domain size accessor." alt="" coords="212,5,388,47"/>
</map>
</div>

</div>
</div>
<a id="a93accba5edcc96b461552d4a9483ec3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93accba5edcc96b461552d4a9483ec3d">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N , typename std::enable_if&lt;(detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value) &amp;&amp;detail::is_numeric_v&lt; N &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of <code>left</code> that is scaled by <code>right</code>. </p>
<p><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile.">Scale</a> a tensor </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">N</td><td>Numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand scalar argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> is equal to <code> left[i] * right </code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00095">95</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a93accba5edcc96b461552d4a9483ec3d_cgraph.png" border="0" usemap="#anamespace_tiled_array_a93accba5edcc96b461552d4a9483ec3d_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a93accba5edcc96b461552d4a9483ec3d_cgraph" id="anamespace_tiled_array_a93accba5edcc96b461552d4a9483ec3d_cgraph">
<area shape="rect" title="Create a copy of left that is scaled by right." alt="" coords="5,13,164,39"/>
<area shape="rect" href="group___tile_interface.html#gaebe37fcda193946fcc4501b42796e9cc" title="Scalar the tile argument." alt="" coords="212,13,343,39"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#ada724a31400bb94f55097560394438de" title="Factory function for tiles." alt="" coords="391,5,524,47"/>
</map>
</div>

</div>
</div>
<a id="a2b7b0326fbc5daaf9df0298d58e7df49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7b0326fbc5daaf9df0298d58e7df49">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt; detail::is_tensor&lt; T1, T2 &gt;::value||detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> multiplication operator. </p>
<p>Element-wise multiplication of two tensors </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> is equal to <code>left[i] * right[i]</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00079">79</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a2b7b0326fbc5daaf9df0298d58e7df49_cgraph.png" border="0" usemap="#anamespace_tiled_array_a2b7b0326fbc5daaf9df0298d58e7df49_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a2b7b0326fbc5daaf9df0298d58e7df49_cgraph" id="anamespace_tiled_array_a2b7b0326fbc5daaf9df0298d58e7df49_cgraph">
<area shape="rect" title="Tensor multiplication operator." alt="" coords="5,13,164,39"/>
<area shape="rect" href="group___tile_interface.html#gaf465d9c7b7f7d31918a6150c9d51ca40" title="Multiplication tile arguments." alt="" coords="212,13,339,39"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#ada724a31400bb94f55097560394438de" title="Factory function for tiles." alt="" coords="387,5,520,47"/>
</map>
</div>

</div>
</div>
<a id="ae22953e4bba13494766ec2fc06ea1744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22953e4bba13494766ec2fc06ea1744">&#9670;&nbsp;</a></span>operator*() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename N , typename T , typename std::enable_if&lt; detail::is_numeric_v&lt; N &gt; &amp;&amp;(detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value)&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of <code>right</code> that is scaled by <code>left</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>A numeric type </td></tr>
    <tr><td class="paramname">T</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand scalar argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> is equal to <code> left * right[i] </code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00111">111</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ae22953e4bba13494766ec2fc06ea1744_cgraph.png" border="0" usemap="#anamespace_tiled_array_ae22953e4bba13494766ec2fc06ea1744_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ae22953e4bba13494766ec2fc06ea1744_cgraph" id="anamespace_tiled_array_ae22953e4bba13494766ec2fc06ea1744_cgraph">
<area shape="rect" title="Create a copy of right that is scaled by left." alt="" coords="5,13,164,39"/>
<area shape="rect" href="group___tile_interface.html#gaebe37fcda193946fcc4501b42796e9cc" title="Scalar the tile argument." alt="" coords="212,13,343,39"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#ada724a31400bb94f55097560394438de" title="Factory function for tiles." alt="" coords="391,5,524,47"/>
</map>
</div>

</div>
</div>
<a id="aa01f9a5a93602269365aefabd0794805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01f9a5a93602269365aefabd0794805">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::container::small_vector&lt;T, N&gt;&amp; TiledArray::operator*= </td>
          <td>(</td>
          <td class="paramtype">boost::container::small_vector&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place permute a <code>boost::container::small_vector</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the vector </td></tr>
    <tr><td class="paramname">N</td><td>The max static size of the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>The vector to be permuted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>v</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the dimension of the permutation is not equal to the size of <code>v</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="permutation_8h_source.html#l00581">581</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_aa01f9a5a93602269365aefabd0794805_cgraph.png" border="0" usemap="#anamespace_tiled_array_aa01f9a5a93602269365aefabd0794805_cgraph" alt=""/></div>
<map name="namespace_tiled_array_aa01f9a5a93602269365aefabd0794805_cgraph" id="anamespace_tiled_array_aa01f9a5a93602269365aefabd0794805_cgraph">
<area shape="rect" title="In&#45;place permute a boost::container::small_vector." alt="" coords="5,13,175,39"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a2cd1e7c394cfe8c14fe1419e4320b97d" title="Create a permuted copy of an array." alt="" coords="223,5,356,47"/>
</map>
</div>

</div>
</div>
<a id="ae84ce21d711a462da4a1b44a811a5a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84ce21d711a462da4a1b44a811a5a94">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, N &gt; &amp; TiledArray::operator*= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place permute a <code>std::array</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the array </td></tr>
    <tr><td class="paramname">N</td><td>The size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a</td><td>The array to be permuted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>a</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the dimension of the permutation is not equal to the size of <code>a</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="permutation_8h_source.html#l00510">510</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ae84ce21d711a462da4a1b44a811a5a94_cgraph.png" border="0" usemap="#anamespace_tiled_array_ae84ce21d711a462da4a1b44a811a5a94_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ae84ce21d711a462da4a1b44a811a5a94_cgraph" id="anamespace_tiled_array_ae84ce21d711a462da4a1b44a811a5a94_cgraph">
<area shape="rect" title="In&#45;place permute a std::array." alt="" coords="5,46,175,73"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a2cd1e7c394cfe8c14fe1419e4320b97d" title="Create a permuted copy of an array." alt="" coords="244,5,377,47"/>
<area shape="rect" href="class_tiled_array_1_1_permutation.html#aacb3f970f21779e9a6c2024790dc7270" title="Domain size accessor." alt="" coords="223,71,399,112"/>
</map>
</div>

</div>
</div>
<a id="a4beab363e9a6e97343bc39965e548f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4beab363e9a6e97343bc39965e548f95">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T, A &gt; &amp; TiledArray::operator*= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place permute a <code>std::vector</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the vector </td></tr>
    <tr><td class="paramname">A</td><td>The allocator type of the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>The vector to be permuted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>v</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the dimension of the permutation is not equal to the size of <code>v</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="permutation_8h_source.html#l00546">546</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a4beab363e9a6e97343bc39965e548f95_cgraph.png" border="0" usemap="#anamespace_tiled_array_a4beab363e9a6e97343bc39965e548f95_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a4beab363e9a6e97343bc39965e548f95_cgraph" id="anamespace_tiled_array_a4beab363e9a6e97343bc39965e548f95_cgraph">
<area shape="rect" title="In&#45;place permute a std::vector." alt="" coords="5,13,175,39"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a2cd1e7c394cfe8c14fe1419e4320b97d" title="Create a permuted copy of an array." alt="" coords="223,5,356,47"/>
</map>
</div>

</div>
</div>
<a id="a1493d57cb2d466240eeaef8e173cf6b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1493d57cb2d466240eeaef8e173cf6b2">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N , typename std::enable_if&lt;(detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value) &amp;&amp;detail::is_numeric_v&lt; N &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator*= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In place tensor scale. </p>
<p><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile.">Scale</a> the elements of <code>left</code> by <code>right</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">N</td><td>Numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand scalar argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>left</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00231">231</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a1493d57cb2d466240eeaef8e173cf6b2_cgraph.png" border="0" usemap="#anamespace_tiled_array_a1493d57cb2d466240eeaef8e173cf6b2_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a1493d57cb2d466240eeaef8e173cf6b2_cgraph" id="anamespace_tiled_array_a1493d57cb2d466240eeaef8e173cf6b2_cgraph">
<area shape="rect" title="In place tensor scale." alt="" coords="5,5,175,32"/>
<area shape="rect" href="group___tile_interface.html#ga381f8c925fdcfdee5cfef07f66c4da25" title="Scale to the result tile." alt="" coords="223,5,373,32"/>
<area shape="rect" href="class_tiled_array_1_1_tile.html#a0736062c5f5f96f07bcff8a302b2c372" title=" " alt="" coords="421,5,591,32"/>
</map>
</div>

</div>
</div>
<a id="aaf25c7dbd596cf41749f0c284a09eafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf25c7dbd596cf41749f0c284a09eafd">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt; detail::is_tensor&lt; T1, T2 &gt;::value||detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator*= </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In place tensor multiplication. </p>
<p>Multiply the elements of left by that of right </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>left</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00183">183</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_aaf25c7dbd596cf41749f0c284a09eafd_cgraph.png" border="0" usemap="#anamespace_tiled_array_aaf25c7dbd596cf41749f0c284a09eafd_cgraph" alt=""/></div>
<map name="namespace_tiled_array_aaf25c7dbd596cf41749f0c284a09eafd_cgraph" id="anamespace_tiled_array_aaf25c7dbd596cf41749f0c284a09eafd_cgraph">
<area shape="rect" title="In place tensor multiplication." alt="" coords="5,5,175,32"/>
<area shape="rect" href="group___tile_interface.html#gad37039529fef4c507e5e5ecf379edf38" title="Multiply to the result tile." alt="" coords="223,5,369,32"/>
<area shape="rect" href="class_tiled_array_1_1_tile.html#a0736062c5f5f96f07bcff8a302b2c372" title=" " alt="" coords="417,5,587,32"/>
</map>
</div>

</div>
</div>
<a id="a70044a879bcceefda052fe65023bb378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70044a879bcceefda052fe65023bb378">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt; detail::is_tensor&lt; T1, T2 &gt;::value||detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> plus operator. </p>
<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> two tensors </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> is equal to <code>left[i] + right[i]</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00047">47</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a70044a879bcceefda052fe65023bb378_cgraph.png" border="0" usemap="#anamespace_tiled_array_a70044a879bcceefda052fe65023bb378_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a70044a879bcceefda052fe65023bb378_cgraph" id="anamespace_tiled_array_a70044a879bcceefda052fe65023bb378_cgraph">
<area shape="rect" title="Tensor plus operator." alt="" coords="5,13,168,39"/>
<area shape="rect" href="group___tile_interface.html#ga4f9977ff8130c6b95fc646e6a968f7a6" title="Add tile arguments." alt="" coords="216,13,336,39"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#ada724a31400bb94f55097560394438de" title="Factory function for tiles." alt="" coords="384,5,517,47"/>
</map>
</div>

</div>
</div>
<a id="a868921cf563ff1fb9f3304bc314fec22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868921cf563ff1fb9f3304bc314fec22">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N , typename std::enable_if&lt;(detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value) &amp;&amp;detail::is_numeric_v&lt; N &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator+= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In place tensor add constant. </p>
<p><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile.">Scale</a> the elements of <code>left</code> by <code>right</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">N</td><td>Numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand scalar argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>left</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00199">199</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a868921cf563ff1fb9f3304bc314fec22_cgraph.png" border="0" usemap="#anamespace_tiled_array_a868921cf563ff1fb9f3304bc314fec22_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a868921cf563ff1fb9f3304bc314fec22_cgraph" id="anamespace_tiled_array_a868921cf563ff1fb9f3304bc314fec22_cgraph">
<area shape="rect" title="In place tensor add constant." alt="" coords="5,5,179,32"/>
<area shape="rect" href="group___tile_interface.html#ga5eaf2e2efc1f2ca1fca6e5e2fcee256e" title="Add to the result tile." alt="" coords="227,5,367,32"/>
<area shape="rect" href="class_tiled_array_1_1_tile.html#a0736062c5f5f96f07bcff8a302b2c372" title=" " alt="" coords="415,5,584,32"/>
</map>
</div>

</div>
</div>
<a id="a9f076f0602b99660440a31b1290dcba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f076f0602b99660440a31b1290dcba7">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt; detail::is_tensor&lt; T1, T2 &gt;::value||detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator+= </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> plus operator. </p>
<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> the elements of <code>right</code> to that of <code>left</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> is equal to <code>left[i] + right[i]</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00151">151</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a9f076f0602b99660440a31b1290dcba7_cgraph.png" border="0" usemap="#anamespace_tiled_array_a9f076f0602b99660440a31b1290dcba7_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a9f076f0602b99660440a31b1290dcba7_cgraph" id="anamespace_tiled_array_a9f076f0602b99660440a31b1290dcba7_cgraph">
<area shape="rect" title="Tensor plus operator." alt="" coords="5,5,179,32"/>
<area shape="rect" href="group___tile_interface.html#ga5eaf2e2efc1f2ca1fca6e5e2fcee256e" title="Add to the result tile." alt="" coords="227,5,367,32"/>
<area shape="rect" href="class_tiled_array_1_1_tile.html#a0736062c5f5f96f07bcff8a302b2c372" title=" " alt="" coords="415,5,584,32"/>
</map>
</div>

</div>
</div>
<a id="ac90b5d6c5aae4293d2b9d3456477aeba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90b5d6c5aae4293d2b9d3456477aeba">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; decltype(arg.neg()) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a negated copy of <code>arg</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of <code>arg</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The argument tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> is equal to <code>-arg</code>[i] </dd></dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00123">123</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ac90b5d6c5aae4293d2b9d3456477aeba_cgraph.png" border="0" usemap="#anamespace_tiled_array_ac90b5d6c5aae4293d2b9d3456477aeba_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ac90b5d6c5aae4293d2b9d3456477aeba_cgraph" id="anamespace_tiled_array_ac90b5d6c5aae4293d2b9d3456477aeba_cgraph">
<area shape="rect" title="Create a negated copy of arg." alt="" coords="5,13,161,39"/>
<area shape="rect" href="group___tile_interface.html#ga6bd5665b8e247cd53460501c3f672751" title="Negate the tile argument." alt="" coords="209,13,329,39"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#ada724a31400bb94f55097560394438de" title="Factory function for tiles." alt="" coords="377,5,511,47"/>
</map>
</div>

</div>
</div>
<a id="ac6846288ddd37fd160c0afcdf72ce03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6846288ddd37fd160c0afcdf72ce03b">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt; detail::is_tensor&lt; T1, T2 &gt;::value||detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator- </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> minus operator. </p>
<p>Subtract two tensors </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> is equal to <code>left[i] - right[i]</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00063">63</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ac6846288ddd37fd160c0afcdf72ce03b_cgraph.png" border="0" usemap="#anamespace_tiled_array_ac6846288ddd37fd160c0afcdf72ce03b_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ac6846288ddd37fd160c0afcdf72ce03b_cgraph" id="anamespace_tiled_array_ac6846288ddd37fd160c0afcdf72ce03b_cgraph">
<area shape="rect" title="Tensor minus operator." alt="" coords="5,13,161,39"/>
<area shape="rect" href="group___tile_interface.html#ga58d10685bc8b980fed30a5e64db19caa" title="Subtract tile arguments." alt="" coords="209,13,333,39"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#ada724a31400bb94f55097560394438de" title="Factory function for tiles." alt="" coords="381,5,515,47"/>
</map>
</div>

</div>
</div>
<a id="acf3890c67d7f105e091e0f6114b9c56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3890c67d7f105e091e0f6114b9c56c">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N , typename std::enable_if&lt;(detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value) &amp;&amp;detail::is_numeric_v&lt; N &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator-= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In place tensor subtract constant. </p>
<p><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile.">Scale</a> the elements of <code>left</code> by <code>right</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">N</td><td>Numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand scalar argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>left</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00215">215</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_acf3890c67d7f105e091e0f6114b9c56c_cgraph.png" border="0" usemap="#anamespace_tiled_array_acf3890c67d7f105e091e0f6114b9c56c_cgraph" alt=""/></div>
<map name="namespace_tiled_array_acf3890c67d7f105e091e0f6114b9c56c_cgraph" id="anamespace_tiled_array_acf3890c67d7f105e091e0f6114b9c56c_cgraph">
<area shape="rect" title="In place tensor subtract constant." alt="" coords="5,5,172,32"/>
<area shape="rect" href="group___tile_interface.html#ga67b0fd498d81c2a5898673bcb0152934" title="Subtract from the result tile." alt="" coords="220,5,364,32"/>
<area shape="rect" href="class_tiled_array_1_1_tile.html#a0736062c5f5f96f07bcff8a302b2c372" title=" " alt="" coords="412,5,581,32"/>
</map>
</div>

</div>
</div>
<a id="a21ca0c0a8f3a232c9d615ffd6e84e41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ca0c0a8f3a232c9d615ffd6e84e41f">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt; detail::is_tensor&lt; T1, T2 &gt;::value||detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator-= </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> minus operator. </p>
<p>Subtract the elements of <code>right</code> from that of <code>left</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>left</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00167">167</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a id="a8044f7d779135e7bc782943d785a0fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8044f7d779135e7bc782943d785a0fc5">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> the tensor to an output stream. </p>
<p>This function will iterate through all tiles on node 0 and print non-zero tiles. It will wait for each tile to be evaluated (i.e. it is a blocking function). Tasks will continue to be processed. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of Array </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a></td><td>The <a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream </td></tr>
    <tr><td class="paramname">a</td><td>The array to be put in the output stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the output stream </dd></dl>

<p class="definition">Definition at line <a class="el" href="dist__array_8h_source.html#l01602">1602</a> of file <a class="el" href="dist__array_8h_source.html">dist_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a8044f7d779135e7bc782943d785a0fc5_cgraph.png" border="0" usemap="#anamespace_tiled_array_a8044f7d779135e7bc782943d785a0fc5_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a8044f7d779135e7bc782943d785a0fc5_cgraph" id="anamespace_tiled_array_a8044f7d779135e7bc782943d785a0fc5_cgraph">
<area shape="rect" title="Add the tensor to an output stream." alt="" coords="5,235,179,262"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a2ade24f4de11bf1d530e7873dfd19599" title="Find local or remote tile by index." alt="" coords="227,137,384,179"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#ab824f8b38418197da56e2e52d611681c" title="Check for zero tiles." alt="" coords="432,201,589,243"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a911b5f4183473c9c9300c370b90374df" title="Returns the number of tiles in the tensor." alt="" coords="227,257,384,299"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor." alt="" coords="227,323,384,364"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_array_impl.html#a7d58f40964ccb5a9be544414f987e258" title="Tile future accessor." alt="" coords="444,136,577,177"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_distributed_storage.html#a1f2ed572953ea119f4cfb8505fca50b6" title="Get local or remote element." alt="" coords="637,5,819,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a2c5ad33baf5e6d3778e685929ca78504" title="Query for a zero tile." alt="" coords="651,201,805,243"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#acc3da081fcb2fd124122dc750d182a96" title="Tiles range accessor." alt="" coords="637,71,819,112"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a1a16c42818cf3c0174187604ed457e79" title="Tiled range accessor." alt="" coords="653,136,803,177"/>
</map>
</div>

</div>
</div>
<a id="a00568c34aef7e5f9b2802cbdd4382ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00568c34aef7e5f9b2802cbdd4382ea5">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a> output operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream that will be used to print <code>r</code> </td></tr>
    <tr><td class="paramname">r</td><td>The range to be printed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the output stream </dd></dl>

<p class="definition">Definition at line <a class="el" href="range_8h_source.html#l01286">1286</a> of file <a class="el" href="range_8h_source.html">range.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a00568c34aef7e5f9b2802cbdd4382ea5_cgraph.png" border="0" usemap="#anamespace_tiled_array_a00568c34aef7e5f9b2802cbdd4382ea5_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a00568c34aef7e5f9b2802cbdd4382ea5_cgraph" id="anamespace_tiled_array_a00568c34aef7e5f9b2802cbdd4382ea5_cgraph">
<area shape="rect" title="Range output operator." alt="" coords="5,107,179,134"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ac1fe1f599524763265207c84e909dd15" title="Range lower bound data accessor." alt="" coords="241,5,387,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a5cd635d089830705f84e08204967760d" title="Print the content of an array like object." alt="" coords="247,71,381,112"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a491195742ae543d2e53d2234bbd0b631" title="Rank accessor." alt="" coords="227,137,401,163"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a7ee2666c973a1cc4a17845f6a410dbe9" title="Range upper bound data accessor." alt="" coords="241,188,387,229"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a2208a1aeda0c14164e2689ee284aace2" title=" " alt="" coords="449,105,624,131"/>
</map>
</div>

</div>
</div>
<a id="a9b4eb5173fc9dae94dd7a1a012f42b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4eb5173fc9dae94dd7a1a012f42b4d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_sparse_shape.html">SparseShape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> the shape to an output stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the numeric type supporting the type of <code>shape</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream </td></tr>
    <tr><td class="paramname">shape</td><td>the SparseShape&lt;T&gt; object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the output stream </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__shape_8h_source.html#l01609">1609</a> of file <a class="el" href="sparse__shape_8h_source.html">sparse_shape.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a9b4eb5173fc9dae94dd7a1a012f42b4d_cgraph.png" border="0" usemap="#anamespace_tiled_array_a9b4eb5173fc9dae94dd7a1a012f42b4d_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a9b4eb5173fc9dae94dd7a1a012f42b4d_cgraph" id="anamespace_tiled_array_a9b4eb5173fc9dae94dd7a1a012f42b4d_cgraph">
<area shape="rect" title="Add the shape to an output stream." alt="" coords="5,13,179,39"/>
<area shape="rect" href="class_tiled_array_1_1_sparse_shape.html#adb1bfeb045c67d93118696bb61db67f7" title="Data accessor." alt="" coords="227,5,407,47"/>
</map>
</div>

</div>
</div>
<a id="af6cc9b9b9bb8de13205881618621a353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6cc9b9b9bb8de13205881618621a353">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector output stream operator. </p>

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l00091">91</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_af6cc9b9b9bb8de13205881618621a353_cgraph.png" border="0" usemap="#anamespace_tiled_array_af6cc9b9b9bb8de13205881618621a353_cgraph" alt=""/></div>
<map name="namespace_tiled_array_af6cc9b9b9bb8de13205881618621a353_cgraph" id="anamespace_tiled_array_af6cc9b9b9bb8de13205881618621a353_cgraph">
<area shape="rect" title="Vector output stream operator." alt="" coords="5,13,179,39"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a5cd635d089830705f84e08204967760d" title="Print the content of an array like object." alt="" coords="227,5,360,47"/>
</map>
</div>

</div>
</div>
<a id="a67d07017bf139b8ea4e344216443b372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d07017bf139b8ea4e344216443b372">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; detail::is_tensor&lt; T &gt;::value &amp;&amp;detail::is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; TiledArray::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> output operator. </p>
<p>Output tensor <code>t</code> to the output stream, <code>os</code> . </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream </td></tr>
    <tr><td class="paramname">t</td><td>The tensor to be output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the output stream </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l00057">57</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ac42dd6da4a499c34371973b91d3529c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42dd6da4a499c34371973b91d3529c0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiled__range_8h_source.html#l00348">348</a> of file <a class="el" href="tiled__range_8h_source.html">tiled_range.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ac42dd6da4a499c34371973b91d3529c0_cgraph.png" border="0" usemap="#anamespace_tiled_array_ac42dd6da4a499c34371973b91d3529c0_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ac42dd6da4a499c34371973b91d3529c0_cgraph" id="anamespace_tiled_array_ac42dd6da4a499c34371973b91d3529c0_cgraph">
<area shape="rect" title=" " alt="" coords="5,46,179,73"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a968fbd936a1606e7885e0912a739f331" title="Access the element range." alt="" coords="227,5,396,47"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a1980b233eaa1fc559b62cc8affc2bd34" title="Access the tile range." alt="" coords="227,71,396,112"/>
</map>
</div>

</div>
</div>
<a id="a3e4d830e8d3e6b0c3ef4db415eeed8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e4d830e8d3e6b0c3ef4db415eeed8f3">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> ostream operator. </p>

<p class="definition">Definition at line <a class="el" href="tiled__range1_8h_source.html#l00323">323</a> of file <a class="el" href="tiled__range1_8h_source.html">tiled_range1.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a3e4d830e8d3e6b0c3ef4db415eeed8f3_cgraph.png" border="0" usemap="#anamespace_tiled_array_a3e4d830e8d3e6b0c3ef4db415eeed8f3_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a3e4d830e8d3e6b0c3ef4db415eeed8f3_cgraph" id="anamespace_tiled_array_a3e4d830e8d3e6b0c3ef4db415eeed8f3_cgraph">
<area shape="rect" title="TiledRange1 ostream operator." alt="" coords="5,46,179,73"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range1.html#aca8acf1ed5dc95ace1edbab47487f6e3" title="Elements range accessor." alt="" coords="227,5,404,47"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range1.html#a5d8f926b068df683395ba689aa587a9d" title="Tile range accessor." alt="" coords="227,71,404,112"/>
</map>
</div>

</div>
</div>
<a id="a343bef50b59c701745c2dc5de90edd1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343bef50b59c701745c2dc5de90edd1b">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_bipartite_permutation.html">BipartitePermutation</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_bipartite_permutation.html">BipartitePermutation</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_permutation.html" title="Permutation of a sequence of objects indexed by base-0 indices.">Permutation</a> equality operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>The left-hand permutation to be compared </td></tr>
    <tr><td class="paramname">p2</td><td>The right-hand permutation to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all elements of <code>p1</code> and <code>p2</code> are equal and the partition sizes match, otherwise <code>false</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="permutation_8h_source.html#l00795">795</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a343bef50b59c701745c2dc5de90edd1b_cgraph.png" border="0" usemap="#anamespace_tiled_array_a343bef50b59c701745c2dc5de90edd1b_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a343bef50b59c701745c2dc5de90edd1b_cgraph" id="anamespace_tiled_array_a343bef50b59c701745c2dc5de90edd1b_cgraph">
<area shape="rect" title="Permutation equality operator." alt="" coords="5,13,179,39"/>
<area shape="rect" href="class_tiled_array_1_1_bipartite_permutation.html#a1c008d05b548c56f123a9c595d593303" title=" " alt="" coords="227,5,459,47"/>
</map>
</div>

</div>
</div>
<a id="a3442799c758651ce6586418d2cf09b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3442799c758651ce6586418d2cf09b24">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_block_range.html" title="Range that references a subblock of another range.">BlockRange</a> equality comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>The first range to be compared </td></tr>
    <tr><td class="paramname">r2</td><td>The second range to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> when <code>r1</code> represents the same range as <code>r2</code>, otherwise <code>false</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="block__range_8h_source.html#l00433">433</a> of file <a class="el" href="block__range_8h_source.html">block_range.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a3442799c758651ce6586418d2cf09b24_icgraph.png" border="0" usemap="#anamespace_tiled_array_a3442799c758651ce6586418d2cf09b24_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a3442799c758651ce6586418d2cf09b24_icgraph" id="anamespace_tiled_array_a3442799c758651ce6586418d2cf09b24_icgraph">
<area shape="rect" title="BlockRange equality comparison." alt="" coords="220,5,393,32"/>
<area shape="rect" href="group__symmetry.html#gab38342dbdaa26d0f24c1633f77c6555d" title="Permutation inequality operator." alt="" coords="5,5,172,32"/>
</map>
</div>

</div>
</div>
<a id="a0de8bd808088bd6375c6dc8a9093b4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de8bd808088bd6375c6dc8a9093b4b6">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool TiledArray::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dense_shape.html">DenseShape</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dense_shape.html">DenseShape</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dense__shape_8h_source.html#l00378">378</a> of file <a class="el" href="dense__shape_8h_source.html">dense_shape.h</a>.</p>

</div>
</div>
<a id="ac25a0fb0ad765d6c6a383c67d403fc57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25a0fb0ad765d6c6a383c67d403fc57">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a> equality comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>The first range to be compared </td></tr>
    <tr><td class="paramname">r2</td><td>The second range to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> when <code>r1</code> represents the same range as <code>r2</code>, otherwise <code>false</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="range_8h_source.html#l01263">1263</a> of file <a class="el" href="range_8h_source.html">range.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ac25a0fb0ad765d6c6a383c67d403fc57_cgraph.png" border="0" usemap="#anamespace_tiled_array_ac25a0fb0ad765d6c6a383c67d403fc57_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ac25a0fb0ad765d6c6a383c67d403fc57_cgraph" id="anamespace_tiled_array_ac25a0fb0ad765d6c6a383c67d403fc57_cgraph">
<area shape="rect" title="Range equality comparison." alt="" coords="5,42,179,69"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ac1fe1f599524763265207c84e909dd15" title="Range lower bound data accessor." alt="" coords="241,5,387,47"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a491195742ae543d2e53d2234bbd0b631" title="Rank accessor." alt="" coords="227,71,401,98"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a2208a1aeda0c14164e2689ee284aace2" title=" " alt="" coords="449,13,624,39"/>
</map>
</div>

</div>
</div>
<a id="a15916eaafd6285509fe08919de285f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15916eaafd6285509fe08919de285f23">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l02163">2163</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a15916eaafd6285509fe08919de285f23_cgraph.png" border="0" usemap="#anamespace_tiled_array_a15916eaafd6285509fe08919de285f23_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a15916eaafd6285509fe08919de285f23_cgraph" id="anamespace_tiled_array_a15916eaafd6285509fe08919de285f23_cgraph">
<area shape="rect" title=" " alt="" coords="5,78,179,105"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a9270d658412efce71cde14a4e9488664" title="Data direct access." alt="" coords="227,5,365,47"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#ac6cab4cebeee61ec14aaf83ecc4b9952" title="Tensor range object accessor." alt="" coords="227,71,365,112"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#ab27ca10b5f528a0625e1eacd76106880" title="Tensor dimension size accessor." alt="" coords="227,136,365,177"/>
</map>
</div>

</div>
</div>
<a id="a4ef306922e8b07ed8df0ef92f0242947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef306922e8b07ed8df0ef92f0242947">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> equality comparison. </p>

<p class="definition">Definition at line <a class="el" href="tile_8h_source.html#l01644">1644</a> of file <a class="el" href="tile_8h_source.html">tile.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a4ef306922e8b07ed8df0ef92f0242947_cgraph.png" border="0" usemap="#anamespace_tiled_array_a4ef306922e8b07ed8df0ef92f0242947_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a4ef306922e8b07ed8df0ef92f0242947_cgraph" id="anamespace_tiled_array_a4ef306922e8b07ed8df0ef92f0242947_cgraph">
<area shape="rect" title="Tile equality comparison." alt="" coords="5,5,179,32"/>
<area shape="rect" href="class_tiled_array_1_1_tile.html#a0736062c5f5f96f07bcff8a302b2c372" title=" " alt="" coords="227,5,396,32"/>
</map>
</div>

</div>
</div>
<a id="a95a1447230c9a5ca4906ee3684cbe890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a1447230c9a5ca4906ee3684cbe890">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true when all tile and element ranges are the same. </p>

<p class="definition">Definition at line <a class="el" href="tiled__range_8h_source.html#l00337">337</a> of file <a class="el" href="tiled__range_8h_source.html">tiled_range.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a95a1447230c9a5ca4906ee3684cbe890_cgraph.png" border="0" usemap="#anamespace_tiled_array_a95a1447230c9a5ca4906ee3684cbe890_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a95a1447230c9a5ca4906ee3684cbe890_cgraph" id="anamespace_tiled_array_a95a1447230c9a5ca4906ee3684cbe890_cgraph">
<area shape="rect" title="Returns true when all tile and element ranges are the same." alt="" coords="5,107,179,134"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a9ab6d42af2997036d41180dfd5439544" title="Tile dimension boundary array accessor." alt="" coords="229,5,399,47"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a968fbd936a1606e7885e0912a739f331" title="Access the element range." alt="" coords="229,71,399,112"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a491195742ae543d2e53d2234bbd0b631" title="Rank accessor." alt="" coords="227,137,401,163"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a1980b233eaa1fc559b62cc8affc2bd34" title="Access the tile range." alt="" coords="229,188,399,229"/>
</map>
</div>

</div>
</div>
<a id="a9e0508aa5150620ac2a2a5476c6c5612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0508aa5150620ac2a2a5476c6c5612">&#9670;&nbsp;</a></span>operator==() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>

<p class="definition">Definition at line <a class="el" href="tiled__range1_8h_source.html#l00311">311</a> of file <a class="el" href="tiled__range1_8h_source.html">tiled_range1.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a9e0508aa5150620ac2a2a5476c6c5612_cgraph.png" border="0" usemap="#anamespace_tiled_array_a9e0508aa5150620ac2a2a5476c6c5612_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a9e0508aa5150620ac2a2a5476c6c5612_cgraph" id="anamespace_tiled_array_a9e0508aa5150620ac2a2a5476c6c5612_cgraph">
<area shape="rect" title="Equality operator." alt="" coords="5,107,179,134"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range1.html#a804300d74a4872393801144e33ad9963" title="Returns an iterator to the first tile in the range." alt="" coords="243,5,420,47"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range1.html#aca8acf1ed5dc95ace1edbab47487f6e3" title="Elements range accessor." alt="" coords="243,71,420,112"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range1.html#a7325e80dbe95df50fbee3baa8669f54a" title="Returns an iterator to the end of the range." alt="" coords="227,137,436,163"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range1.html#a5d8f926b068df683395ba689aa587a9d" title="Tile range accessor." alt="" coords="243,188,420,229"/>
</map>
</div>

</div>
</div>
<a id="a80801a169db3865dd8333dcf76d908fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80801a169db3865dd8333dcf76d908fb">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespace_tiled_array.html#a075713b9b2f21c1f7a54361922ff9d13">MemorySpace</a> TiledArray::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array.html#a075713b9b2f21c1f7a54361922ff9d13">MemorySpace</a>&#160;</td>
          <td class="paramname"><em>space1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array.html#a075713b9b2f21c1f7a54361922ff9d13">MemorySpace</a>&#160;</td>
          <td class="paramname"><em>space2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>union of <code>space1</code> and <code>space2</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="platform_8h_source.html#l00048">48</a> of file <a class="el" href="platform_8h_source.html">platform.h</a>.</p>

</div>
</div>
<a id="a0d11d5e7475f3cd511716fc434dc28c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d11d5e7475f3cd511716fc434dc28c7">&#9670;&nbsp;</a></span>outer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::outer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_bipartite_permutation.html">BipartitePermutation</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="permutation_8h_source.html#l00831">831</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a0d11d5e7475f3cd511716fc434dc28c7_cgraph.png" border="0" usemap="#anamespace_tiled_array_a0d11d5e7475f3cd511716fc434dc28c7_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a0d11d5e7475f3cd511716fc434dc28c7_cgraph" id="anamespace_tiled_array_a0d11d5e7475f3cd511716fc434dc28c7_cgraph">
<area shape="rect" title=" " alt="" coords="5,13,136,39"/>
<area shape="rect" href="class_tiled_array_1_1_bipartite_permutation.html#a23ec27d7401d602b1be25e02846caa68" title=" " alt="" coords="184,5,416,47"/>
</map>
</div>

</div>
</div>
<a id="a09ca17753fe59a1d02033b03b343db89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ca17753fe59a1d02033b03b343db89">&#9670;&nbsp;</a></span>outer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::outer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="permutation_8h_source.html#l00820">820</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a09ca17753fe59a1d02033b03b343db89_icgraph.png" border="0" usemap="#anamespace_tiled_array_a09ca17753fe59a1d02033b03b343db89_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a09ca17753fe59a1d02033b03b343db89_icgraph" id="anamespace_tiled_array_a09ca17753fe59a1d02033b03b343db89_icgraph">
<area shape="rect" title=" " alt="" coords="557,381,688,407"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a83ef14e0a09d55fee40c40fbf5ac58b2" title="Use a binary, element wise operation to construct a new, permuted tensor." alt="" coords="309,5,483,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#affe584326250186e9764756598f7eefd" title="Use a binary, element wise operation to construct a new, permuted tensor." alt="" coords="307,71,485,112"/>
<area shape="rect" href="class_tiled_array_1_1tile__interface_1_1_permute.html#aeeeb5ea0a11df85dbad5b77b226d4ee4" title=" " alt="" coords="303,137,489,193"/>
<area shape="rect" href="class_tiled_array_1_1tile__interface_1_1_permute_3_01_result_00_01_arg_00_01typename_01std_1_1en7a77b7348979b0dc049d9f5c087f4759.html#a2bfaca68b8ca7207e07aa9b41c414fe2" title=" " alt="" coords="283,216,509,316"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a414d53dd49a11ae4a6e67907a5daa521" title="Create a permuted copy of this tensor." alt="" coords="303,340,489,381"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aebc5c8b00cc397f5ba32ea426d1ddcc3" title=" " alt="" coords="299,405,493,447"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a3f41e1794be8e3f5515437c8301585a9" title="Construct a permuted tensor copy." alt="" coords="329,471,463,512"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a97bb481eb9dc1357f2c8816fc456e3bf" title="Construct a permuted tensor copy." alt="" coords="309,536,483,577"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a1f907f15ed5a44df959cfccc950368ac" title="Use a unary, element wise operation to construct a new, permuted tensor." alt="" coords="311,601,481,643"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aab51b68f811fbe0fbb29909202ad3b30" title="Use a unary, element wise operation to construct a new, permuted tensor." alt="" coords="309,667,483,708"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#af174120ffd75a14d13077eff16452d9b" title="In&#45;place tensor permutation operations with contiguous data." alt="" coords="46,361,194,403"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_contract_reduce.html#a3edb113a3e4524ffa21985587b0b7311" title="Post processing step." alt="" coords="5,427,235,556"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a2788b8e3e27331097aa656a0e6e36b20" title="Initialize tensor with permuted tensor arguments." alt="" coords="53,580,187,621"/>
</map>
</div>

</div>
</div>
<a id="a989cf8c0973570f17442418f3bb37a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a989cf8c0973570f17442418f3bb37a18">&#9670;&nbsp;</a></span>outer_size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::outer_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_bipartite_permutation.html">BipartitePermutation</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="permutation_8h_source.html#l00837">837</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a989cf8c0973570f17442418f3bb37a18_cgraph.png" border="0" usemap="#anamespace_tiled_array_a989cf8c0973570f17442418f3bb37a18_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a989cf8c0973570f17442418f3bb37a18_cgraph" id="anamespace_tiled_array_a989cf8c0973570f17442418f3bb37a18_cgraph">
<area shape="rect" title=" " alt="" coords="5,13,168,39"/>
<area shape="rect" href="class_tiled_array_1_1_bipartite_permutation.html#a46b1baec8bf299ce5ca6602430172142" title=" " alt="" coords="216,5,448,47"/>
<area shape="rect" href="class_tiled_array_1_1_bipartite_permutation.html#a982f88c28cfe0b3fbebd85ac1688ee28" title="Domain size accessor." alt="" coords="496,5,728,47"/>
<area shape="rect" href="class_tiled_array_1_1_permutation.html#aacb3f970f21779e9a6c2024790dc7270" title="Domain size accessor." alt="" coords="776,5,952,47"/>
</map>
</div>

</div>
</div>
<a id="aba8fcee404b04343dc31f107f1373c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8fcee404b04343dc31f107f1373c8c">&#9670;&nbsp;</a></span>outer_size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::outer_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="permutation_8h_source.html#l00827">827</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_aba8fcee404b04343dc31f107f1373c8c_cgraph.png" border="0" usemap="#anamespace_tiled_array_aba8fcee404b04343dc31f107f1373c8c_cgraph" alt=""/></div>
<map name="namespace_tiled_array_aba8fcee404b04343dc31f107f1373c8c_cgraph" id="anamespace_tiled_array_aba8fcee404b04343dc31f107f1373c8c_cgraph">
<area shape="rect" title=" " alt="" coords="5,13,168,39"/>
<area shape="rect" href="class_tiled_array_1_1_permutation.html#aacb3f970f21779e9a6c2024790dc7270" title="Domain size accessor." alt="" coords="216,5,392,47"/>
</map>
</div>

</div>
</div>
<a id="acd16fab45a79047fe90a8ba765185a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd16fab45a79047fe90a8ba765185a1d">&#9670;&nbsp;</a></span>overlap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool TiledArray::overlap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array.html#a075713b9b2f21c1f7a54361922ff9d13">MemorySpace</a>&#160;</td>
          <td class="paramname"><em>space1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array.html#a075713b9b2f21c1f7a54361922ff9d13">MemorySpace</a>&#160;</td>
          <td class="paramname"><em>space2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if intersection of <code>space1</code> and <code>space2</code> is nonnull </dd></dl>

<p class="definition">Definition at line <a class="el" href="platform_8h_source.html#l00053">53</a> of file <a class="el" href="platform_8h_source.html">platform.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_acd16fab45a79047fe90a8ba765185a1d_icgraph.png" border="0" usemap="#anamespace_tiled_array_acd16fab45a79047fe90a8ba765185a1d_icgraph" alt=""/></div>
<map name="namespace_tiled_array_acd16fab45a79047fe90a8ba765185a1d_icgraph" id="anamespace_tiled_array_acd16fab45a79047fe90a8ba765185a1d_icgraph">
<area shape="rect" title=" " alt="" coords="224,13,369,39"/>
<area shape="rect" href="namespace_tiled_array.html#a7aa78fc16b2d0cae8227821ab85d635a" title=" " alt="" coords="5,5,176,47"/>
</map>
</div>

</div>
</div>
<a id="ab8f8422b76a244ec44b61a8beeb014ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f8422b76a244ec44b61a8beeb014ee">&#9670;&nbsp;</a></span>permute() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt; &amp;&amp;                                detail::has_member_function_permute_anyreturn_v&lt;                                    const Arg, const Perm&amp;&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::permute </td>
          <td>(</td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a permuted copy of <code>arg</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>The tile argument type </td></tr>
    <tr><td class="paramname">Perm</td><td>A permutation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The tile argument to be permuted </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tile that is equal to <code>perm ^ arg</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tile__interface_2permute_8h_source.html#l00047">47</a> of file <a class="el" href="tile__interface_2permute_8h_source.html">permute.h</a>.</p>

</div>
</div>
<a id="a4568b46144cd7f450bd034c8db17b807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4568b46144cd7f450bd034c8db17b807">&#9670;&nbsp;</a></span>permute() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename  = std::enable_if_t&lt;std::is_integral_v&lt;I&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_range.html">Range</a> TiledArray::permute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; I &gt;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a permuted range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The range to be permuted </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A permuted copy of <code>r</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this is an adaptor to BTAS' permute </dd></dl>

<p class="definition">Definition at line <a class="el" href="range_8h_source.html#l01253">1253</a> of file <a class="el" href="range_8h_source.html">range.h</a>.</p>

</div>
</div>
<a id="a1bd2736a88698132f314b8a6e34aec67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd2736a88698132f314b8a6e34aec67">&#9670;&nbsp;</a></span>permute() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Perm &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!TiledArray::detail::is_permutation_v&lt;Perm&gt;, <a class="el" href="class_tiled_array_1_1_range.html">TiledArray::Range</a>&gt;::type TiledArray::permute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">TiledArray::Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>permute function for <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">TiledArray::Range</a> class with non-TiledArray <a class="el" href="class_tiled_array_1_1_permutation.html" title="Permutation of a sequence of objects indexed by base-0 indices.">Permutation</a> object </p>

<p class="definition">Definition at line <a class="el" href="external_2btas_8h_source.html#l00803">803</a> of file <a class="el" href="external_2btas_8h_source.html">btas.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a1bd2736a88698132f314b8a6e34aec67_icgraph.png" border="0" usemap="#anamespace_tiled_array_a1bd2736a88698132f314b8a6e34aec67_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a1bd2736a88698132f314b8a6e34aec67_icgraph" id="anamespace_tiled_array_a1bd2736a88698132f314b8a6e34aec67_icgraph">
<area shape="rect" title=" " alt="" coords="280,165,431,192"/>
<area shape="rect" href="class_tiled_array_1_1tile__interface_1_1_permute.html#aeeeb5ea0a11df85dbad5b77b226d4ee4" title=" " alt="" coords="25,5,212,61"/>
<area shape="rect" href="class_tiled_array_1_1tile__interface_1_1_permute_3_01_result_00_01_arg_00_01typename_01std_1_1en7a77b7348979b0dc049d9f5c087f4759.html#a2bfaca68b8ca7207e07aa9b41c414fe2" title=" " alt="" coords="5,85,232,185"/>
<area shape="rect" href="namespace_tiled_array.html#a5b58b8591b03eebae61c177036697562" title="Create a permuted copy of arg." alt="" coords="39,209,198,236"/>
<area shape="rect" href="group___tile_interface.html#gab21c3c768743ce8dec32ae106a3e79ca" title="Create a permuted copy of arg." alt="" coords="43,260,194,287"/>
</map>
</div>

</div>
</div>
<a id="a2340821470ffaf86a80c7f1e3a9cbf53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2340821470ffaf86a80c7f1e3a9cbf53">&#9670;&nbsp;</a></span>product_reduce_cuda_kernel_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T TiledArray::product_reduce_cuda_kernel_impl </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="reduce__kernel__impl_8h_source.html#l00064">64</a> of file <a class="el" href="reduce__kernel__impl_8h_source.html">reduce_kernel_impl.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a2340821470ffaf86a80c7f1e3a9cbf53_cgraph.png" border="0" usemap="#anamespace_tiled_array_a2340821470ffaf86a80c7f1e3a9cbf53_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a2340821470ffaf86a80c7f1e3a9cbf53_cgraph" id="anamespace_tiled_array_a2340821470ffaf86a80c7f1e3a9cbf53_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,200,47"/>
<area shape="rect" href="namespace_tiled_array.html#a3bc356474566d00f7de7b22b0ce8b108" title="T = reduce(T* arg)" alt="" coords="248,5,391,47"/>
</map>
</div>

</div>
</div>
<a id="aeefaad05a6d604d7013a5f96d2b28888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeefaad05a6d604d7013a5f96d2b28888">&#9670;&nbsp;</a></span>push_default_world()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;World, decltype(world_resetter)&gt; TiledArray::push_default_world </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the default World to <code>world</code> and returns a smart pointer to the current default World. Releasing this pointer will automatically set the default World to the World that it points. Thus use this as follows: </p><div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> popper = <a class="code" href="namespace_tiled_array.html#aeefaad05a6d604d7013a5f96d2b28888">push_default_world</a>(new_world);</div>
<div class="line">  assert(&amp;new_world == &amp;<a class="code" href="namespace_tiled_array.html#a8bb41dd83ecdc33052c9c02eeda152e8">get_default_world</a>()); <span class="comment">// new_world is now default</span></div>
<div class="line">  ... <span class="comment">// TiledArray expressions will use new_world now</span></div>
<div class="line">}  <span class="comment">// popper destructor resets the default World back to the old value</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>a World object which will become the new default </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a smart pointer to the current default World (i.e. not <code>world</code>) whose deleter will reset the default World back to the stored value </dd></dl>

<p class="definition">Definition at line <a class="el" href="madness_8h_source.html#l00117">117</a> of file <a class="el" href="madness_8h_source.html">madness.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_aeefaad05a6d604d7013a5f96d2b28888_cgraph.png" border="0" usemap="#anamespace_tiled_array_aeefaad05a6d604d7013a5f96d2b28888_cgraph" alt=""/></div>
<map name="namespace_tiled_array_aeefaad05a6d604d7013a5f96d2b28888_cgraph" id="anamespace_tiled_array_aeefaad05a6d604d7013a5f96d2b28888_cgraph">
<area shape="rect" title=" " alt="" coords="5,39,185,80"/>
<area shape="rect" href="struct_tiled_array_1_1detail_1_1default__world.html#af08ed184e7e3639b0c632f76cc9a9f9e" title=" " alt="" coords="236,5,400,47"/>
<area shape="rect" href="namespace_tiled_array.html#a1553ba04e597fc346a2313ab175f37b4" title="Sets the default World to world ." alt="" coords="233,71,403,112"/>
<area shape="rect" href="struct_tiled_array_1_1detail_1_1default__world.html#a8b208921f20466d1e807709942581396" title=" " alt="" coords="451,71,597,112"/>
</map>
</div>

</div>
</div>
<a id="ae6e2da9f3855369c97e61e9105cce50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e2da9f3855369c97e61e9105cce50a">&#9670;&nbsp;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::rank </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dist__array_8h_source.html#l01617">1617</a> of file <a class="el" href="dist__array_8h_source.html">dist_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ae6e2da9f3855369c97e61e9105cce50a_cgraph.png" border="0" usemap="#anamespace_tiled_array_ae6e2da9f3855369c97e61e9105cce50a_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ae6e2da9f3855369c97e61e9105cce50a_cgraph" id="anamespace_tiled_array_ae6e2da9f3855369c97e61e9105cce50a_cgraph">
<area shape="rect" title=" " alt="" coords="5,13,131,39"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="179,5,336,47"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ae6e2da9f3855369c97e61e9105cce50a_icgraph.png" border="0" usemap="#anamespace_tiled_array_ae6e2da9f3855369c97e61e9105cce50a_icgraph" alt=""/></div>
<map name="namespace_tiled_array_ae6e2da9f3855369c97e61e9105cce50a_icgraph" id="anamespace_tiled_array_ae6e2da9f3855369c97e61e9105cce50a_icgraph">
<area shape="rect" title=" " alt="" coords="1099,1233,1224,1259"/>
<area shape="rect" href="namespace_tiled_array.html#a37032bc091e5e9452a6385ebbce0dc94" title=" " alt="" coords="832,97,987,123"/>
<area shape="rect" href="namespace_tiled_array.html#ad09edca89f7e0f6b29c03206118a9c49" title=" " alt="" coords="834,261,985,287"/>
<area shape="rect" href="namespace_tiled_array.html#ad4ffc6de9b633a34e7d724191cd11f3f" title="Convert an Array object into an Eigen matrix object." alt="" coords="834,911,985,952"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg.html#a92c5af2b767e01e343ac5bbede88b0b8" title=" " alt="" coords="507,560,682,601"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_blk_tsr_expr_base.html#a1cef296df22d5e802c41ef108483588e" title="Block expression constructor." alt="" coords="768,977,1051,1033"/>
<area shape="rect" href="namespace_tiled_array.html#aa4eb781438f1d5ffec3f75b879ead8c0" title="Convert a btas::Tensor object into a TiledArray::DistArray object." alt="" coords="823,1057,995,1099"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_blk_tsr_expr_base.html#a4233158dc2d8f961fbe420397cdc715c" title=" " alt="" coords="779,1123,1039,1179"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1linalg_1_1_d_i_i_s.html#a7785ec26d7d007cf4f4d1f0fddf303fe" title=" " alt="" coords="487,626,702,682"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#ae2c7d290f2fb4704eecc33b0894de068" title="Computes a range of the diagonal elements (if any) in a rank&#45;d Range." alt="" coords="843,1255,976,1296"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a8c268a352be16fc597e6ad2c7d6a7560" title="Writes tiles of a nonconstant diagonal array." alt="" coords="518,1306,671,1362"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a808571423d2d6d551e9844f0b38369a8" title="Writes tiles of a constant diagonal array." alt="" coords="518,1159,671,1215"/>
<area shape="rect" href="namespace_tiled_array.html#a56e8a14dc06218506b921b90d86bf622" title=" " alt="" coords="851,1371,968,1398"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_expr.html#a10319000c0fd7c82c1428782621df81b" title="Evaluate this object and assign it to tsr." alt="" coords="813,1422,1005,1478"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1linalg_1_1_d_i_i_s.html#a1e21c0afce21586679b3ab7c5983bcd0" title=" " alt="" coords="247,769,421,811"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a716b4de519b8ce66cdf12b9e6578f30b" title="fuses the SparseShape objects of a tilewise&#45;round&#45;robin distributed vector of Arrays into single Spar..." alt="" coords="802,1503,1017,1544"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_leaf_engine.html#a5d1422aed6e6267f7e5181c72f430890" title="Initialize the index list of this expression." alt="" coords="817,1568,1001,1609"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_binary_engine.html#a64dfe59ebc2de023122bbdfaf6332c45" title="Initialize result tensor structure." alt="" coords="815,1633,1004,1675"/>
<area shape="rect" href="namespace_tiled_array.html#a2108251710c269618bbdf6291f16a340" title=" " alt="" coords="817,509,1002,535"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_blk_tsr_engine.html#a037d25d8c569b2489c28eb91c8009274" title="Non&#45;permuting tile operation factory function." alt="" coords="805,1699,1013,1740"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_scal_blk_tsr_engine.html#a9c146fd0600a1ee3651a8da9289aef0d" title="Non&#45;permuting tile operation factory function." alt="" coords="817,1765,1001,1821"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_blk_tsr_engine_base.html#a8e5efccb876f3fe2010242d94674a914" title="Non&#45;permuting tiled range factory function." alt="" coords="815,1845,1004,1901"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_expr_trace_target.html#ab9aaa499580ec90c3f61c902a1e7e60c" title="Start the expression trace." alt="" coords="800,1925,1019,1967"/>
<area shape="rect" href="namespacebtas.html#a5434ad02c1d953f0419acdccb7eaf62a" title=" " alt="" coords="842,1991,977,2018"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_expr.html#adf842b116f8e63fb855d5eadabb75d37" title=" " alt="" coords="813,2042,1005,2098"/>
<area shape="rect" href="namespace_tiled_array.html#a93e85683a584368627bbc160569c246f" title=" " alt="" coords="844,2122,975,2149"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg.html#aed164664129bc2babc1ee7122c06fad2" title=" " alt="" coords="822,713,997,755"/>
<area shape="rect" href="namespace_tiled_array.html#a2208f3d88d7e5293d2fc6b1fc01768fd" title=" " alt="" coords="815,859,1004,886"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg.html#aedd5240dad16cf9d351dbc30b34568e6" title=" " alt="" coords="247,392,421,433"/>
<area shape="rect" href="group___tile_interface.html#ga86214f440122e8aac85a93dce17e0d7d" title="Absolute maximum element of a tile." alt="" coords="517,71,672,98"/>
<area shape="rect" href="struct_tiled_array_1_1math_1_1linalg_1_1_conjugate_gradient_solver.html#a76d41343afbc8d219dcaafb4ab32a64e" title=" " alt="" coords="5,519,199,575"/>
<area shape="rect" href="class_tiled_array_1_1_abs_max_reduction.html#ad9c41c32c3fd91dc3f89cd2202b9e202" title=" " alt="" coords="488,5,701,47"/>
<area shape="rect" href="group___tile_interface.html#gac89ec1d5bad433cb8a9ee8612a6d88fd" title="Absolute mainimum element of a tile." alt="" coords="519,173,670,199"/>
<area shape="rect" href="class_tiled_array_1_1_abs_min_reduction.html#a1df628e219703bf23d42ebf0ddb3e930" title=" " alt="" coords="490,224,699,265"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1linalg_1_1_d_i_i_s.html#abf98aae362b3e309c5cfa170ae305ba2" title=" " alt="" coords="247,611,421,652"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a33aa537f17e1c4de2e8abf7093e29699" title="computes shape data (i.e. Frobenius norms of the tiles) for a constant diagonal tensor" alt="" coords="528,1240,661,1281"/>
<area shape="rect" href="namespace_tiled_array.html#a8d2668989011ee62fa6314733cfc4a32" title="Creates a constant diagonal DistArray." alt="" coords="258,1203,410,1244"/>
<area shape="rect" href="group___tile_interface.html#gaf71813b13896a29698efff4232719d70" title="Vector dot product of a tile." alt="" coords="536,1386,653,1413"/>
<area shape="rect" href="class_tiled_array_1_1_dot_reduction.html#ae9f6343d37bfa088e4a28896cac26f7a" title=" " alt="" coords="503,1437,687,1479"/>
<area shape="rect" href="namespace_tiled_array.html#ac602cf7316f1296d1f59f76975f5cdfb" title="fuses a vector of DistArray objects, each with the same TiledRange into a DistArray with 1 more dimen..." alt="" coords="509,1503,681,1544"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_mult_engine.html#ac0edb2ca29c0404ede453de194a103af" title="Initialize result tensor structure." alt="" coords="507,1601,683,1643"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_scal_mult_engine.html#a0138742cea6f55a6f058a7fe4ee8ff57" title="Initialize result tensor structure." alt="" coords="507,1667,682,1723"/>
<area shape="rect" href="group___tile_interface.html#gac817534360dc7eb173c22113bc49522f" title="Vector inner product of a tile." alt="" coords="502,391,687,418"/>
<area shape="rect" href="class_tiled_array_1_1_inner_product_reduction.html#aeb0e3c839f596a9ad5cf626ba6fee0f0" title=" " alt="" coords="505,443,684,484"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg.html#a1ad6389967920621411c2d56b487605b" title=" " alt="" coords="507,757,682,799"/>
<area shape="rect" href="namespace_tiled_array.html#a736de0045a7f48b5df63e3137260e40b" title=" " alt="" coords="265,861,403,887"/>
<area shape="rect" href="class_tiled_array_1_1_squared_norm_reduction.html#ae29200c16028bc21d3a944a09f042a9c" title=" " alt="" coords="469,976,720,1017"/>
<area shape="rect" href="group___tile_interface.html#ga0367bc300cd4417138d2ac139048c234" title="Squared vector 2&#45;norm of the elements of a tile." alt="" coords="500,925,689,951"/>
</map>
</div>

</div>
</div>
<a id="a3bc356474566d00f7de7b22b0ce8b108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc356474566d00f7de7b22b0ce8b108">&#9670;&nbsp;</a></span>reduce_cuda_kernel_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ReduceOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T TiledArray::reduce_cuda_kernel_impl </td>
          <td>(</td>
          <td class="paramtype">ReduceOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>T = reduce(T* arg) </p>

<p class="definition">Definition at line <a class="el" href="reduce__kernel__impl_8h_source.html#l00051">51</a> of file <a class="el" href="reduce__kernel__impl_8h_source.html">reduce_kernel_impl.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a3bc356474566d00f7de7b22b0ce8b108_icgraph.png" border="0" usemap="#anamespace_tiled_array_a3bc356474566d00f7de7b22b0ce8b108_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a3bc356474566d00f7de7b22b0ce8b108_icgraph" id="anamespace_tiled_array_a3bc356474566d00f7de7b22b0ce8b108_icgraph">
<area shape="rect" title="T = reduce(T* arg)" alt="" coords="248,104,391,145"/>
<area shape="rect" href="namespace_tiled_array.html#a0f71d75add02ed829ddc72f0a5e19e83" title=" " alt="" coords="15,5,191,47"/>
<area shape="rect" href="namespace_tiled_array.html#ae1deaffe62f8c644f5e3dc2e21789771" title=" " alt="" coords="17,71,189,112"/>
<area shape="rect" href="namespace_tiled_array.html#a2340821470ffaf86a80c7f1e3a9cbf53" title=" " alt="" coords="5,136,200,177"/>
<area shape="rect" href="namespace_tiled_array.html#ad43d5179dda74b3b85d1e8520e2f12a6" title=" " alt="" coords="15,201,190,243"/>
</map>
</div>

</div>
</div>
<a id="a3db494b2ac41df5b86b630c1af56ce3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db494b2ac41df5b86b630c1af56ce3c">&#9670;&nbsp;</a></span>remap() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_ , typename OpResult , typename Index1 , typename Index2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; const T, Range_, OpResult &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T * const&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index1 &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c838835577e8b9255dd7eaa44eceeee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c838835577e8b9255dd7eaa44eceeee">&#9670;&nbsp;</a></span>remap() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_ , typename OpResult , typename Index1 , typename Index2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; const T, Range_, OpResult &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T * const&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; Index1 &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; Index2 &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f3eccf37d7d009fa685a2a3e3e42b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3eccf37d7d009fa685a2a3e3e42b6b">&#9670;&nbsp;</a></span>remap() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_ , typename OpResult , typename Index1 , typename Index2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; T, Range_, OpResult &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T * const&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index1 &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00154">154</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a id="a1f3322ef849eda8162808382d772564c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3322ef849eda8162808382d772564c">&#9670;&nbsp;</a></span>remap() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_ , typename OpResult , typename Index1 , typename Index2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; T, Range_, OpResult &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T * const&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; Index1 &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; Index2 &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00172">172</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a id="a4da7247ef54c50ac1e2cc8c51d3e8bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da7247ef54c50ac1e2cc8c51d3e8bac">&#9670;&nbsp;</a></span>remap() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_ , typename OpResult , typename Index1 , typename Index2 , typename  = std::enable_if_t&lt;!std::is_const&lt;T&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array.html#a362559c766dfbca887fc6dff5523fb3b">TensorConstMap</a>&lt; T, Range_, OpResult &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index1 &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index2 &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00154">154</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a id="a06a8c53fcc8e44d44de78348bce433f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a8c53fcc8e44d44de78348bce433f7">&#9670;&nbsp;</a></span>remap() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_ , typename OpResult , typename Index1 , typename Index2 , typename  = std::enable_if_t&lt;!std::is_const&lt;T&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array.html#a362559c766dfbca887fc6dff5523fb3b">TensorConstMap</a>&lt; T, Range_, OpResult &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; Index1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; Index2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00172">172</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a id="ab87cc62a790937f001093b0677471e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87cc62a790937f001093b0677471e61">&#9670;&nbsp;</a></span>remap() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_ , typename OpResult , typename Index1 , typename Index2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array.html#acf8bdb4a9d561d001f7a34f49c077a5c">TensorMap</a>&lt; T, Range_, OpResult &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index1 &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index2 &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For reusing map without allocating new ranges . . . maybe. </p>

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00145">145</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a id="a9555255255f82b5cb66cfd240db0cad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9555255255f82b5cb66cfd240db0cad5">&#9670;&nbsp;</a></span>remap() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_ , typename OpResult , typename Index1 , typename Index2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array.html#acf8bdb4a9d561d001f7a34f49c077a5c">TensorMap</a>&lt; T, Range_, OpResult &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; Index1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; Index2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00162">162</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a id="a8869aaf7a547c7f9870fb0d12cbdfd09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8869aaf7a547c7f9870fb0d12cbdfd09">&#9670;&nbsp;</a></span>reset_default_world()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::reset_default_world </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resets the default World to the world returned by madness::World::get_default(), i.e. the World that spans all processes </p>

<p class="definition">Definition at line <a class="el" href="madness_8h_source.html#l00093">93</a> of file <a class="el" href="madness_8h_source.html">madness.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a8869aaf7a547c7f9870fb0d12cbdfd09_cgraph.png" border="0" usemap="#anamespace_tiled_array_a8869aaf7a547c7f9870fb0d12cbdfd09_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a8869aaf7a547c7f9870fb0d12cbdfd09_cgraph" id="anamespace_tiled_array_a8869aaf7a547c7f9870fb0d12cbdfd09_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,188,47"/>
<area shape="rect" href="struct_tiled_array_1_1detail_1_1default__world.html#a8b208921f20466d1e807709942581396" title=" " alt="" coords="236,5,383,47"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a8869aaf7a547c7f9870fb0d12cbdfd09_icgraph.png" border="0" usemap="#anamespace_tiled_array_a8869aaf7a547c7f9870fb0d12cbdfd09_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a8869aaf7a547c7f9870fb0d12cbdfd09_icgraph" id="anamespace_tiled_array_a8869aaf7a547c7f9870fb0d12cbdfd09_icgraph">
<area shape="rect" title=" " alt="" coords="196,5,379,47"/>
<area shape="rect" href="namespace_tiled_array.html#a0f1265733604f5af60af78a9d7fa3ae4" title=" " alt="" coords="5,13,148,39"/>
</map>
</div>

</div>
</div>
<a id="a93e85683a584368627bbc160569c246f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e85683a584368627bbc160569c246f">&#9670;&nbsp;</a></span>retile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TileType , typename PolicyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::retile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; TileType, PolicyType &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>new_trange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="retile_8h_source.html#l00042">42</a> of file <a class="el" href="retile_8h_source.html">retile.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a93e85683a584368627bbc160569c246f_cgraph.png" border="0" usemap="#anamespace_tiled_array_a93e85683a584368627bbc160569c246f_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a93e85683a584368627bbc160569c246f_cgraph" id="anamespace_tiled_array_a93e85683a584368627bbc160569c246f_cgraph">
<area shape="rect" title=" " alt="" coords="5,180,136,207"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a42bfd3b3ccab2835c75af773050444b7" title="Accessor of the tiled range for one of the dimensions." alt="" coords="184,5,387,32"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#ac8c1d53822fd3da51824e4d97a11dd2a" title="The rank accessor." alt="" coords="435,23,604,65"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a05c44cde899d571534b6ff2e9d22ed75" title=" " alt="" coords="207,107,364,149"/>
<area shape="rect" href="namespace_tiled_array_1_1symmetry.html#ab88cc83a558d388cedeec00d2457827d" title="identity for group of objects of type T" alt="" coords="204,173,367,214"/>
<area shape="rect" href="namespace_tiled_array.html#ae6e2da9f3855369c97e61e9105cce50a" title=" " alt="" coords="223,239,348,265"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="441,257,598,298"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor." alt="" coords="207,341,364,382"/>
</map>
</div>

</div>
</div>
<a id="a22699a4d75791748456f10475f3de4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22699a4d75791748456f10475f3de4c5">&#9670;&nbsp;</a></span>row_major_buffer_to_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">A TiledArray::row_major_buffer_to_array </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename A::trange_type &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename A::value_type::value_type *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>replicated</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; typename A::pmap_interface &gt;&#160;</td>
          <td class="paramname"><em>pmap</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a row-major matrix buffer into an Array object. </p>
<p>This function will copy the content of <code>buffer</code> into an <code>Array</code> object that is tiled according to the <code>trange</code> object. The copy operation is done in parallel, and this function will block until all elements of <code>matrix</code> have been copied into the result array tiles. Each tile is created using the local contents of <code>matrix</code>, hence it is your responsibility to ensure that the data in <code>matrix</code> is distributed correctly among the ranks. If in doubt, you should replicate <code>matrix</code> among the ranks prior to calling this.</p>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keywordtype">double</span>* buffer = <span class="keyword">new</span> <span class="keywordtype">double</span>[100 * 100];</div>
<div class="line"><span class="comment">// Fill buffer with data ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a range for the new array object</span></div>
<div class="line">std::vector&lt;std::size_t&gt; blocks;</div>
<div class="line"><span class="keywordflow">for</span>(std::size_t i = 0ul; i &lt;= 100ul; i += 10ul)</div>
<div class="line">  blocks.push_back(i);</div>
<div class="line">std::array&lt;TiledArray::TiledRange1, 2&gt; blocks2 =</div>
<div class="line">    {{ <a class="code" href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a>(blocks.begin(), blocks.end()),</div>
<div class="line">       <a class="code" href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a>(blocks.begin(), blocks.end()) }};</div>
<div class="line"><a class="code" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> trange(blocks2.begin(), blocks2.end());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create an Array from an Eigen matrix.</span></div>
<div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::Array&lt;double, 2&gt;</a> array =</div>
<div class="line">    row_major_buffer_to_array&lt;TiledArray::Array&lt;double, 2&gt; &gt;(world, trange,</div>
<div class="line">    buffer, 100, 100);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">delete</span> [] buffer;</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>The world where the array will live </td></tr>
    <tr><td class="paramname">trange</td><td>The tiled range of the new array </td></tr>
    <tr><td class="paramname">buffer</td><td>The row-major matrix buffer to be copied </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in the matrix </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix </td></tr>
    <tr><td class="paramname">replicated</td><td>if true, the result will be replicated [default = true]. </td></tr>
    <tr><td class="paramname">pmap</td><td>the process map object [default=null]; initialized to the default if <code>replicated</code> is false, or a replicated pmap if <code>replicated</code> is true; ignored if <code>replicated</code> is true and <code>world.size()&gt;1</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>Array</code> object that is a copy of <code>matrix</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When <code>m</code> and <code>n</code> are not equal to the number of rows or columns in tiled range. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00593">593</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="acf92d0f99f726bc096fe6e7c6a6bee7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf92d0f99f726bc096fe6e7c6a6bee7b">&#9670;&nbsp;</a></span>scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename Scalar , std::enable_if_t&lt; TiledArray::detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;!TiledArray::detail::is_array_v&lt; Arg &gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::scale </td>
          <td>(</td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar the tile argument. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>A tile type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A numeric type (i.e. <a class="el" href="namespace_tiled_array_1_1detail.html#ae9a8587fd56f077ba909b14bca4609d9" title="is_numeric_v&lt;T&gt; is an alias for is_numeric&lt;T&gt;::value">TiledArray::detail::is_numeric_v&lt;Scalar&gt;</a> is true)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The left-hand argument to be scaled</td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tile that is equal to <code>arg * factor</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="scale_8h_source.html#l00044">44</a> of file <a class="el" href="scale_8h_source.html">scale.h</a>.</p>

</div>
</div>
<a id="a2177a3aa0107d3a03856779aa5bad8e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2177a3aa0107d3a03856779aa5bad8e9">&#9670;&nbsp;</a></span>scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename Scalar , typename Perm , std::enable_if_t&lt; TiledArray::detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;TiledArray::detail::is_permutation_v&lt; Perm &gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::scale </td>
          <td>(</td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile.">Scale</a> and permute tile argument. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>The tile argument type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The left-hand argument to be scaled </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tile that is equal to <code>perm ^ (arg * factor)</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="scale_8h_source.html#l00060">60</a> of file <a class="el" href="scale_8h_source.html">scale.h</a>.</p>

</div>
</div>
<a id="ac10222cde45203777a4b3a6dc2d2d72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac10222cde45203777a4b3a6dc2d2d72d">&#9670;&nbsp;</a></span>scale_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Result , typename Scalar , std::enable_if_t&lt; TiledArray::detail::is_numeric_v&lt; Scalar &gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Result&amp; TiledArray::scale_to </td>
          <td>(</td>
          <td class="paramtype">Result &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile.">Scale</a> to the result tile. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Result</td><td>The result tile type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The result tile to be scaled </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tile that is equal to <code>result *= factor</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="scale_8h_source.html#l00073">73</a> of file <a class="el" href="scale_8h_source.html">scale.h</a>.</p>

</div>
</div>
<a id="a1553ba04e597fc346a2313ab175f37b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1553ba04e597fc346a2313ab175f37b4">&#9670;&nbsp;</a></span>set_default_world()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::set_default_world </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the default World to <code>world</code> . </p>
<p>Expressions that follow this call will use <code>world</code> as the default execution context (the use of default World can be overridden by explicit mechanisms for specifying the execution context, like Expr::set_world() or assigning an expression to a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> that has already been initialized with a World).</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="namespace_tiled_array.html#a1553ba04e597fc346a2313ab175f37b4" title="Sets the default World to world .">set_default_world()</a> and <a class="el" href="namespace_tiled_array.html#a8bb41dd83ecdc33052c9c02eeda152e8">get_default_world()</a> are only useful if 1 thread (usually, the main thread ) creates <a class="el" href="namespace_tiled_array.html">TiledArray</a> expressions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>a World object which will become the new default </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="madness_8h_source.html#l00085">85</a> of file <a class="el" href="madness_8h_source.html">madness.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a1553ba04e597fc346a2313ab175f37b4_cgraph.png" border="0" usemap="#anamespace_tiled_array_a1553ba04e597fc346a2313ab175f37b4_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a1553ba04e597fc346a2313ab175f37b4_cgraph" id="anamespace_tiled_array_a1553ba04e597fc346a2313ab175f37b4_cgraph">
<area shape="rect" title="Sets the default World to world ." alt="" coords="5,5,175,47"/>
<area shape="rect" href="struct_tiled_array_1_1detail_1_1default__world.html#a8b208921f20466d1e807709942581396" title=" " alt="" coords="223,5,369,47"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a1553ba04e597fc346a2313ab175f37b4_icgraph.png" border="0" usemap="#anamespace_tiled_array_a1553ba04e597fc346a2313ab175f37b4_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a1553ba04e597fc346a2313ab175f37b4_icgraph" id="anamespace_tiled_array_a1553ba04e597fc346a2313ab175f37b4_icgraph">
<area shape="rect" title="Sets the default World to world ." alt="" coords="433,27,603,69"/>
<area shape="rect" href="namespace_tiled_array.html#a1890cfcad9af02c7bbe1022d0cb7faab" title=" " alt="" coords="219,5,371,32"/>
<area shape="rect" href="namespace_tiled_array.html#aeefaad05a6d604d7013a5f96d2b28888" title=" " alt="" coords="205,57,385,98"/>
<area shape="rect" href="namespace_tiled_array.html#a42672835ea9434bc06ea421dea37d815" title=" " alt="" coords="5,5,157,32"/>
</map>
</div>

</div>
</div>
<a id="a55b406a97e00d20e23f39f52cae8d6dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b406a97e00d20e23f39f52cae8d6dc">&#9670;&nbsp;</a></span>shift() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename Index , typename  = std::enable_if_t&lt;detail::is_integral_range_v&lt;Index&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::shift </td>
          <td>(</td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>range_shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> the range of <code>arg</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>The tile argument type </td></tr>
    <tr><td class="paramname">Index</td><td>An integral range type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The tile argument to be shifted </td></tr>
    <tr><td class="paramname">range_shift</td><td>The offset to be applied to the argument range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the tile with a new range </dd></dl>

<p class="definition">Definition at line <a class="el" href="tile__interface_2shift_8h_source.html#l00043">43</a> of file <a class="el" href="tile__interface_2shift_8h_source.html">shift.h</a>.</p>

</div>
</div>
<a id="a9f2d4c345272f74469cd90d9f563d787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2d4c345272f74469cd90d9f563d787">&#9670;&nbsp;</a></span>shift() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename Index , typename  = std::enable_if_t&lt;std::is_integral_v&lt;Index&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::shift </td>
          <td>(</td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>range_shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> the range of <code>arg</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>The tile argument type </td></tr>
    <tr><td class="paramname">Index</td><td>An integral type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The tile argument to be shifted </td></tr>
    <tr><td class="paramname">range_shift</td><td>The offset to be applied to the argument range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the tile with a new range </dd></dl>

<p class="definition">Definition at line <a class="el" href="tile__interface_2shift_8h_source.html#l00056">56</a> of file <a class="el" href="tile__interface_2shift_8h_source.html">shift.h</a>.</p>

</div>
</div>
<a id="a62b1b3fec016be7c5ed4230f72e5b29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b1b3fec016be7c5ed4230f72e5b29d">&#9670;&nbsp;</a></span>shift() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html">detail::ShiftWrapper</a>&lt;const T&gt; TiledArray::shift </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> a tensor from one range to another. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor object to shift </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shifted tensor object </dd></dl>

<p class="definition">Definition at line <a class="el" href="shift__wrapper_8h_source.html#l00146">146</a> of file <a class="el" href="shift__wrapper_8h_source.html">shift_wrapper.h</a>.</p>

</div>
</div>
<a id="a3ed423a0b023a4a5aadfb5012d968a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed423a0b023a4a5aadfb5012d968a4a">&#9670;&nbsp;</a></span>shift() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html">detail::ShiftWrapper</a>&lt;T&gt; TiledArray::shift </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> a tensor from one range to another. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor object to shift </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shifted tensor object </dd></dl>

<p class="definition">Definition at line <a class="el" href="shift__wrapper_8h_source.html#l00136">136</a> of file <a class="el" href="shift__wrapper_8h_source.html">shift_wrapper.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a3ed423a0b023a4a5aadfb5012d968a4a_icgraph.png" border="0" usemap="#anamespace_tiled_array_a3ed423a0b023a4a5aadfb5012d968a4a_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a3ed423a0b023a4a5aadfb5012d968a4a_icgraph" id="anamespace_tiled_array_a3ed423a0b023a4a5aadfb5012d968a4a_icgraph">
<area shape="rect" title="Shift a tensor from one range to another." alt="" coords="289,148,413,175"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_expr.html#a10319000c0fd7c82c1428782621df81b" title="Evaluate this object and assign it to tsr." alt="" coords="27,5,219,61"/>
<area shape="rect" href="class_tiled_array_1_1tile__interface_1_1_shift.html#ae41095dcbe777304303fc0baef920ab3" title=" " alt="" coords="32,85,215,141"/>
<area shape="rect" href="class_tiled_array_1_1tile__interface_1_1_shift_3_01_result_00_01_arg_00_01typename_01std_1_1enab30c9bbdca9725fc3bda440b8a046e897.html#af9d6e3129c97b296e302bfc397142cf6" title=" " alt="" coords="5,165,241,251"/>
<area shape="rect" href="group___tile_interface.html#gacca0c957b239734acfa9b111a65736df" title="Shift the range of arg." alt="" coords="61,275,185,301"/>
</map>
</div>

</div>
</div>
<a id="a53b4cffaa8c8a7ded3b9a0a56f529ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b4cffaa8c8a7ded3b9a0a56f529ebb">&#9670;&nbsp;</a></span>shift_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename Index , typename  = std::enable_if_t&lt;detail::is_integral_range_v&lt;Index&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::shift_to </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>range_shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> the range of <code>arg</code> in place. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>The tile argument type </td></tr>
    <tr><td class="paramname">Index</td><td>An integral range type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The tile argument to be shifted </td></tr>
    <tr><td class="paramname">range_shift</td><td>The offset to be applied to the argument range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the tile with a new range </dd></dl>

<p class="definition">Definition at line <a class="el" href="tile__interface_2shift_8h_source.html#l00070">70</a> of file <a class="el" href="tile__interface_2shift_8h_source.html">shift.h</a>.</p>

</div>
</div>
<a id="a1df329d84b8e06ed0c5eac001dcee410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df329d84b8e06ed0c5eac001dcee410">&#9670;&nbsp;</a></span>shift_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename Index , typename  = std::enable_if_t&lt;std::is_integral_v&lt;Index&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::shift_to </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>range_shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> the range of <code>arg</code> in place. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>The tile argument type </td></tr>
    <tr><td class="paramname">Index</td><td>An integral type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The tile argument to be shifted </td></tr>
    <tr><td class="paramname">range_shift</td><td>The offset to be applied to the argument range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the tile with a new range </dd></dl>

<p class="definition">Definition at line <a class="el" href="tile__interface_2shift_8h_source.html#l00083">83</a> of file <a class="el" href="tile__interface_2shift_8h_source.html">shift.h</a>.</p>

</div>
</div>
<a id="a2208f3d88d7e5293d2fc6b1fc01768fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2208f3d88d7e5293d2fc6b1fc01768fd">&#9670;&nbsp;</a></span>squared_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::squared_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dist__array_8h_source.html#l01655">1655</a> of file <a class="el" href="dist__array_8h_source.html">dist_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a2208f3d88d7e5293d2fc6b1fc01768fd_cgraph.png" border="0" usemap="#anamespace_tiled_array_a2208f3d88d7e5293d2fc6b1fc01768fd_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a2208f3d88d7e5293d2fc6b1fc01768fd_cgraph" id="anamespace_tiled_array_a2208f3d88d7e5293d2fc6b1fc01768fd_cgraph">
<area shape="rect" title=" " alt="" coords="5,42,195,69"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a05c44cde899d571534b6ff2e9d22ed75" title=" " alt="" coords="243,5,400,47"/>
<area shape="rect" href="namespace_tiled_array.html#ae6e2da9f3855369c97e61e9105cce50a" title=" " alt="" coords="259,71,384,98"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="448,64,605,105"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a2208f3d88d7e5293d2fc6b1fc01768fd_icgraph.png" border="0" usemap="#anamespace_tiled_array_a2208f3d88d7e5293d2fc6b1fc01768fd_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a2208f3d88d7e5293d2fc6b1fc01768fd_icgraph" id="anamespace_tiled_array_a2208f3d88d7e5293d2fc6b1fc01768fd_icgraph">
<area shape="rect" title=" " alt="" coords="545,79,735,105"/>
<area shape="rect" href="namespace_tiled_array.html#a736de0045a7f48b5df63e3137260e40b" title=" " alt="" coords="303,20,441,47"/>
<area shape="rect" href="class_tiled_array_1_1_squared_norm_reduction.html#ae29200c16028bc21d3a944a09f042a9c" title=" " alt="" coords="247,71,497,113"/>
<area shape="rect" href="group___tile_interface.html#ga0367bc300cd4417138d2ac139048c234" title="Squared vector 2&#45;norm of the elements of a tile." alt="" coords="277,137,467,164"/>
<area shape="rect" href="struct_tiled_array_1_1math_1_1linalg_1_1_conjugate_gradient_solver.html#a76d41343afbc8d219dcaafb4ab32a64e" title=" " alt="" coords="5,5,199,61"/>
</map>
</div>

</div>
</div>
<a id="a40ec22d8c4caa8f1662a6c124430e802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ec22d8c4caa8f1662a6c124430e802">&#9670;&nbsp;</a></span>subarray_from_fused_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::subarray_from_fused_array </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>local_world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">TA::DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>fused_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>tile_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_tiled_array_1_1_dist_array.html">TA::DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>split_arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TA::TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>split_trange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extracts a subarray of a fused array created with fuse_vector_of_arrays and creates the array in <code>local_world</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">local_world</td><td>The World object where the @i -th subarray is created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fused_array</td><td>a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> created with fuse_vector_of_arrays </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index of the subarray to be extracted (i.e. the index of the corresponding <em>element</em> index of the leading dimension) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tile_of_i</td><td>tile range information for tile i </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">split_trange</td><td><a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array.">TiledRange</a> of the split Array object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <code>i</code> -th subarray </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_tiled_array_1_1detail.html#af29fcee5d56ed2b3110413f3d8d31d2f" title="extracts the shape of a slice of a fused array created with fuse_vector_of_arrays">detail::subshape_from_fused_tile</a> TODO rename to split_tilewise_fused_array </dd></dl>
<p>copy the data from tile</p>
<p>write to blocks of fused_array</p>

<p class="definition">Definition at line <a class="el" href="vector__of__arrays_8h_source.html#l00393">393</a> of file <a class="el" href="vector__of__arrays_8h_source.html">vector_of_arrays.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a40ec22d8c4caa8f1662a6c124430e802_cgraph.png" border="0" usemap="#anamespace_tiled_array_a40ec22d8c4caa8f1662a6c124430e802_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a40ec22d8c4caa8f1662a6c124430e802_cgraph" id="anamespace_tiled_array_a40ec22d8c4caa8f1662a6c124430e802_cgraph">
<area shape="rect" title="extracts a subarray of a fused array created with fuse_vector_of_arrays and creates the array in loca..." alt="" coords="5,321,159,363"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a2208a1aeda0c14164e2689ee284aace2" title=" " alt="" coords="220,87,395,114"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a2ade24f4de11bf1d530e7873dfd19599" title="Find local or remote tile by index." alt="" coords="229,139,386,180"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#ab824f8b38418197da56e2e52d611681c" title="Check for zero tiles." alt="" coords="462,201,619,243"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#ada724a31400bb94f55097560394438de" title="Factory function for tiles." alt="" coords="241,256,374,297"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a3140a5cda14c2ea5b5e7c654099f015d" title="Shape accessor." alt="" coords="229,321,386,363"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#af29fcee5d56ed2b3110413f3d8d31d2f" title="extracts the shape of a slice of a fused array created with fuse_vector_of_arrays" alt="" coords="207,439,408,480"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a1980b233eaa1fc559b62cc8affc2bd34" title="Access the tile range." alt="" coords="456,373,625,415"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a63700b9c4ebc8c67f46325f77ed4cd2a" title="Range volume accessor." alt="" coords="468,504,613,545"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="229,556,386,597"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_array_impl.html#a7d58f40964ccb5a9be544414f987e258" title="Tile future accessor." alt="" coords="474,136,607,177"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_distributed_storage.html#a1f2ed572953ea119f4cfb8505fca50b6" title="Get local or remote element." alt="" coords="673,71,855,112"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a2c5ad33baf5e6d3778e685929ca78504" title="Query for a zero tile." alt="" coords="687,201,841,243"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#acc3da081fcb2fd124122dc750d182a96" title="Tiles range accessor." alt="" coords="673,136,855,177"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a1a16c42818cf3c0174187604ed457e79" title="Tiled range accessor." alt="" coords="689,5,839,47"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a9270d658412efce71cde14a4e9488664" title="Data direct access." alt="" coords="471,439,610,480"/>
</map>
</div>

</div>
</div>
<a id="ad43d5179dda74b3b85d1e8520e2f12a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43d5179dda74b3b85d1e8520e2f12a6">&#9670;&nbsp;</a></span>sum_reduce_cuda_kernel_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T TiledArray::sum_reduce_cuda_kernel_impl </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="reduce__kernel__impl_8h_source.html#l00072">72</a> of file <a class="el" href="reduce__kernel__impl_8h_source.html">reduce_kernel_impl.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ad43d5179dda74b3b85d1e8520e2f12a6_cgraph.png" border="0" usemap="#anamespace_tiled_array_ad43d5179dda74b3b85d1e8520e2f12a6_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ad43d5179dda74b3b85d1e8520e2f12a6_cgraph" id="anamespace_tiled_array_ad43d5179dda74b3b85d1e8520e2f12a6_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,180,47"/>
<area shape="rect" href="namespace_tiled_array.html#a3bc356474566d00f7de7b22b0ce8b108" title="T = reduce(T* arg)" alt="" coords="228,5,371,47"/>
</map>
</div>

</div>
</div>
<a id="a8386153a74ac2847e5c1025d438fd1a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8386153a74ac2847e5c1025d438fd1a6">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void TiledArray::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the referred callables of <code>lhs</code> and <code>rhs</code>. </p>

<p class="definition">Definition at line <a class="el" href="function_8h_source.html#l00120">120</a> of file <a class="el" href="function_8h_source.html">function.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a8386153a74ac2847e5c1025d438fd1a6_icgraph.png" border="0" usemap="#anamespace_tiled_array_a8386153a74ac2847e5c1025d438fd1a6_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a8386153a74ac2847e5c1025d438fd1a6_icgraph" id="anamespace_tiled_array_a8386153a74ac2847e5c1025d438fd1a6_icgraph">
<area shape="rect" title="Swaps the referred callables of lhs and rhs." alt="" coords="228,13,359,39"/>
<area shape="rect" href="class_tiled_array_1_1function__ref_3_01_r_07_args_8_8_8_08_4.html#a5ca8a387ea4aaed4ef44ded4e8a26928" title="Swaps the referred callables of *this and rhs." alt="" coords="5,5,180,47"/>
</map>
</div>

</div>
</div>
<a id="a705b350b2dbf336a9cc24fb1d0f78fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705b350b2dbf336a9cc24fb1d0f78fca">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchange the values of the give two ranges. </p>

<p class="definition">Definition at line <a class="el" href="range_8h_source.html#l01233">1233</a> of file <a class="el" href="range_8h_source.html">range.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a705b350b2dbf336a9cc24fb1d0f78fca_cgraph.png" border="0" usemap="#anamespace_tiled_array_a705b350b2dbf336a9cc24fb1d0f78fca_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a705b350b2dbf336a9cc24fb1d0f78fca_cgraph" id="anamespace_tiled_array_a705b350b2dbf336a9cc24fb1d0f78fca_cgraph">
<area shape="rect" title="Exchange the values of the give two ranges." alt="" coords="5,5,136,32"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ad5c630210968ab837a58bedcb3b29442" title=" " alt="" coords="184,5,363,32"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a705b350b2dbf336a9cc24fb1d0f78fca_icgraph.png" border="0" usemap="#anamespace_tiled_array_a705b350b2dbf336a9cc24fb1d0f78fca_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a705b350b2dbf336a9cc24fb1d0f78fca_icgraph" id="anamespace_tiled_array_a705b350b2dbf336a9cc24fb1d0f78fca_icgraph">
<area shape="rect" title="Exchange the values of the give two ranges." alt="" coords="671,46,801,73"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ad5c630210968ab837a58bedcb3b29442" title=" " alt="" coords="444,46,623,73"/>
<area shape="rect" href="class_tiled_array_1_1_block_range.html#aa8e883ff57e15866ee27e8e07dc60b90" title=" " alt="" coords="223,5,396,47"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a348bcd96541cb2bc8588cfc333778455" title=" " alt="" coords="225,71,394,112"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#ab90bd6a088860c5ab99398dafe2be406" title="TiledRange assignment operator." alt="" coords="5,12,175,53"/>
<area shape="rect" href="namespace_tiled_array.html#a4b0947b0d351b9ee0112b292eb869249" title="Exchange the content of the two given TiledRange&#39;s." alt="" coords="25,78,155,105"/>
</map>
</div>

</div>
</div>
<a id="a4b0947b0d351b9ee0112b292eb869249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0947b0d351b9ee0112b292eb869249">&#9670;&nbsp;</a></span>swap() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchange the content of the two given <a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array.">TiledRange</a>'s. </p>

<p class="definition">Definition at line <a class="el" href="tiled__range_8h_source.html#l00334">334</a> of file <a class="el" href="tiled__range_8h_source.html">tiled_range.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a4b0947b0d351b9ee0112b292eb869249_cgraph.png" border="0" usemap="#anamespace_tiled_array_a4b0947b0d351b9ee0112b292eb869249_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a4b0947b0d351b9ee0112b292eb869249_cgraph" id="anamespace_tiled_array_a4b0947b0d351b9ee0112b292eb869249_cgraph">
<area shape="rect" title="Exchange the content of the two given TiledRange&#39;s." alt="" coords="5,13,136,39"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a348bcd96541cb2bc8588cfc333778455" title=" " alt="" coords="184,5,353,47"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ad5c630210968ab837a58bedcb3b29442" title=" " alt="" coords="401,13,580,39"/>
<area shape="rect" href="namespace_tiled_array.html#a705b350b2dbf336a9cc24fb1d0f78fca" title="Exchange the values of the give two ranges." alt="" coords="628,13,759,39"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a4b0947b0d351b9ee0112b292eb869249_icgraph.png" border="0" usemap="#anamespace_tiled_array_a4b0947b0d351b9ee0112b292eb869249_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a4b0947b0d351b9ee0112b292eb869249_icgraph" id="anamespace_tiled_array_a4b0947b0d351b9ee0112b292eb869249_icgraph">
<area shape="rect" title="Exchange the content of the two given TiledRange&#39;s." alt="" coords="440,13,571,39"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a348bcd96541cb2bc8588cfc333778455" title=" " alt="" coords="223,5,392,47"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#ab90bd6a088860c5ab99398dafe2be406" title="TiledRange assignment operator." alt="" coords="5,5,175,47"/>
</map>
</div>

</div>
</div>
<a id="abe5632aeeaf569807a5e38b4ae1c5a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5632aeeaf569807a5e38b4ae1c5a98">&#9670;&nbsp;</a></span>swap() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>r0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchange the data of the two given ranges. </p>

<p class="definition">Definition at line <a class="el" href="tiled__range1_8h_source.html#l00306">306</a> of file <a class="el" href="tiled__range1_8h_source.html">tiled_range1.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_abe5632aeeaf569807a5e38b4ae1c5a98_cgraph.png" border="0" usemap="#anamespace_tiled_array_abe5632aeeaf569807a5e38b4ae1c5a98_cgraph" alt=""/></div>
<map name="namespace_tiled_array_abe5632aeeaf569807a5e38b4ae1c5a98_cgraph" id="anamespace_tiled_array_abe5632aeeaf569807a5e38b4ae1c5a98_cgraph">
<area shape="rect" title="Exchange the data of the two given ranges." alt="" coords="5,13,136,39"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range1.html#a6cceff1ac7cf448502e83993911e24a6" title="swapper" alt="" coords="184,5,361,47"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_abe5632aeeaf569807a5e38b4ae1c5a98_icgraph.png" border="0" usemap="#anamespace_tiled_array_abe5632aeeaf569807a5e38b4ae1c5a98_icgraph" alt=""/></div>
<map name="namespace_tiled_array_abe5632aeeaf569807a5e38b4ae1c5a98_icgraph" id="anamespace_tiled_array_abe5632aeeaf569807a5e38b4ae1c5a98_icgraph">
<area shape="rect" title="Exchange the data of the two given ranges." alt="" coords="231,13,361,39"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range1.html#a6cceff1ac7cf448502e83993911e24a6" title="swapper" alt="" coords="5,5,183,47"/>
</map>
</div>

</div>
</div>
<a id="a982f4ff04f86f6ea1bd32d0f8046d479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982f4ff04f86f6ea1bd32d0f8046d479">&#9670;&nbsp;</a></span>system_now()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::system_clock::time_point TiledArray::system_now </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="time_8h_source.html#l00037">37</a> of file <a class="el" href="time_8h_source.html">time.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a982f4ff04f86f6ea1bd32d0f8046d479_cgraph.png" border="0" usemap="#anamespace_tiled_array_a982f4ff04f86f6ea1bd32d0f8046d479_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a982f4ff04f86f6ea1bd32d0f8046d479_cgraph" id="anamespace_tiled_array_a982f4ff04f86f6ea1bd32d0f8046d479_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,184,32"/>
<area shape="rect" href="namespace_tiled_array.html#a28ed2ff1e65aebae0733ebc4b73e17bf" title=" " alt="" coords="232,5,355,32"/>
</map>
</div>

</div>
</div>
<a id="aa273a954beb5f7b7fc4d94c17c0c774d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa273a954beb5f7b7fc4d94c17c0c774d">&#9670;&nbsp;</a></span>ta_abort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::ta_abort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finalizes <a class="el" href="namespace_tiled_array.html">TiledArray</a> (and MADWorld runtime, if it had not been initialized when <a class="el" href="namespace_tiled_array.html#a1890cfcad9af02c7bbe1022d0cb7faab">TiledArray::initialize</a> was called). </p>

<p class="definition">Definition at line <a class="el" href="tiledarray_8cpp_source.html#l00136">136</a> of file <a class="el" href="tiledarray_8cpp_source.html">tiledarray.cpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_aa273a954beb5f7b7fc4d94c17c0c774d_icgraph.png" border="0" usemap="#anamespace_tiled_array_aa273a954beb5f7b7fc4d94c17c0c774d_icgraph" alt=""/></div>
<map name="namespace_tiled_array_aa273a954beb5f7b7fc4d94c17c0c774d_icgraph" id="anamespace_tiled_array_aa273a954beb5f7b7fc4d94c17c0c774d_icgraph">
<area shape="rect" title=" " alt="" coords="204,42,355,69"/>
<area shape="rect" href="namespace_tiled_array.html#a6bdf2a8c0016b75f187be14d3dde68b4" title=" " alt="" coords="13,5,149,47"/>
<area shape="rect" href="namespace_tiled_array.html#ad9592cd825cf934e8fa07f1f085bf247" title=" " alt="" coords="5,71,156,98"/>
</map>
</div>

</div>
</div>
<a id="ad9592cd825cf934e8fa07f1f085bf247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9592cd825cf934e8fa07f1f085bf247">&#9670;&nbsp;</a></span>ta_abort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::ta_abort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finalizes <a class="el" href="namespace_tiled_array.html">TiledArray</a> (and MADWorld runtime, if it had not been initialized when <a class="el" href="namespace_tiled_array.html#a1890cfcad9af02c7bbe1022d0cb7faab">TiledArray::initialize</a> was called). </p>

<p class="definition">Definition at line <a class="el" href="tiledarray_8cpp_source.html#l00140">140</a> of file <a class="el" href="tiledarray_8cpp_source.html">tiledarray.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ad9592cd825cf934e8fa07f1f085bf247_cgraph.png" border="0" usemap="#anamespace_tiled_array_ad9592cd825cf934e8fa07f1f085bf247_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ad9592cd825cf934e8fa07f1f085bf247_cgraph" id="anamespace_tiled_array_ad9592cd825cf934e8fa07f1f085bf247_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,156,32"/>
<area shape="rect" href="namespace_tiled_array.html#aa273a954beb5f7b7fc4d94c17c0c774d" title=" " alt="" coords="204,5,355,32"/>
</map>
</div>

</div>
</div>
<a id="ad8cb3eac6d5a72fae3c98b4d78f5b77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8cb3eac6d5a72fae3c98b4d78f5b77a">&#9670;&nbsp;</a></span>tensor_to_btas_subtensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tensor_ , typename T , typename Range_ , typename Storage_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::tensor_to_btas_subtensor </td>
          <td>(</td>
          <td class="paramtype">const Tensor_ &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">btas::Tensor&lt; T, Range_, Storage_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a block of a btas::Tensor into a <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">TiledArray::Tensor</a>. </p>
<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">TiledArray::Tensor</a> <code>src</code> will be copied into a block of btas::Tensor <code>dst</code>. The block dimensions will be determined by the dimensions of the range of <code>src</code> . </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tensor_</td><td>A tensor type (e.g., <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">TiledArray::Tensor</a> or btas::Tensor, optionally wrapped into <a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">TiledArray::Tile</a>) </td></tr>
    <tr><td class="paramname">T</td><td>The tensor element type </td></tr>
    <tr><td class="paramname">Range_</td><td>The range type of the destination btas::Tensor object </td></tr>
    <tr><td class="paramname">Storage_</td><td>The storage type of the destination btas::Tensor object </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The source object whose contents will be copied into a subblock of <code>dst</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>The destination object; its subblock defined by the {lower,upper} bounds <code>{src.lobound()</code>,src.upbound()} will be overwritten with the content of <code>src</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the dimensions of <code>src</code> and <code>dst</code> do not match. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2btas_8h_source.html#l00096">96</a> of file <a class="el" href="conversions_2btas_8h_source.html">btas.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ad8cb3eac6d5a72fae3c98b4d78f5b77a_cgraph.png" border="0" usemap="#anamespace_tiled_array_ad8cb3eac6d5a72fae3c98b4d78f5b77a_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ad8cb3eac6d5a72fae3c98b4d78f5b77a_cgraph" id="anamespace_tiled_array_ad8cb3eac6d5a72fae3c98b4d78f5b77a_cgraph">
<area shape="rect" title="Copy a block of a btas::Tensor into a TiledArray::Tensor." alt="" coords="5,89,153,131"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ab4da186af12caf4000fd293eaf2c744e" title="Range lower bound accessor." alt="" coords="234,5,379,47"/>
<area shape="rect" href="namespace_tiled_array.html#a4fc8675b642f53bdab884e5a6c473103" title=" " alt="" coords="201,71,412,98"/>
<area shape="rect" href="namespace_tiled_array.html#a676ce2ab1b89d4f820aba886f9ce12a7" title=" " alt="" coords="223,122,391,149"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a45190dfcad5ef2b9af5b4aa000c844b0" title=" " alt="" coords="240,173,373,215"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ac1fe1f599524763265207c84e909dd15" title="Range lower bound data accessor." alt="" coords="460,5,605,47"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a2208a1aeda0c14164e2689ee284aace2" title=" " alt="" coords="653,13,828,39"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ad8cb3eac6d5a72fae3c98b4d78f5b77a_icgraph.png" border="0" usemap="#anamespace_tiled_array_ad8cb3eac6d5a72fae3c98b4d78f5b77a_icgraph" alt=""/></div>
<map name="namespace_tiled_array_ad8cb3eac6d5a72fae3c98b4d78f5b77a_icgraph" id="anamespace_tiled_array_ad8cb3eac6d5a72fae3c98b4d78f5b77a_icgraph">
<area shape="rect" title="Copy a block of a btas::Tensor into a TiledArray::Tensor." alt="" coords="204,13,352,54"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#aae305e910ce674d71f550e104c354cb5" title="Task function for assigning a tensor to an Eigen submatrix." alt="" coords="5,5,156,61"/>
</map>
</div>

</div>
</div>
<a id="a3f423f82e222f193a882c9ea1cb7567f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f423f82e222f193a882c9ea1cb7567f">&#9670;&nbsp;</a></span>tensor_to_eigen_submatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Derived , std::enable_if_t&lt; detail::is_contiguous_tensor_v&lt; T &gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::tensor_to_eigen_submatrix </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the content of a tensor into an <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> matrix block. </p>
<p>The content of tensor will be copied into a block of matrix. The block dimensions will be determined by the dimensions of the tensor's range. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensor type, e.g. <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">TiledArray::Tensor</a> </td></tr>
    <tr><td class="paramname">Derived</td><td>The derived type of an <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor</td><td>The object that will be copied to <code>matrix</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">matrix</td><td>The object that will be assigned the content of <code>tensor</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the dimensions of <code>tensor</code> are not equal to 1 or 2. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the range of <code>tensor</code> is outside the range of <code>matrix</code> . </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00274">274</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a3f423f82e222f193a882c9ea1cb7567f_cgraph.png" border="0" usemap="#anamespace_tiled_array_a3f423f82e222f193a882c9ea1cb7567f_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a3f423f82e222f193a882c9ea1cb7567f_cgraph" id="anamespace_tiled_array_a3f423f82e222f193a882c9ea1cb7567f_cgraph">
<area shape="rect" title="Copy the content of a tensor into an Eigen matrix block." alt="" coords="5,5,164,47"/>
<area shape="rect" href="namespace_tiled_array.html#a03e3bc36192ae1bb9b4f6e3da001023a" title="Construct a const Eigen::Map object for a given Tensor object." alt="" coords="212,13,380,39"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a3f423f82e222f193a882c9ea1cb7567f_icgraph.png" border="0" usemap="#anamespace_tiled_array_a3f423f82e222f193a882c9ea1cb7567f_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a3f423f82e222f193a882c9ea1cb7567f_icgraph" id="anamespace_tiled_array_a3f423f82e222f193a882c9ea1cb7567f_icgraph">
<area shape="rect" title="Copy the content of a tensor into an Eigen matrix block." alt="" coords="403,13,561,54"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#afe493525138ef355ba76900e56ae8cf2" title="Task function for assigning a tensor to an Eigen submatrix." alt="" coords="204,5,355,61"/>
<area shape="rect" href="namespace_tiled_array.html#ad4ffc6de9b633a34e7d724191cd11f3f" title="Convert an Array object into an Eigen matrix object." alt="" coords="5,13,156,54"/>
</map>
</div>

</div>
</div>
<a id="a8291483119dcf3831ee15dce5be0b85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8291483119dcf3831ee15dce5be0b85a">&#9670;&nbsp;</a></span>tiled_range_from_il()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = std::array&lt;TiledRange1, initializer_list_rank_v&lt;std::decay_t&lt;T&gt;&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::tiled_range_from_il </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>shape</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array.">TiledRange</a> for the provided initializer list. </p>
<p>Tensors which are constructed with initializer lists are assumed to be small enough that the data should reside in a single tile. This function will recurse through <code>il</code> and create a <a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array.">TiledRange</a> instance such that each rank is tiled from <code>[0, n_i)</code> where <code>n_i</code> is the length of the <code>i</code>-th nested <code>std::initializer_list</code> in <code>il</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Expected to be the type of a tensor element (<em>i.e.</em> float, double, <em>etc.</em>) or a (possibly nested) <code>std::initializer_list</code> of tensor elements. </td></tr>
    <tr><td class="paramname">U</td><td>The type of the container which will hold the <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> instances for each level of nesting in <code>T</code>. <code>U</code> must satisfy the concept of a random-access container. <code>U</code> defaults to <code>std::array&lt;<a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a>, N&gt;</code> where <code>N</code> is the degree of nesting of <code>il</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>The state we intend to initialize the tensor to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>A pre-allocated buffer that will be used to hold the <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> instances for each <code>std::initializer_list</code> as this function recurses. The default value is an <code>std::array</code> of default constructed <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> instances, which should suffice for most purposes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array.">TiledRange</a> instance consistent with treating <code>il</code> as a tensor with a single tile.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>if <code>il</code> contains no elements. If an exception is raised this way <code>il</code> and <code>shape</code> are guaranteed to be in the same state (strong throw guarantee). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="initializer__list_8h_source.html#l00131">131</a> of file <a class="el" href="initializer__list_8h_source.html">initializer_list.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a8291483119dcf3831ee15dce5be0b85a_icgraph.png" border="0" usemap="#anamespace_tiled_array_a8291483119dcf3831ee15dce5be0b85a_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a8291483119dcf3831ee15dce5be0b85a_icgraph" id="anamespace_tiled_array_a8291483119dcf3831ee15dce5be0b85a_icgraph">
<area shape="rect" title="Creates a TiledRange for the provided initializer list." alt="" coords="236,5,405,47"/>
<area shape="rect" href="namespace_tiled_array.html#af9109c96280c540844ebe4e8ab8adecd" title="Converts an std::initializer_list into a single tile array." alt="" coords="5,13,188,39"/>
</map>
</div>

</div>
</div>
<a id="aa14fae9ffb07568e7366e6e1964665cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14fae9ffb07568e7366e6e1964665cc">&#9670;&nbsp;</a></span>to_dense() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename ResultPolicy  = DensePolicy, typename ArgPolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt;ResultPolicy&gt; &amp;&amp; !<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt;ArgPolicy&gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, ResultPolicy&gt; &gt; TiledArray::to_dense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, ArgPolicy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>sparse_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sparse__to__dense_8h_source.html#l00037">37</a> of file <a class="el" href="sparse__to__dense_8h_source.html">sparse_to_dense.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_aa14fae9ffb07568e7366e6e1964665cc_cgraph.png" border="0" usemap="#anamespace_tiled_array_aa14fae9ffb07568e7366e6e1964665cc_cgraph" alt=""/></div>
<map name="namespace_tiled_array_aa14fae9ffb07568e7366e6e1964665cc_cgraph" id="anamespace_tiled_array_aa14fae9ffb07568e7366e6e1964665cc_cgraph">
<area shape="rect" title=" " alt="" coords="5,235,160,262"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a2ade24f4de11bf1d530e7873dfd19599" title="Find local or remote tile by index." alt="" coords="208,137,365,179"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#ab824f8b38418197da56e2e52d611681c" title="Check for zero tiles." alt="" coords="413,201,571,243"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="208,257,365,299"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor." alt="" coords="208,323,365,364"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_array_impl.html#a7d58f40964ccb5a9be544414f987e258" title="Tile future accessor." alt="" coords="425,136,559,177"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_distributed_storage.html#a1f2ed572953ea119f4cfb8505fca50b6" title="Get local or remote element." alt="" coords="619,5,800,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a2c5ad33baf5e6d3778e685929ca78504" title="Query for a zero tile." alt="" coords="632,201,787,243"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#acc3da081fcb2fd124122dc750d182a96" title="Tiles range accessor." alt="" coords="619,71,800,112"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a1a16c42818cf3c0174187604ed457e79" title="Tiled range accessor." alt="" coords="634,136,785,177"/>
</map>
</div>

</div>
</div>
<a id="a64038a31ff7ab96b97008f3ab99e915f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64038a31ff7ab96b97008f3ab99e915f">&#9670;&nbsp;</a></span>to_dense() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt;Policy&gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy&gt; &gt; TiledArray::to_dense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sparse__to__dense_8h_source.html#l00065">65</a> of file <a class="el" href="sparse__to__dense_8h_source.html">sparse_to_dense.h</a>.</p>

</div>
</div>
<a id="aa442389b0a4b843c2e7b580b1c6c0452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa442389b0a4b843c2e7b580b1c6c0452">&#9670;&nbsp;</a></span>to_execution_space()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ExecutionSpace Space, typename T , typename HostAlloc , typename DeviceAlloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::to_execution_space </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1cpu__cuda__vector.html">cpu_cuda_vector</a>&lt; T, HostAlloc, DeviceAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cpu__cuda__vector_8h_source.html#l00170">170</a> of file <a class="el" href="cpu__cuda__vector_8h_source.html">cpu_cuda_vector.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_aa442389b0a4b843c2e7b580b1c6c0452_cgraph.png" border="0" usemap="#anamespace_tiled_array_aa442389b0a4b843c2e7b580b1c6c0452_cgraph" alt=""/></div>
<map name="namespace_tiled_array_aa442389b0a4b843c2e7b580b1c6c0452_cgraph" id="anamespace_tiled_array_aa442389b0a4b843c2e7b580b1c6c0452_cgraph">
<area shape="rect" title=" " alt="" coords="5,39,184,80"/>
<area shape="rect" href="class_tiled_array_1_1cpu__cuda__vector.html#a8c2aff2c0c790ca05273ae8121aed4ae" title="moves the data from the host to the device (even if it&#39;s there)" alt="" coords="232,5,389,47"/>
<area shape="rect" href="class_tiled_array_1_1cpu__cuda__vector.html#a304c08be616c40b825e19742acf654bc" title="moves the data from the device to the host (even if it&#39;s there)" alt="" coords="232,71,389,112"/>
<area shape="rect" href="class_tiled_array_1_1cpu__cuda__vector.html#a1e4be29bc5e236355922ab53221bac6b" title=" " alt="" coords="437,5,595,47"/>
<area shape="rect" href="class_tiled_array_1_1cpu__cuda__vector.html#a964c6d249f341c439f319e4bd765ced3" title=" " alt="" coords="437,71,595,112"/>
</map>
</div>

</div>
</div>
<a id="a5ef954fffe09fc2ffff5921bd107e0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef954fffe09fc2ffff5921bd107e0df">&#9670;&nbsp;</a></span>to_new_tile_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename ConvTile  = Tile, typename Policy , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) TiledArray::to_new_tile_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>old_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to convert an array to a new array with a different tile type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a></td><td>The array tile type </td></tr>
    <tr><td class="paramname">ConvTile</td><td>The tile type to which <a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> can be converted to and for which <code>Op(ConvTile)</code> is well-formed </td></tr>
    <tr><td class="paramname">Policy</td><td>The array policy type </td></tr>
    <tr><td class="paramname">Op</td><td>The tile conversion operation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array to be converted </td></tr>
    <tr><td class="paramname">op</td><td>The tile type conversion operation </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="to__new__tile__type_8h_source.html#l00071">71</a> of file <a class="el" href="to__new__tile__type_8h_source.html">to_new_tile_type.h</a>.</p>

</div>
</div>
<a id="a8957a8fceb6790b1ea9e5637728e0f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8957a8fceb6790b1ea9e5637728e0f66">&#9670;&nbsp;</a></span>to_sparse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename ResultPolicy  = SparsePolicy, typename ArgPolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt;ResultPolicy&gt; &amp;&amp; <a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt;ArgPolicy&gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, ResultPolicy&gt; &gt; TiledArray::to_sparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, ArgPolicy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>dense_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to convert a dense array into a block sparse array. </p>
<p>If the input array is dense then create a copy by checking the norms of the tiles in the dense array and then cloning the significant tiles into the sparse array. </p>

<p class="definition">Definition at line <a class="el" href="dense__to__sparse_8h_source.html#l00017">17</a> of file <a class="el" href="dense__to__sparse_8h_source.html">dense_to_sparse.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a8957a8fceb6790b1ea9e5637728e0f66_cgraph.png" border="0" usemap="#anamespace_tiled_array_a8957a8fceb6790b1ea9e5637728e0f66_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a8957a8fceb6790b1ea9e5637728e0f66_cgraph" id="anamespace_tiled_array_a8957a8fceb6790b1ea9e5637728e0f66_cgraph">
<area shape="rect" title="Function to convert a dense array into a block sparse array." alt="" coords="5,122,164,149"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a8f63920a51f61fd746fef31cc0a0929e" title="Begin iterator factory function." alt="" coords="227,5,385,47"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a8587157f8ad46d5da4f786b79110d0ab" title="End iterator factory function." alt="" coords="212,71,400,98"/>
<area shape="rect" href="group___tile_interface.html#gaf68ae245fa13091be35fcc8cad8b2ba6" title="Vector 2&#45;norm of a tile." alt="" coords="241,122,371,149"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="227,173,385,215"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor." alt="" coords="227,239,385,280"/>
</map>
</div>

</div>
</div>
<a id="a0cb8995bef009f9282891f14263dea8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb8995bef009f9282891f14263dea8c">&#9670;&nbsp;</a></span>to_sparse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt;Policy&gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy&gt; &gt; TiledArray::to_sparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>sparse_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the array is already sparse return a copy of the array. </p>

<p class="definition">Definition at line <a class="el" href="dense__to__sparse_8h_source.html#l00054">54</a> of file <a class="el" href="dense__to__sparse_8h_source.html">dense_to_sparse.h</a>.</p>

</div>
</div>
<a id="a10502bd5879f539420520f928f8bae2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10502bd5879f539420520f928f8bae2e">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = detail::enable_if_trace_is_defined_t&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) TiledArray::trace </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function for taking the trace of a tensor</p>
<p>This function works by creating a <a class="el" href="struct_tiled_array_1_1detail_1_1_trace.html">detail::Trace</a> instance for the given tile type, <code>T</code>. The implementation of the trace operation can be controlled by specializing Trace&lt;T&gt;. It simply returns the result of Trace&lt;T&gt;::operator()(const T&amp;)const verbatim.</p>
<p>This function only participates in overload resolution if <a class="el" href="namespace_tiled_array_1_1detail.html#a90b5d0dceea692165fc0b10fba571020">detail::trace_is_defined_v&lt;T&gt;</a> is true.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of tensor we are trying to take the trace of. </td></tr>
    <tr><td class="paramname">&lt;anonymous&gt;</td><td>Template type parameter used for SFINAE. Defaults to void when we know how to take the trace of a tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The tensor instance we want the trace of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The results of calling Trace&lt;T&gt;::operator() on <code>t</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>Any exceptions thrown by Trace&lt;T&gt;::operator() will also be thrown by this function with the same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="trace_8h_source.html#l00092">92</a> of file <a class="el" href="trace_8h_source.html">trace.h</a>.</p>

</div>
</div>
<a id="a4e56cc87496a69b06a7d21765b404aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e56cc87496a69b06a7d21765b404aa3">&#9670;&nbsp;</a></span>truncate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt;Policy&gt;, void&gt; TiledArray::truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Policy::shape_type::value_type&#160;</td>
          <td class="paramname"><em>thresh</em> = <code>Policy::shape_type::threshold()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncate a sparse Array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a></td><td>The tile type of <code>array</code> </td></tr>
    <tr><td class="paramname">Policy</td><td>The policy type of <code>array</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array</td><td>The array object to be truncated </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="truncate_8h_source.html#l00056">56</a> of file <a class="el" href="truncate_8h_source.html">truncate.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a4e56cc87496a69b06a7d21765b404aa3_cgraph.png" border="0" usemap="#anamespace_tiled_array_a4e56cc87496a69b06a7d21765b404aa3_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a4e56cc87496a69b06a7d21765b404aa3_cgraph" id="anamespace_tiled_array_a4e56cc87496a69b06a7d21765b404aa3_cgraph">
<area shape="rect" title="Truncate a sparse Array." alt="" coords="5,35,156,61"/>
<area shape="rect" href="group___tile_interface.html#gaf68ae245fa13091be35fcc8cad8b2ba6" title="Vector 2&#45;norm of a tile." alt="" coords="217,5,348,32"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor." alt="" coords="204,57,361,98"/>
</map>
</div>

</div>
</div>
<a id="ae9879b4e6b03e7be2b37f3b1e8c8a0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9879b4e6b03e7be2b37f3b1e8c8a0f8">&#9670;&nbsp;</a></span>truncate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt;Policy&gt;, void&gt; TiledArray::truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Policy::shape_type::value_type&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncate a dense Array. </p>
<p>This is a no-op </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a></td><td>The tile type of <code>array</code> </td></tr>
    <tr><td class="paramname">Policy</td><td>The policy type of <code>array</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array</td><td>The array object to be truncated </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="truncate_8h_source.html#l00046">46</a> of file <a class="el" href="truncate_8h_source.html">truncate.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ae9879b4e6b03e7be2b37f3b1e8c8a0f8_icgraph.png" border="0" usemap="#anamespace_tiled_array_ae9879b4e6b03e7be2b37f3b1e8c8a0f8_icgraph" alt=""/></div>
<map name="namespace_tiled_array_ae9879b4e6b03e7be2b37f3b1e8c8a0f8_icgraph" id="anamespace_tiled_array_ae9879b4e6b03e7be2b37f3b1e8c8a0f8_icgraph">
<area shape="rect" title="Truncate a dense Array." alt="" coords="225,46,376,73"/>
<area shape="rect" href="namespace_tiled_array.html#aa4eb781438f1d5ffec3f75b879ead8c0" title="Convert a btas::Tensor object into a TiledArray::DistArray object." alt="" coords="5,5,177,47"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a4c63ec23a819fe9537c9f09fe5ea3e66" title=" " alt="" coords="13,71,170,112"/>
</map>
</div>

</div>
</div>
<a id="aea673bd36f494b9b4c040ea0e09c00bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea673bd36f494b9b4c040ea0e09c00bd">&#9670;&nbsp;</a></span>volume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t TiledArray::volume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dist__array_8h_source.html#l01622">1622</a> of file <a class="el" href="dist__array_8h_source.html">dist_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_aea673bd36f494b9b4c040ea0e09c00bd_cgraph.png" border="0" usemap="#anamespace_tiled_array_aea673bd36f494b9b4c040ea0e09c00bd_cgraph" alt=""/></div>
<map name="namespace_tiled_array_aea673bd36f494b9b4c040ea0e09c00bd_cgraph" id="anamespace_tiled_array_aea673bd36f494b9b4c040ea0e09c00bd_cgraph">
<area shape="rect" title=" " alt="" coords="5,46,151,73"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a911b5f4183473c9c9300c370b90374df" title="Returns the number of tiles in the tensor." alt="" coords="199,5,356,47"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="199,71,356,112"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_aea673bd36f494b9b4c040ea0e09c00bd_icgraph.png" border="0" usemap="#anamespace_tiled_array_aea673bd36f494b9b4c040ea0e09c00bd_icgraph" alt=""/></div>
<map name="namespace_tiled_array_aea673bd36f494b9b4c040ea0e09c00bd_icgraph" id="anamespace_tiled_array_aea673bd36f494b9b4c040ea0e09c00bd_icgraph">
<area shape="rect" title=" " alt="" coords="827,1070,972,1097"/>
<area shape="rect" href="namespace_tiled_array.html#ac602cf7316f1296d1f59f76975f5cdfb" title="fuses a vector of DistArray objects, each with the same TiledRange into a DistArray with 1 more dimen..." alt="" coords="575,365,747,407"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a85557b284f443993530894acbb158b58" title="Get the inner size." alt="" coords="589,431,733,472"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#ac7c2574bd1506d0e811e2c0eb58fb1e3" title="In&#45;place tensor operations with contiguous data." alt="" coords="587,828,735,869"/>
<area shape="rect" href="namespace_tiled_array.html#a55a3b9976b8eacacfa0517e6bdc7c44d" title="collective bitwise&#45;compare&#45;reduce for SparseShape objects" alt="" coords="572,894,751,921"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#aa2d67872f963bb7a42d3f43872067148" title=" " alt="" coords="583,945,740,987"/>
<area shape="rect" href="struct_tiled_array_1_1math_1_1linalg_1_1_conjugate_gradient_solver.html#a76d41343afbc8d219dcaafb4ab32a64e" title=" " alt="" coords="565,1011,758,1067"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_dist_eval_impl.html#aa6e0cd9cb5b159f7dd1434976de5cd59" title="Permute index from a target index to a source index." alt="" coords="544,1092,779,1163"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_dist_eval_impl.html#a6a707d3b0ec4aad1f3bafb2ab237310f" title="Permute index from a source index to a target index." alt="" coords="546,1187,777,1257"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_perm_index.html#ab54930056c8997aa0c41fbb37fc4175e" title="Construct permuting functor." alt="" coords="572,1281,751,1323"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a3f41e1794be8e3f5515437c8301585a9" title="Construct a permuted tensor copy." alt="" coords="595,1347,728,1388"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a688f0fd56017f86cec0a631a0b967706" title="deserialize local contents of a DistArray from an Archive object" alt="" coords="583,1412,740,1453"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#ac3cdc1442eaf288a10279190d87d0461" title="Stores this array to an Archive object." alt="" coords="583,1507,740,1548"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a2fa32053a2cef8c73b71763a0e01cd95" title="Initialize tensor with contiguous tensor arguments." alt="" coords="595,496,728,537"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#ab957a79bba9735ad3e405dbb8dd53796" title="Reduction operation for contiguous tensors." alt="" coords="595,1589,728,1631"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a91ec4c7e7bd4d19b11f0674903ce630a" title="Get the inner size of two tensors." alt="" coords="307,136,440,177"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#affe584326250186e9764756598f7eefd" title="Use a binary, element wise operation to construct a new, permuted tensor." alt="" coords="15,5,193,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aebc5c8b00cc397f5ba32ea426d1ddcc3" title=" " alt="" coords="7,201,201,243"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#ac5132fe4d73d49d24d2dcd60f06849f9" title="Initialize tensor with one or more non&#45;contiguous tensor arguments." alt="" coords="37,71,171,112"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aab51b68f811fbe0fbb29909202ad3b30" title="Use a unary, element wise operation to construct a new, permuted tensor." alt="" coords="17,136,191,177"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a272585651b1233bb8f90d23c88a12c61" title="Use a binary, element wise operation to modify this tensor." alt="" coords="284,629,463,685"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aedf1dc6f6754af31fdfcc8ee86b0c73d" title="Use a binary, element wise operation to modify this tensor." alt="" coords="281,709,466,765"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#af23df0d855cd33e6e977bd39e780ca9a" title="Use a unary, element wise operation to modify this tensor." alt="" coords="262,789,485,831"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a8cc4b0e0e82ab58dad40a01b4530b94b" title="Use a unary, element wise operation to modify this tensor." alt="" coords="259,855,488,896"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a864d3eed3caa265526a36b1e042aaeb9" title=" " alt="" coords="274,920,473,961"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a70f6e8ca6afdfd889fac691a39f7a57e" title=" " alt="" coords="271,985,475,1027"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html#a6f2e00b7e50f7ba5858e3fa472d3e917" title="Assignment operator." alt="" coords="279,1051,467,1092"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a2d65efd4c6093a5373e836d74619b738" title="Add other to this tensor." alt="" coords="13,659,195,700"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a2cd3d6f515b31751c9fcc26e48f2e3ed" title="Multiply this tensor by right." alt="" coords="10,724,198,765"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a69ca8d8ac4237fb53887d69ffc4c5225" title="Subtract right from this tensor." alt="" coords="11,789,197,831"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a5c3cfbd8b10ff2801543f4584d753a5f" title="Add a constant to this tensor." alt="" coords="13,855,195,896"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ae8094e4b120557459a28f1f21513f774" title="Negate elements of this tensor." alt="" coords="13,920,195,961"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#afdf25cc0015b6214fac0682074137d33" title="Scale this tensor." alt="" coords="8,985,200,1027"/>
<area shape="rect" href="structmadness_1_1archive_1_1_archive_load_impl_3_01_parallel_input_archive_00_01_tiled_array_1_127f6223a4fbe7d043e5343ca6e61407e.html#a665594267ce09e80cb90991d42dfa099" title=" " alt="" coords="258,1116,489,1187"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#af174120ffd75a14d13077eff16452d9b" title="In&#45;place tensor permutation operations with contiguous data." alt="" coords="299,1211,447,1252"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_contract_reduce.html#a3edb113a3e4524ffa21985587b0b7311" title="Post processing step." alt="" coords="259,1276,488,1405"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a2788b8e3e27331097aa656a0e6e36b20" title="Initialize tensor with permuted tensor arguments." alt="" coords="307,1429,440,1471"/>
<area shape="rect" href="structmadness_1_1archive_1_1_archive_store_impl_3_01_parallel_output_archive_00_01_tiled_array_18f4819b6a225b588aa7a90efa190e9ec.html#aca7ab27b4099ef3cff1bcaff1ff0d3d5" title=" " alt="" coords="251,1495,496,1565"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ae11a9e70ba98eccc31ef6b8a265cc369" title="Use a binary, element wise operation to construct a new tensor." alt="" coords="284,364,463,405"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#ad06d56e445f36d572109abbafc1a32e5" title="Construct a tensor with a fill value." alt="" coords="286,463,461,504"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ae5f80c1e7c2e5855313fad6ad10375b3" title="Use a unary, element wise operation to construct a new tensor." alt="" coords="286,528,461,569"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a0ef9fb1d4cd22af3bb02002209eb31f0" title="Add this and other to construct a new tensors." alt="" coords="23,267,185,308"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#af0e2f37b46d3c3c0fcc3ab77d8594b6f" title="Multiply this by right to create a new tensor." alt="" coords="20,332,188,373"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a8361c0f82bfdfcf468247cf566c87a89" title="Subtract this and right to construct a new tensor." alt="" coords="21,397,187,439"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a31362893bb066fe8568529f881028611" title="Add a constant to a copy of this tensor." alt="" coords="23,463,185,504"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a115f6c8f776a9d58a238dfc810758b34" title="Create a negated copy of this tensor." alt="" coords="23,528,185,569"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a4738cdadac53a8979ffb09d1409e0a1e" title="Construct a scaled copy of this tensor." alt="" coords="18,593,190,635"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aad1e3e351ce4d80310c368f77375198c" title="Unary reduction operation." alt="" coords="282,1589,465,1631"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#ac7e2825494e7578e27becf11d2a6b794" title="Unary reduction operation." alt="" coords="285,1655,461,1696"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aadf392a65c7edfe026984dc11b0d47d8" title="Absolute maximum element." alt="" coords="5,1589,203,1631"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="abf38dec6e494f090575f45ea9f5234c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf38dec6e494f090575f45ea9f5234c5">&#9670;&nbsp;</a></span>initializer_list_rank_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeType  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto TiledArray::initializer_list_rank_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    InitializerListRank&lt;T, SizeType&gt;::value</div>
</div><!-- fragment -->
<p>Helper variable for retrieving the degree of nesting for an std::initializer_list. </p>
<p>This helper variable creates a global variable which contains the value of InitializerListRank&lt;T, SizeType&gt; and is intended to be used as a (more) convenient means of retrieving the value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type we are analyzing for its std::initializer_list-nested-ness </td></tr>
    <tr><td class="paramname">SizeType</td><td>the type to use for the <code>value</code> member. Defaults to <code>std::size_t</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="initializer__list_8h_source.html#l00071">71</a> of file <a class="el" href="initializer__list_8h_source.html">initializer_list.h</a>.</p>

</div>
</div>
<a id="ad73c8b5fc3cf99546cf08ec8c8d755fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73c8b5fc3cf99546cf08ec8c8d755fd">&#9670;&nbsp;</a></span>is_dense_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::is_dense_v = <a class="el" href="struct_tiled_array_1_1is__dense.html">is_dense</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="shape_8h_source.html#l00047">47</a> of file <a class="el" href="shape_8h_source.html">shape.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespace_tiled_array_1_1detail_html_a8a4894269f42087aba45c572ad95aae0"><div class="ttname"><a href="namespace_tiled_array_1_1detail.html#a8a4894269f42087aba45c572ad95aae0">TiledArray::detail::value_t</a></div><div class="ttdeci">remove_cvr_t&lt; decltype(*std::begin(std::declval&lt; T &amp; &gt;()))&gt; value_t</div><div class="ttdef"><b>Definition:</b> <a href="type__traits_8h_source.html#l01113">type_traits.h:1113</a></div></div>
<div class="ttc" id="anamespace_tiled_array_html_aeefaad05a6d604d7013a5f96d2b28888"><div class="ttname"><a href="namespace_tiled_array.html#aeefaad05a6d604d7013a5f96d2b28888">TiledArray::push_default_world</a></div><div class="ttdeci">std::unique_ptr&lt; World, decltype(world_resetter)&gt; push_default_world(World &amp;world)</div><div class="ttdef"><b>Definition:</b> <a href="madness_8h_source.html#l00117">madness.h:117</a></div></div>
<div class="ttc" id="anamespace_tiled_array_html_abb0c4ccd3689f4dafb20c6d238690705"><div class="ttname"><a href="namespace_tiled_array.html#abb0c4ccd3689f4dafb20c6d238690705">TiledArray::TSpArrayD</a></div><div class="ttdeci">TSpArray&lt; double &gt; TSpArrayD</div><div class="ttdef"><b>Definition:</b> <a href="tiledarray__fwd_8h_source.html#l00105">tiledarray_fwd.h:105</a></div></div>
<div class="ttc" id="aclass_tiled_array_1_1_tensor_html_af23df0d855cd33e6e977bd39e780ca9a"><div class="ttname"><a href="class_tiled_array_1_1_tensor.html#af23df0d855cd33e6e977bd39e780ca9a">TiledArray::Tensor::inplace_unary</a></div><div class="ttdeci">Tensor_ &amp; inplace_unary(Op &amp;&amp;op)</div><div class="ttdoc">Use a unary, element wise operation to modify this tensor.</div><div class="ttdef"><b>Definition:</b> <a href="tensor_2tensor_8h_source.html#l01062">tensor.h:1062</a></div></div>
<div class="ttc" id="anamespace_tiled_array_html_a8bb41dd83ecdc33052c9c02eeda152e8"><div class="ttname"><a href="namespace_tiled_array.html#a8bb41dd83ecdc33052c9c02eeda152e8">TiledArray::get_default_world</a></div><div class="ttdeci">World &amp; get_default_world()</div><div class="ttdef"><b>Definition:</b> <a href="madness_8h_source.html#l00090">madness.h:90</a></div></div>
<div class="ttc" id="anamespace_tiled_array_html_ae732935e243d742f37911ca9592ab851"><div class="ttname"><a href="namespace_tiled_array.html#ae732935e243d742f37911ca9592ab851">TiledArray::array_to_btas_tensor</a></div><div class="ttdeci">btas::Tensor&lt; typename Tile::value_type, btas::DEFAULT::range, Storage &gt; array_to_btas_tensor(const TiledArray::DistArray&lt; Tile, Policy &gt; &amp;src, int target_rank=-1)</div><div class="ttdoc">Convert a TiledArray::DistArray object into a btas::Tensor object.</div><div class="ttdef"><b>Definition:</b> <a href="conversions_2btas_8h_source.html#l00301">btas.h:301</a></div></div>
<div class="ttc" id="aclass_tiled_array_1_1_tiled_range_html"><div class="ttname"><a href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a></div><div class="ttdoc">Range data of a tiled array.</div><div class="ttdef"><b>Definition:</b> <a href="tiled__range_8h_source.html#l00032">tiled_range.h:32</a></div></div>
<div class="ttc" id="aclass_tiled_array_1_1_dist_array_html"><div class="ttname"><a href="class_tiled_array_1_1_dist_array.html">TiledArray::DistArray</a></div><div class="ttdoc">Forward declarations.</div><div class="ttdef"><b>Definition:</b> <a href="dist__array_8h_source.html#l00057">dist_array.h:57</a></div></div>
<div class="ttc" id="aclass_tiled_array_1_1_tensor_html"><div class="ttname"><a href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a></div><div class="ttdoc">An N-dimensional tensor object.</div><div class="ttdef"><b>Definition:</b> <a href="tensor_2tensor_8h_source.html#l00050">tensor.h:50</a></div></div>
<div class="ttc" id="anamespace_tiled_array_html_acd1b198e655d9877e8251a2cfc50c70b"><div class="ttname"><a href="namespace_tiled_array.html#acd1b198e655d9877e8251a2cfc50c70b">TiledArray::concat</a></div><div class="ttdeci">TiledRange1 concat(const TiledRange1 &amp;r1, const TiledRange1 &amp;r2)</div><div class="ttdoc">Concatenates two ranges.</div><div class="ttdef"><b>Definition:</b> <a href="tiled__range1_8h_source.html#l00339">tiled_range1.h:339</a></div></div>
<div class="ttc" id="aclass_tiled_array_1_1_tiled_range1_html"><div class="ttname"><a href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a></div><div class="ttdef"><b>Definition:</b> <a href="tiled__range1_8h_source.html#l00050">tiled_range1.h:50</a></div></div>
<div class="ttc" id="anamespace_tiled_array_html_ad4ffc6de9b633a34e7d724191cd11f3f"><div class="ttname"><a href="namespace_tiled_array.html#ad4ffc6de9b633a34e7d724191cd11f3f">TiledArray::array_to_eigen</a></div><div class="ttdeci">Eigen::Matrix&lt; typename Tile::value_type, Eigen::Dynamic, Eigen::Dynamic, EigenStorageOrder &gt; array_to_eigen(const DistArray&lt; Tile, Policy &gt; &amp;array)</div><div class="ttdoc">Convert an Array object into an Eigen matrix object.</div><div class="ttdef"><b>Definition:</b> <a href="conversions_2eigen_8h_source.html#l00496">eigen.h:496</a></div></div>
<div class="ttc" id="aclass_tiled_array_1_1_range_html"><div class="ttname"><a href="class_tiled_array_1_1_range.html">TiledArray::Range</a></div><div class="ttdoc">A (hyperrectangular) interval on , space of integer -indices.</div><div class="ttdef"><b>Definition:</b> <a href="range_8h_source.html#l00046">range.h:46</a></div></div>

<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
    Generated at Sat Apr 24 2021 05:44:22 for <a href="https://https://github.com/ValeevGroup/tiledarray/">TiledArray</a>
    1.0.0 by &#160;<a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.20
</small></address>
</body>
<script type="text/javascript" src="doxy-boot.js"></script>
</html>
