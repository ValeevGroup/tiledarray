<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.20"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>TiledArray: TiledArray::detail Namespace Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
        <script type="text/javascript" src="jquery.smartmenus.js"></script>
        <!-- SmartMenus jQuery Bootstrap Addon -->
        <script type="text/javascript" src="jquery.smartmenus.bootstrap.js"></script>
        <!-- SmartMenus jQuery plugin -->
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">TiledArray 1.0.0</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="userguide.html"><span>User&#160;Guide</span></a></li>
      <li><a href="usergroup0.html"><span>Programmer&#160;Guides</span></a></li>
      <li class="current"><a href="usergroup1.html"><span>Source&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_tiled_array.html">TiledArray</a></li><li class="navelem"><a class="el" href="namespace_tiled_array_1_1detail.html">detail</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">TiledArray::detail Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1absolute__value.html">absolute_value</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_add.html">Add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> addition operation.  <a href="class_tiled_array_1_1detail_1_1_add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_argument_helper.html">ArgumentHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_argument_helper_3_01_future_3_01_t_01_4_01_4.html">ArgumentHelper&lt; Future&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_argument_helper_3_01std_1_1pair_3_01_future_3_01_t_01_4_00_01_future_3_01_u_01_4_01_4_01_4.html">ArgumentHelper&lt; std::pair&lt; Future&lt; T &gt;, Future&lt; U &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_array_eval_impl.html">ArrayEvalImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed evaluator for <code><a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">TiledArray::Array</a></code> objects.  <a href="class_tiled_array_1_1detail_1_1_array_eval_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_array_impl.html">ArrayImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> implementation and base for other tensor implementation objects.  <a href="class_tiled_array_1_1detail_1_1_array_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_array_iterator.html">ArrayIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed tensor iterator.  <a href="class_tiled_array_1_1detail_1_1_array_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_backtrace.html">Backtrace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_binary_eval_impl.html">BinaryEvalImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary, distributed tensor evaluator.  <a href="class_tiled_array_1_1detail_1_1_binary_eval_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_binary_transform_iterator.html">BinaryTransformIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary transform iterator.  <a href="class_tiled_array_1_1detail_1_1_binary_transform_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_binary_wrapper.html">BinaryWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary tile operation wrapper.  <a href="class_tiled_array_1_1detail_1_1_binary_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed size bitset.  <a href="class_tiled_array_1_1detail_1_1_bitset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_blocked_pmap.html">BlockedPmap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A blocked process map.  <a href="class_tiled_array_1_1detail_1_1_blocked_pmap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_can_make_random.html">CanMakeRandom</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_can_make_random_3_01double_01_4.html">CanMakeRandom&lt; double &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables generating random double values.  <a href="struct_tiled_array_1_1detail_1_1_can_make_random_3_01double_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_can_make_random_3_01float_01_4.html">CanMakeRandom&lt; float &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables generating random float values.  <a href="struct_tiled_array_1_1detail_1_1_can_make_random_3_01float_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_can_make_random_3_01int_01_4.html">CanMakeRandom&lt; int &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables generating random int values.  <a href="struct_tiled_array_1_1detail_1_1_can_make_random_3_01int_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_can_make_random_3_01std_1_1complex_3_01double_01_4_01_4.html">CanMakeRandom&lt; std::complex&lt; double &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables generating random std::complex&lt;double&gt; values.  <a href="struct_tiled_array_1_1detail_1_1_can_make_random_3_01std_1_1complex_3_01double_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_can_make_random_3_01std_1_1complex_3_01float_01_4_01_4.html">CanMakeRandom&lt; std::complex&lt; float &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables generating random std::complex&lt;float&gt; values.  <a href="struct_tiled_array_1_1detail_1_1_can_make_random_3_01std_1_1complex_3_01float_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1cast__then__op.html">cast_then_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1cast__then__op_3_01_dst_tile_00_01_src_tile_00_01_op_00_01std_1_27a0cd6cdf824158182fd2fcb5e9765d.html">cast_then_op&lt; DstTile, SrcTile, Op, std::enable_if_t&lt;!std::is_same&lt; DstTile, SrcTile &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1cast__then__op_3_01_tile_00_01_tile_00_01_op_00_01void_01_4.html">cast_then_op&lt; Tile, Tile, Op, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate_3_01_complex_neg_tag_01_4.html">ComplexConjugate&lt; ComplexNegTag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate_3_01void_01_4.html">ComplexConjugate&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a><s> for the case of a unit/identity factor. </s> <a href="class_tiled_array_1_1detail_1_1_complex_conjugate_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_complex_neg_tag.html">ComplexNegTag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_contract_reduce.html">ContractReduce</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract and (sum) reduce operation.  <a href="class_tiled_array_1_1detail_1_1_contract_reduce.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_contract_reduce_3_01_result_00_01_left_00_01_right_00_01_tiled_ac747358d5737d2beb853a2e1d5509b1f.html">ContractReduce&lt; Result, Left, Right, TiledArray::detail::ComplexConjugate&lt; Scalar &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract and reduce operation.  <a href="class_tiled_array_1_1detail_1_1_contract_reduce_3_01_result_00_01_left_00_01_right_00_01_tiled_ac747358d5737d2beb853a2e1d5509b1f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_contract_reduce_3_01_result_00_01_left_00_01_right_00_01_tiled_a9a56f685ff213c256976617604736135.html">ContractReduce&lt; Result, Left, Right, TiledArray::detail::ComplexConjugate&lt; void &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract and (sum) reduce operation.  <a href="class_tiled_array_1_1detail_1_1_contract_reduce_3_01_result_00_01_left_00_01_right_00_01_tiled_a9a56f685ff213c256976617604736135.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_contract_reduce_base.html">ContractReduceBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract and (sum) reduce base.  <a href="class_tiled_array_1_1detail_1_1_contract_reduce_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_cyclic_pmap.html">CyclicPmap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps cyclically a sequence of indices onto a 2-d matrix of processes.  <a href="class_tiled_array_1_1detail_1_1_cyclic_pmap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1default__permutation.html">default_permutation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">detect cuda tile  <a href="struct_tiled_array_1_1detail_1_1default__permutation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1default__permutation_3_01_tensor_00_01std_1_1enable__if__t_3_01ib2fa7ed022ceae5d0fe1d9896f5af87d.html">default_permutation&lt; Tensor, std::enable_if_t&lt; is_tensor_of_tensor_v&lt; Tensor &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1default__permutation_3_01_tensor_00_01std_1_1enable__if__t_3_9isc2b81fa673377a2dbd1b889fdaec942f.html">default_permutation&lt; Tensor, std::enable_if_t&lt;!is_tensor_of_tensor_v&lt; Tensor &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1default__world.html">default_world</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1dist__subarray__vec.html">dist_subarray_vec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">global view of a tilewise-round-robin distributed std::vector of Arrays  <a href="class_tiled_array_1_1detail_1_1dist__subarray__vec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_dist_eval.html">DistEval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> expression object.  <a href="class_tiled_array_1_1detail_1_1_dist_eval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_dist_eval_impl.html">DistEvalImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed evaluator implementation object.  <a href="class_tiled_array_1_1detail_1_1_dist_eval_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_distributed_storage.html">DistributedStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed storage container.  <a href="class_tiled_array_1_1detail_1_1_distributed_storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1eval__trait__base.html">eval_trait_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1eval__trait__base_3_01_t_00_01typename_01std_1_1enable__if_3_01haf03a5632a5411c05658071b9b5c7ffa.html">eval_trait_base&lt; T, typename std::enable_if&lt; has_member_type_eval_type&lt; T &gt;::value &amp;&amp;(detail::is_explicitly_convertible&lt; T, typename T::eval_type &gt;::value||detail::is_explicitly_convertible&lt; T, madness::Future&lt; typename T::eval_type &gt;&gt;::value||detail::is_implicitly_convertible&lt; T, typename T::eval_type &gt;::value||detail::is_implicitly_convertible&lt; T, madness::Future&lt; typename T::eval_type &gt;&gt;::value)&gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1has__conversion__operator.html">has_conversion_operator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1has__conversion__operator_3_01_from_00_01_to_00_01typename_01std718e73a5439d660cc9a7377523f11d0a.html">has_conversion_operator&lt; From, To, typename std::enable_if&lt; is_type&lt; decltype(std::declval&lt; From &gt;().operator To &amp;())&gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1has__conversion__operator_3_01_from_00_01_to_00_01typename_01std8732e964c6c1a9becba684003f3cf24b.html">has_conversion_operator&lt; From, To, typename std::enable_if&lt; is_type&lt; decltype(std::declval&lt; From &gt;().operator To())&gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_hash_pmap.html">HashPmap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashed process map.  <a href="class_tiled_array_1_1detail_1_1_hash_pmap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__array.html">is_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__array_3_01_dist_array_3_01_t_00_01_p_01_4_01_4.html">is_array&lt; DistArray&lt; T, P &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__array__tile.html">is_array_tile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect tiles used by <code><a class="el" href="class_tiled_array_1_1detail_1_1_array_eval_impl.html" title="Distributed evaluator for TiledArray::Array objects.">ArrayEvalImpl</a></code>.  <a href="struct_tiled_array_1_1detail_1_1is__array__tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__array__tile_3_01_tiled_array_1_1detail_1_1_lazy_array_tile_3_01_t_00_01_op_01_4_01_4.html">is_array_tile&lt; TiledArray::detail::LazyArrayTile&lt; T, Op &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__bidirectional__iterator.html">is_bidirectional_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__boost__gettable.html">is_boost_gettable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__boost__gettable_3_01_i_00_01_t_00_01std_1_1void__t_3_01declt6658c6a86c9758c6d4c7c545f6e7e140.html">is_boost_gettable&lt; I, T, std::void_t&lt; decltype(::boost::get&lt; I &gt;(std::declval&lt; const T &amp; &gt;()))&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__btas__tensor.html">is_btas_tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__btas__tensor_3_01btas_1_1_tensor_3_01_t_00_01_args_8_8_8_01_4_01_4.html">is_btas_tensor&lt; btas::Tensor&lt; T, Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__complete__type.html">is_complete_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper to implement other metafunctions <code>is_complete_type&lt;T&gt;::value</code> is true if <code>T</code> is a complete type  <a href="struct_tiled_array_1_1detail_1_1is__complete__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__complete__type_3_01_t_00_01decltype_07void_07sizeof_07_t_08_08_08_4.html">is_complete_type&lt; T, decltype(void(sizeof(T)))&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__complete__type_3_01void_01_4.html">is_complete_type&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__complex.html">is_complex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__complex_3_01std_1_1complex_3_01_t_01_4_01_4.html">is_complex&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__range.html">is_contiguous_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__range_3_01_t_00_01std_1_1void__t_3_01decltype_076979b55480a0f2e36cf4d1aa849147da.html">is_contiguous_range&lt; T, std::void_t&lt; decltype(std::data(std::declval&lt; T &amp; &gt;()))&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__range__helper.html">is_contiguous_range_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__range__helper_3_01_range_01_4.html">is_contiguous_range_helper&lt; Range &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor.html">is_contiguous_tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor_3_01_t_01_4.html">is_contiguous_tensor&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor_3_01_t1_00_01_t2_00_01_ts_8_8_8_01_4.html">is_contiguous_tensor&lt; T1, T2, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor_3_4.html">is_contiguous_tensor&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor__helper.html">is_contiguous_tensor_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor__helper_3_01btas_1_1_tensor_3_01_t_00_01_args_8_8_8_01_4_01_4.html">is_contiguous_tensor_helper&lt; btas::Tensor&lt; T, Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor__helper_3_01_shift_wrapper_3_01_t_01_4_01_4.html">is_contiguous_tensor_helper&lt; ShiftWrapper&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor__helper_3_01_tensor_3_01_t_00_01_a_01_4_01_4.html">is_contiguous_tensor_helper&lt; Tensor&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor__helper_3_01_tensor_interface_3_01_t_00_01_r_00_01_op_result_01_4_01_4.html">is_contiguous_tensor_helper&lt; TensorInterface&lt; T, R, OpResult &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor__helper_3_01_tile_3_01_t_01_4_01_4.html">is_contiguous_tensor_helper&lt; Tile&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__convertible.html">is_convertible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__explicitly__convertible.html">is_explicitly_convertible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__forward__iterator.html">is_forward_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__gettable__pair.html">is_gettable_pair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__gettable__pair_3_01_t_00_01std_1_1enable__if__t_3_01is__gettd034b149ff0d7cc9fd0d15bd99eceb83.html">is_gettable_pair&lt; T, std::enable_if_t&lt; is_gettable_v&lt; 0, T &gt; &amp;&amp;is_gettable_v&lt; 1, T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__gpair__range.html">is_gpair_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__gpair__range_3_01_t_00_01std_1_1enable__if__t_3_01is__gpair_2cf53d5c80abc29cc92743fd1a2771a5.html">is_gpair_range&lt; T, std::enable_if_t&lt; is_gpair_v&lt; value_t&lt; T &gt; &gt; &amp;&amp;is_range_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__implicitly__convertible.html">is_implicitly_convertible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__initializer__list.html">is_initializer_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template for detecting if <code>T</code> is an std::initializer_list.  <a href="struct_tiled_array_1_1detail_1_1is__initializer__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__initializer__list_3_01std_1_1initializer__list_3_01_t_01_4_01_4.html">is_initializer_list&lt; std::initializer_list&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="struct_tiled_array_1_1detail_1_1is__initializer__list.html" title="Primary template for detecting if T is an std::initializer_list.">is_initializer_list</a> for an std::initializer_list.  <a href="struct_tiled_array_1_1detail_1_1is__initializer__list_3_01std_1_1initializer__list_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__input__iterator.html">is_input_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__list.html">is_integral_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__list__helper.html">is_integral_list_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__list__helper_3_01_t_00_01_ts_8_8_8_01_4.html">is_integral_list_helper&lt; T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__list__helper_3_4.html">is_integral_list_helper&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__pair.html">is_integral_pair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__pair__.html">is_integral_pair_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__pair___3_01std_1_1pair_3_01_t1_00_01_t2_01_4_00_01929d82b290f47b7b6ae4b08beac9d756.html">is_integral_pair_&lt; std::pair&lt; T1, T2 &gt;, typename std::enable_if&lt; std::is_integral&lt; T1 &gt;::value &amp;&amp;std::is_integral&lt; T2 &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__pair__list.html">is_integral_pair_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__pair__list__helper.html">is_integral_pair_list_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__pair__list__helper_3_01_t_00_01_ts_8_8_8_01_4.html">is_integral_pair_list_helper&lt; T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__pair__list__helper_3_4.html">is_integral_pair_list_helper&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__range.html">is_integral_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__range_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1970eb0f3e89ee2fab8c3b89c7dab62d6.html">is_integral_range&lt; T, std::enable_if_t&lt; std::is_integral_v&lt; value_t&lt; T &gt; &gt; &amp;&amp;is_range_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__sized__range.html">is_integral_sized_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__sized__range_3_01_t_00_01std_1_1enable__if__t_3_01ab7e3ddc1dcd184ff26fad6461680f33.html">is_integral_sized_range&lt; T, std::enable_if_t&lt; std::is_integral_v&lt; value_t&lt; T &gt; &gt; &amp;&amp;is_sized_range_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__tuple.html">is_integral_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__tuple_3_01std_1_1tuple_3_01_ts_8_8_8_01_4_01_4.html">is_integral_tuple&lt; std::tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__invocable.html">is_invocable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__invocable__r.html">is_invocable_r</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__invocable__void.html">is_invocable_void</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__invocable__void__helper.html">is_invocable_void_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__invocable__void__helper_3_01std_1_1enable__if__t_3_01std_1_1d1bbde809e7064c83eca132e3fd3a7ce.html">is_invocable_void_helper&lt; std::enable_if_t&lt; std::is_void&lt; std::result_of_t&lt; F(Args...)&gt; &gt;::value, void &gt;, F, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator.html">is_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator_3_01const_01_t_01_5_00_01void_01_4.html">is_iterator&lt; const T *, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator_3_01const_01_t_01_5const_00_01void_01_4.html">is_iterator&lt; const T *const, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator_3_01_t_01_5_00_01void_01_4.html">is_iterator&lt; T *, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator_3_01_t_01_5const_00_01void_01_4.html">is_iterator&lt; T *const, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator_3_01_t_00_01typename_01std_1_1enable__if_3_01has__m665d2b3bafc083e46c25939cb2cd2486.html">is_iterator&lt; T, typename std::enable_if&lt; has_member_type_iterator_category&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__non__array__lazy__tile.html">is_non_array_lazy_tile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect a lazy evaluation tile that are not a <code><a class="el" href="class_tiled_array_1_1detail_1_1_lazy_array_tile.html" title="Lazy tile for on-the-fly evaluation of array tiles.">LazyArrayTile</a></code>.  <a href="struct_tiled_array_1_1detail_1_1is__non__array__lazy__tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__numeric.html">is_numeric</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__numeric_3_01bool_01_4.html">is_numeric&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__numeric_3_01_complex_conjugate_3_01_s_01_4_01_4.html">is_numeric&lt; ComplexConjugate&lt; S &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__numeric_3_01std_1_1complex_3_01_t_01_4_01_4.html">is_numeric&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__output__iterator.html">is_output_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__pair.html">is_pair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__pair_3_01std_1_1pair_3_01_t1_00_01_t2_01_4_01_4.html">is_pair&lt; std::pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__permutation.html">is_permutation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__permutation_3_01_tiled_array_1_1_bipartite_permutation_01_4.html">is_permutation&lt; TiledArray::BipartitePermutation &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__permutation_3_01_tiled_array_1_1_permutation_01_4.html">is_permutation&lt; TiledArray::Permutation &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__permutation_3_01_tiled_array_1_1symmetry_1_1_permutation_01_4.html">is_permutation&lt; TiledArray::symmetry::Permutation &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__random__iterator.html">is_random_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__range.html">is_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__range_3_01_t_00_01std_1_1void__t_3_01decltype_07std_1_1begin3872b273666256023916e0a63ef935b8.html">is_range&lt; T, std::void_t&lt; decltype(std::begin(std::declval&lt; T &amp; &gt;()), std::end(std::declval&lt; T &amp; &gt;()))&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__reduce__op__.html">is_reduce_op_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__reduce__op___3_01std_1_1void__t_3_01decltype_07std_1_1declvae8fa8726cfc76a5bef955a373cfa7361.html">is_reduce_op_&lt; std::void_t&lt; decltype(std::declval&lt; ReduceOp &amp; &gt;()(std::declval&lt; Result &amp; &gt;(), std::declval&lt; const Args * &gt;()...))&gt;, ReduceOp, Result, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__same__or__derived.html">is_same_or_derived</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__scalar.html">is_scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__scalar_3_01std_1_1complex_3_01_t_01_4_01_4.html">is_scalar&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted.html">is_shifted</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted_3_01_t_01_4.html">is_shifted&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted_3_01_t1_00_01_t2_00_01_ts_8_8_8_01_4.html">is_shifted&lt; T1, T2, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted_3_4.html">is_shifted&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted__helper.html">is_shifted_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted__helper_3_01_shift_wrapper_3_01_t_01_4_01_4.html">is_shifted_helper&lt; ShiftWrapper&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__sized__range.html">is_sized_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__sized__range_3_01_t_00_01std_1_1void__t_3_01decltype_07std_170ba815a4e07eb4fbecd445a1735e24b.html">is_sized_range&lt; T, std::void_t&lt; decltype(std::size(std::declval&lt; T &amp; &gt;()))&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__std__gettable.html">is_std_gettable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__std__gettable_3_01_i_00_01_t_00_01std_1_1void__t_3_01decltyp281e6ec0ea5eabcc95614540b4178d64.html">is_std_gettable&lt; I, T, std::void_t&lt; decltype(::std::get&lt; I &gt;(std::declval&lt; const T &amp; &gt;()))&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__strictly__ordered.html">is_strictly_ordered</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__strictly__ordered__helper.html">is_strictly_ordered_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__ta__tensor.html">is_ta_tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__ta__tensor_3_01_tensor_3_01_t_00_01_a_01_4_01_4.html">is_ta_tensor&lt; Tensor&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor.html">is_tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor_3_01_t_01_4.html">is_tensor&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor_3_01_t1_00_01_t2_00_01_ts_8_8_8_01_4.html">is_tensor&lt; T1, T2, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor_3_4.html">is_tensor&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__helper.html">is_tensor_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__helper_3_01btas_1_1_tensor_3_01_t_00_01_args_8_8_8_01_4_01_4.html">is_tensor_helper&lt; btas::Tensor&lt; T, Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__helper_3_01_shift_wrapper_3_01const_01_t_01_4_01_4.html">is_tensor_helper&lt; ShiftWrapper&lt; const T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__helper_3_01_shift_wrapper_3_01_t_01_4_01_4.html">is_tensor_helper&lt; ShiftWrapper&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__helper_3_01_tensor_3_01_t_00_01_a_01_4_01_4.html">is_tensor_helper&lt; Tensor&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__helper_3_01_tensor_interface_3_01_args_8_8_8_01_4_01_4.html">is_tensor_helper&lt; TensorInterface&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__helper_3_01_tile_3_01_t_01_4_01_4.html">is_tensor_helper&lt; Tile&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor.html">is_tensor_of_tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor_3_01_t_01_4.html">is_tensor_of_tensor&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor_3_01_t1_00_01_t2_00_01_ts_8_8_8_01_4.html">is_tensor_of_tensor&lt; T1, T2, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor_3_4.html">is_tensor_of_tensor&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor__helper.html">is_tensor_of_tensor_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor__helper_3_01_shift_wrapper_3_01_t_01_4_01_4.html">is_tensor_of_tensor_helper&lt; ShiftWrapper&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor__helper_3_01_tensor_3_01_t_00_01_a_01_4_01_4.html">is_tensor_of_tensor_helper&lt; Tensor&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor__helper_3_01_tensor_interface_3_01_t_00_01_args_8_8_8_01_4_01_4.html">is_tensor_of_tensor_helper&lt; TensorInterface&lt; T, Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor__helper_3_01_tile_3_01_t_01_4_01_4.html">is_tensor_of_tensor_helper&lt; Tile&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tuple.html">is_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tuple_3_01std_1_1tuple_3_01_ts_8_8_8_01_4_01_4.html">is_tuple&lt; std::tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__type.html">is_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper to implement other metafunctions <code>is_type&lt;T&gt;::value</code> is true if <code>T</code> is a valid type  <a href="struct_tiled_array_1_1detail_1_1is__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_lazy_array_tile.html">LazyArrayTile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazy tile for on-the-fly evaluation of array tiles.  <a href="class_tiled_array_1_1detail_1_1_lazy_array_tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_make_random.html">MakeRandom</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_make_random_3_01std_1_1complex_3_01_scalar_type_01_4_01_4.html">MakeRandom&lt; std::complex&lt; ScalarType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_memory_watchpoint__x86__64.html">MemoryWatchpoint_x86_64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MemoryWatchpoint represents a hardware watchpoint for a memory location Implements a memory watchpoint on x86 ... only implemented for macOS so far this is a slightly tweaked version of <a href="https://m.habrahabr.ru/post/103073/">https://m.habrahabr.ru/post/103073/</a> see also <a href="http://www.sandpile.org/x86/drx.htm">http://www.sandpile.org/x86/drx.htm</a> for the x86 debugging register map.  <a href="class_tiled_array_1_1detail_1_1_memory_watchpoint__x86__64.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_mult.html">Mult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> multiplication operation.  <a href="class_tiled_array_1_1detail_1_1_mult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1non__iterator__tag.html">non_iterator_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_noop.html">Noop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> no operation (noop)  <a href="class_tiled_array_1_1detail_1_1_noop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type.html">numeric_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for extracting the numeric type of tensors and arrays.  <a href="struct_tiled_array_1_1detail_1_1numeric__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type_3_01_t_00_01typename_01std_1_1enable__if_3_01has__d59abeff2d30466086f8b9f9bebb50d9.html">numeric_type&lt; T, typename std::enable_if&lt; has_member_type_value_type&lt; T &gt;::value &amp;&amp;(!is_lazy_tile&lt; T &gt;::value) &amp;&amp;(!is_numeric_v&lt; T &gt;)&gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type_3_01_t_00_01typename_01std_1_1enable__if_3_01is__l56dea616054ab957d56742b9d4aa5296.html">numeric_type&lt; T, typename std::enable_if&lt; is_lazy_tile&lt; T &gt;::value &amp;&amp;!is_numeric_v&lt; T &gt; &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type_3_01_t_00_01typename_01std_1_1enable__if_3_01is__n30da39b3c54cc17adc63703c43a32a69.html">numeric_type&lt; T, typename std::enable_if&lt; is_numeric_v&lt; T &gt; &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1ordinal__traits.html">ordinal_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ordinal trait specifies properties of the ordinal  <a href="struct_tiled_array_1_1detail_1_1ordinal__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1ordinal__traits_3_01btas_1_1_range_nd_3_01___order_00_01___index_00_01___ordinal_01_4_01_4.html">ordinal_traits&lt; btas::RangeNd&lt; _Order, _Index, _Ordinal &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">btas::RangeNd can be col or row-major  <a href="struct_tiled_array_1_1detail_1_1ordinal__traits_3_01btas_1_1_range_nd_3_01___order_00_01___index_00_01___ordinal_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1ordinal__traits_3_01_range_01_4.html">ordinal_traits&lt; Range &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TA::Range is hardwired to row-major.  <a href="struct_tiled_array_1_1detail_1_1ordinal__traits_3_01_range_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1ordinal__traits_3_01_t_00_01std_1_1enable__if__t_3_01is__contigub364800e730b0362d4f327ab9bc94825.html">ordinal_traits&lt; T, std::enable_if_t&lt; is_contiguous_tensor_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ordinal traits of contiguous tensors are defined by their range type  <a href="struct_tiled_array_1_1detail_1_1ordinal__traits_3_01_t_00_01std_1_1enable__if__t_3_01is__contigub364800e730b0362d4f327ab9bc94825.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1param.html">param</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1param_3_01_t_00_01typename_01std_1_1enable__if_3_01is__numeric__v_3_01_t_01_4_01_4_1_1type_01_4.html">param&lt; T, typename std::enable_if&lt; is_numeric_v&lt; T &gt; &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1param_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__po026251cf0f0a4c03557bdf8a6565693e.html">param&lt; T, typename std::enable_if&lt; std::is_pointer&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1param_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__rece401fa407cc0a1ee19af25268964063.html">param&lt; T, typename std::enable_if&lt; std::is_reference&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_perm_index.html">PermIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that permutes ordinal indices.  <a href="class_tiled_array_1_1detail_1_1_perm_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_proc_grid.html">ProcGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D processor grid.  <a href="class_tiled_array_1_1detail_1_1_proc_grid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coordinate index iterate.  <a href="class_tiled_array_1_1detail_1_1_range_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_reduce_pair_op_wrapper.html">ReducePairOpWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper that to convert a pair-wise reduction into a standard reduction.  <a href="class_tiled_array_1_1detail_1_1_reduce_pair_op_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_reduce_pair_task.html">ReducePairTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce pair task.  <a href="class_tiled_array_1_1detail_1_1_reduce_pair_task.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_reduce_task.html">ReduceTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce task.  <a href="class_tiled_array_1_1detail_1_1_reduce_task.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1remove__cvr.html">remove_cvr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove const, volatile, and reference qualifiers.  <a href="struct_tiled_array_1_1detail_1_1remove__cvr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_replicated_pmap.html">ReplicatedPmap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Replicated process map.  <a href="class_tiled_array_1_1detail_1_1_replicated_pmap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_replicator.html">Replicator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replicate a <code>Array</code> object.  <a href="class_tiled_array_1_1detail_1_1_replicator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_round_robin_pmap.html">RoundRobinPmap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A blocked process map.  <a href="class_tiled_array_1_1detail_1_1_round_robin_pmap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_scal.html">Scal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> scaling operation.  <a href="class_tiled_array_1_1detail_1_1_scal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_scal_add.html">ScalAdd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> scale-addition operation.  <a href="class_tiled_array_1_1detail_1_1_scal_add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type.html">scalar_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for extracting the scalar type of tensors and arrays.  <a href="struct_tiled_array_1_1detail_1_1scalar__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type_3_01std_1_1complex_3_01_t_01_4_00_01void_01_4.html">scalar_type&lt; std::complex&lt; T &gt;, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type_3_01_t_00_01typename_01std_1_1enable__if_3_01is__scafb614aa70ce77399d4b647372651fd5.html">scalar_type&lt; T, typename std::enable_if&lt; is_scalar_v&lt; T &gt; &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type_3_01_t_00_01typename_01std_1_1enable__if_3_9is__num8f485262426224927d29a8d390487eb6.html">scalar_type&lt; T, typename std::enable_if&lt;!is_numeric_v&lt; T &gt; &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_scal_mult.html">ScalMult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> scale-multiplication operation.  <a href="class_tiled_array_1_1detail_1_1_scal_mult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_scal_shift.html">ScalShift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> shift operation.  <a href="class_tiled_array_1_1detail_1_1_scal_shift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_scal_subt.html">ScalSubt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> scale-subtraction operation.  <a href="class_tiled_array_1_1detail_1_1_scal_subt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_shift.html">Shift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> shift operation.  <a href="class_tiled_array_1_1detail_1_1_shift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html">ShiftWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1detail_1_1_shift.html" title="Tile shift operation.">Shift</a> wrapper class.  <a href="class_tiled_array_1_1detail_1_1_shift_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_size_array.html">SizeArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array wrapper.  <a href="class_tiled_array_1_1detail_1_1_size_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_subt.html">Subt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects.">Tile</a> subtraction operation.  <a href="class_tiled_array_1_1detail_1_1_subt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_summa.html">Summa</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed contraction evaluator implementation.  <a href="class_tiled_array_1_1detail_1_1_summa.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_const_reference.html">TensorConstReference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_impl.html">TensorImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> implementation and base for other tensor implementation objects.  <a href="class_tiled_array_1_1detail_1_1_tensor_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">TensorInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> interface for external data.  <a href="class_tiled_array_1_1detail_1_1_tensor_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_reference.html">TensorReference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html">TileConstReference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> tile reference.  <a href="class_tiled_array_1_1detail_1_1_tile_const_reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html">TileReference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> tile reference.  <a href="class_tiled_array_1_1detail_1_1_tile_reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_trace.html">Trace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_trace_3_01_tensor_3_01_t_00_01_a_01_4_00_01detail_1_1enable__if__numeric__t_3_01_t_01_4_01_4.html">Trace&lt; Tensor&lt; T, A &gt;, detail::enable_if_numeric_t&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_trace_is_defined.html">TraceIsDefined</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_trace_is_defined_3_01btas_1_1_tensor_3_01_t_00_01_range_00_01_s9ed10398046465880c26cd27f3be0174.html">TraceIsDefined&lt; btas::Tensor&lt; T, Range, Storage &gt;, enable_if_numeric_t&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_trace_is_defined_3_01_tensor_3_01_t_00_01_a_01_4_00_01enable__if__numeric__t_3_01_t_01_4_01_4.html">TraceIsDefined&lt; Tensor&lt; T, A &gt;, enable_if_numeric_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals that we can take the trace of a Tensor&lt;T, A&gt; (for numeric <code>T</code>)  <a href="struct_tiled_array_1_1detail_1_1_trace_is_defined_3_01_tensor_3_01_t_00_01_a_01_4_00_01enable__if__numeric__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_trace_is_defined_3_01_tile_3_01_arg_01_4_00_01enable__if__trace95ada15598ee3692b7d210e948c5949e.html">TraceIsDefined&lt; Tile&lt; Arg &gt;, enable_if_trace_is_defined_t&lt; Arg &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals that we can take the trace of a <code>Tile&lt;Arg&gt;</code> if can trace <code>Arg</code>.  <a href="struct_tiled_array_1_1detail_1_1_trace_is_defined_3_01_tile_3_01_arg_01_4_00_01enable__if__trace95ada15598ee3692b7d210e948c5949e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1transform.html">transform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1transform_3_01_tensor_3_01_t_00_01_a_01_4_01_4.html">transform&lt; Tensor&lt; T, A &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization of <a class="el" href="struct_tiled_array_1_1detail_1_1transform.html">TiledArray::detail::transform</a> for <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a>  <a href="struct_tiled_array_1_1detail_1_1transform_3_01_tensor_3_01_t_00_01_a_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1type__printer.html">type_printer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_unary_eval_impl.html">UnaryEvalImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> that is composed from an argument tensor.  <a href="class_tiled_array_1_1detail_1_1_unary_eval_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_unary_transform_iterator.html">UnaryTransformIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary transform iterator.  <a href="class_tiled_array_1_1detail_1_1_unary_transform_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_unary_wrapper.html">UnaryWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary tile operation wrapper.  <a href="class_tiled_array_1_1detail_1_1_unary_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_val_array.html">ValArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value array.  <a href="class_tiled_array_1_1detail_1_1_val_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a65a45262917781cbe96e0397ecf16fc0"><td class="memTemplParams" colspan="2">template&lt;typename Tensor &gt; </td></tr>
<tr class="memitem:a65a45262917781cbe96e0397ecf16fc0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a65a45262917781cbe96e0397ecf16fc0">default_permutation_t</a> = typename <a class="el" href="struct_tiled_array_1_1detail_1_1default__permutation.html">default_permutation</a>&lt; <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> &gt;::type</td></tr>
<tr class="separator:a65a45262917781cbe96e0397ecf16fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad934b0052446ed0de31bf4b3e2c2d148"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U  = void&gt; </td></tr>
<tr class="memitem:ad934b0052446ed0de31bf4b3e2c2d148"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ad934b0052446ed0de31bf4b3e2c2d148">enable_if_trace_is_defined_t</a> = std::enable_if_t&lt; <a class="el" href="namespace_tiled_array_1_1detail.html#a90b5d0dceea692165fc0b10fba571020">trace_is_defined_v</a>&lt; T &gt;, U &gt;</td></tr>
<tr class="memdesc:ad934b0052446ed0de31bf4b3e2c2d148"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE type for enabling code when the trace operation is defined.  <a href="namespace_tiled_array_1_1detail.html#ad934b0052446ed0de31bf4b3e2c2d148">More...</a><br /></td></tr>
<tr class="separator:ad934b0052446ed0de31bf4b3e2c2d148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da5cff0e02d481c8a9e83169d39885d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U  = void&gt; </td></tr>
<tr class="memitem:a5da5cff0e02d481c8a9e83169d39885d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a5da5cff0e02d481c8a9e83169d39885d">enable_if_numeric_t</a> = std::enable_if_t&lt; <a class="el" href="namespace_tiled_array_1_1detail.html#ae9a8587fd56f077ba909b14bca4609d9">is_numeric_v</a>&lt; T &gt;, U &gt;</td></tr>
<tr class="memdesc:a5da5cff0e02d481c8a9e83169d39885d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE type for enabling code when <code>T</code> is a numeric type.  <a href="namespace_tiled_array_1_1detail.html#a5da5cff0e02d481c8a9e83169d39885d">More...</a><br /></td></tr>
<tr class="separator:a5da5cff0e02d481c8a9e83169d39885d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763e783371e091990055d391dc6d2090"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a763e783371e091990055d391dc6d2090"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a763e783371e091990055d391dc6d2090">numeric_t</a> = typename <a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type.html">TiledArray::detail::numeric_type</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a763e783371e091990055d391dc6d2090"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>numeric_t&lt;T&gt;</code> is an alias for <code>numeric_type&lt;T&gt;::type</code>  <a href="namespace_tiled_array_1_1detail.html#a763e783371e091990055d391dc6d2090">More...</a><br /></td></tr>
<tr class="separator:a763e783371e091990055d391dc6d2090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3c6ec63959b5ed57e480adf45732d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5d3c6ec63959b5ed57e480adf45732d7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a5d3c6ec63959b5ed57e480adf45732d7">scalar_t</a> = typename <a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type.html">TiledArray::detail::scalar_type</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a5d3c6ec63959b5ed57e480adf45732d7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>scalar_t&lt;T&gt;</code> is an alias for <code>scalar_type&lt;T&gt;::type</code>  <a href="namespace_tiled_array_1_1detail.html#a5d3c6ec63959b5ed57e480adf45732d7">More...</a><br /></td></tr>
<tr class="separator:a5d3c6ec63959b5ed57e480adf45732d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d14af13df5092911ff84d4c1e8b0461"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d14af13df5092911ff84d4c1e8b0461"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a8d14af13df5092911ff84d4c1e8b0461">remove_cvr_t</a> = typename <a class="el" href="struct_tiled_array_1_1detail_1_1remove__cvr.html">remove_cvr</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a8d14af13df5092911ff84d4c1e8b0461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196b35f7b6b1ccdb872eeca1353bb26b"><td class="memTemplParams" colspan="2">template&lt;bool B, typename T &gt; </td></tr>
<tr class="memitem:a196b35f7b6b1ccdb872eeca1353bb26b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a196b35f7b6b1ccdb872eeca1353bb26b">const_if_t</a> = typename std::conditional&lt; B, const T, T &gt;::type</td></tr>
<tr class="memdesc:a196b35f7b6b1ccdb872eeca1353bb26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">prepends <code>const</code> to <code>T</code> if <code>B</code> is <code>true</code>  <a href="namespace_tiled_array_1_1detail.html#a196b35f7b6b1ccdb872eeca1353bb26b">More...</a><br /></td></tr>
<tr class="separator:a196b35f7b6b1ccdb872eeca1353bb26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d58e523957afcbcb1a47b8d98ab30d5"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a0d58e523957afcbcb1a47b8d98ab30d5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a0d58e523957afcbcb1a47b8d98ab30d5">param_type</a> = typename <a class="el" href="struct_tiled_array_1_1detail_1_1param.html">param</a>&lt; U &gt;::type</td></tr>
<tr class="separator:a0d58e523957afcbcb1a47b8d98ab30d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf7de66db96d83d8c9d1a990a9604b3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aebf7de66db96d83d8c9d1a990a9604b3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aebf7de66db96d83d8c9d1a990a9604b3">iterator_t</a> = decltype(std::begin(std::declval&lt; T &amp; &gt;()))</td></tr>
<tr class="separator:aebf7de66db96d83d8c9d1a990a9604b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4894269f42087aba45c572ad95aae0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8a4894269f42087aba45c572ad95aae0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a8a4894269f42087aba45c572ad95aae0">value_t</a> = <a class="el" href="namespace_tiled_array_1_1detail.html#a8d14af13df5092911ff84d4c1e8b0461">remove_cvr_t</a>&lt; decltype(*std::begin(std::declval&lt; T &amp; &gt;()))&gt;</td></tr>
<tr class="separator:a8a4894269f42087aba45c572ad95aae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97c9bf4ef025af9a6a81c86b49d2fad"><td class="memTemplParams" colspan="2">template&lt;typename Scalar1 , typename Scalar2 &gt; </td></tr>
<tr class="memitem:af97c9bf4ef025af9a6a81c86b49d2fad"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af97c9bf4ef025af9a6a81c86b49d2fad">add_t</a> = decltype(std::declval&lt; Scalar1 &gt;()+std::declval&lt; Scalar2 &gt;())</td></tr>
<tr class="separator:af97c9bf4ef025af9a6a81c86b49d2fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb1097bfa2f729cf40656648ed4116a"><td class="memTemplParams" colspan="2">template&lt;typename Scalar1 , typename Scalar2 &gt; </td></tr>
<tr class="memitem:abeb1097bfa2f729cf40656648ed4116a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#abeb1097bfa2f729cf40656648ed4116a">subt_t</a> = decltype(std::declval&lt; Scalar1 &gt;() - std::declval&lt; Scalar2 &gt;())</td></tr>
<tr class="separator:abeb1097bfa2f729cf40656648ed4116a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0808e462394d3ca16b63a873448283bd"><td class="memTemplParams" colspan="2">template&lt;typename Scalar1 , typename Scalar2 &gt; </td></tr>
<tr class="memitem:a0808e462394d3ca16b63a873448283bd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a0808e462394d3ca16b63a873448283bd">mult_t</a> = decltype(std::declval&lt; Scalar1 &gt;() *std::declval&lt; Scalar2 &gt;())</td></tr>
<tr class="separator:a0808e462394d3ca16b63a873448283bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e12c23ae1ad65ad65ef54b041abb37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a06e12c23ae1ad65ad65ef54b041abb37"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a06e12c23ae1ad65ad65ef54b041abb37">trange_t</a> = typename T::trange_type</td></tr>
<tr class="separator:a06e12c23ae1ad65ad65ef54b041abb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3199b02c7815c0d03a919fc87807656a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3199b02c7815c0d03a919fc87807656a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a3199b02c7815c0d03a919fc87807656a">shape_t</a> = typename T::shape_type</td></tr>
<tr class="separator:a3199b02c7815c0d03a919fc87807656a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11981ec4cf6f0e145fe51fa42c93ec10"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11981ec4cf6f0e145fe51fa42c93ec10"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a11981ec4cf6f0e145fe51fa42c93ec10">pmap_t</a> = typename T::pmap_interface</td></tr>
<tr class="separator:a11981ec4cf6f0e145fe51fa42c93ec10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187720de6c845523407c42fb2ebe0385"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a187720de6c845523407c42fb2ebe0385"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a187720de6c845523407c42fb2ebe0385">policy_t</a> = typename T::policy_type</td></tr>
<tr class="separator:a187720de6c845523407c42fb2ebe0385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c255a1c329b316421179dcb22fb044b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4c255a1c329b316421179dcb22fb044b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a4c255a1c329b316421179dcb22fb044b">vector_il</a> = std::initializer_list&lt; T &gt;</td></tr>
<tr class="separator:a4c255a1c329b316421179dcb22fb044b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1742d20935b7b111e19dd4da10428db3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1742d20935b7b111e19dd4da10428db3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a1742d20935b7b111e19dd4da10428db3">matrix_il</a> = std::initializer_list&lt; <a class="el" href="namespace_tiled_array_1_1detail.html#a4c255a1c329b316421179dcb22fb044b">vector_il</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:a1742d20935b7b111e19dd4da10428db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf318ba869ec2393a479afc716b081f4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf318ba869ec2393a479afc716b081f4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aaf318ba869ec2393a479afc716b081f4">tensor3_il</a> = std::initializer_list&lt; <a class="el" href="namespace_tiled_array_1_1detail.html#a1742d20935b7b111e19dd4da10428db3">matrix_il</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:aaf318ba869ec2393a479afc716b081f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adca399248d0a48c5e912e702dc7985"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1adca399248d0a48c5e912e702dc7985"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a1adca399248d0a48c5e912e702dc7985">tensor4_il</a> = std::initializer_list&lt; <a class="el" href="namespace_tiled_array_1_1detail.html#aaf318ba869ec2393a479afc716b081f4">tensor3_il</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:a1adca399248d0a48c5e912e702dc7985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f9d4ee3832912b4bcd51316feb99e6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a99f9d4ee3832912b4bcd51316feb99e6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a99f9d4ee3832912b4bcd51316feb99e6">tensor5_il</a> = std::initializer_list&lt; <a class="el" href="namespace_tiled_array_1_1detail.html#a1adca399248d0a48c5e912e702dc7985">tensor4_il</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:a99f9d4ee3832912b4bcd51316feb99e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe872421c2ccfb55ec6e98e9f139086d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afe872421c2ccfb55ec6e98e9f139086d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#afe872421c2ccfb55ec6e98e9f139086d">tensor6_il</a> = std::initializer_list&lt; <a class="el" href="namespace_tiled_array_1_1detail.html#a99f9d4ee3832912b4bcd51316feb99e6">tensor5_il</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:afe872421c2ccfb55ec6e98e9f139086d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a075f6329670e34ca33ad4ac48a64c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8a075f6329670e34ca33ad4ac48a64c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af8a075f6329670e34ca33ad4ac48a64c">enable_if_can_make_random_t</a> = std::enable_if_t&lt; can_make_random_v&lt; T &gt; &gt;</td></tr>
<tr class="separator:af8a075f6329670e34ca33ad4ac48a64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2cdeb370801b331554b63c01f4ac402b"><td class="memTemplParams" colspan="2">template&lt;typename Impl &gt; </td></tr>
<tr class="memitem:a2cdeb370801b331554b63c01f4ac402b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a2cdeb370801b331554b63c01f4ac402b">operator==</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html">TileReference</a>&lt; Impl &gt; &amp;a, const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html">TileReference</a>&lt; Impl &gt; &amp;b)</td></tr>
<tr class="memdesc:a2cdeb370801b331554b63c01f4ac402b"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison operator for <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html" title="Tensor tile reference.">TileReference</a> objects  <a href="namespace_tiled_array_1_1detail.html#a2cdeb370801b331554b63c01f4ac402b">More...</a><br /></td></tr>
<tr class="separator:a2cdeb370801b331554b63c01f4ac402b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b423b1a3fcf6701ac05c9ce692d208"><td class="memTemplParams" colspan="2">template&lt;typename Impl &gt; </td></tr>
<tr class="memitem:ae8b423b1a3fcf6701ac05c9ce692d208"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ae8b423b1a3fcf6701ac05c9ce692d208">operator!=</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html">TileReference</a>&lt; Impl &gt; &amp;a, const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html">TileReference</a>&lt; Impl &gt; &amp;b)</td></tr>
<tr class="memdesc:ae8b423b1a3fcf6701ac05c9ce692d208"><td class="mdescLeft">&#160;</td><td class="mdescRight">inequality operator for <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html" title="Tensor tile reference.">TileReference</a> objects  <a href="namespace_tiled_array_1_1detail.html#ae8b423b1a3fcf6701ac05c9ce692d208">More...</a><br /></td></tr>
<tr class="separator:ae8b423b1a3fcf6701ac05c9ce692d208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218cac85d033808e795a87a686ce4fb6"><td class="memTemplParams" colspan="2">template&lt;typename Impl &gt; </td></tr>
<tr class="memitem:a218cac85d033808e795a87a686ce4fb6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a218cac85d033808e795a87a686ce4fb6">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html">TileReference</a>&lt; Impl &gt; &amp;a)</td></tr>
<tr class="memdesc:a218cac85d033808e795a87a686ce4fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">redirect operator to std::ostream for <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html" title="Tensor tile reference.">TileReference</a> objects  <a href="namespace_tiled_array_1_1detail.html#a218cac85d033808e795a87a686ce4fb6">More...</a><br /></td></tr>
<tr class="separator:a218cac85d033808e795a87a686ce4fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52461acf45d3505ede569ee1aaa395c"><td class="memTemplParams" colspan="2">template&lt;typename Impl &gt; </td></tr>
<tr class="memitem:aa52461acf45d3505ede569ee1aaa395c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aa52461acf45d3505ede569ee1aaa395c">operator==</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html">TileConstReference</a>&lt; Impl &gt; &amp;a, const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html">TileConstReference</a>&lt; Impl &gt; &amp;b)</td></tr>
<tr class="memdesc:aa52461acf45d3505ede569ee1aaa395c"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison operator for <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html" title="Tensor tile reference.">TileConstReference</a> objects  <a href="namespace_tiled_array_1_1detail.html#aa52461acf45d3505ede569ee1aaa395c">More...</a><br /></td></tr>
<tr class="separator:aa52461acf45d3505ede569ee1aaa395c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804792a4a8294fbb2ca9ea04cb8c1da8"><td class="memTemplParams" colspan="2">template&lt;typename Impl &gt; </td></tr>
<tr class="memitem:a804792a4a8294fbb2ca9ea04cb8c1da8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a804792a4a8294fbb2ca9ea04cb8c1da8">operator!=</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html">TileConstReference</a>&lt; Impl &gt; &amp;a, const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html">TileConstReference</a>&lt; Impl &gt; &amp;b)</td></tr>
<tr class="memdesc:a804792a4a8294fbb2ca9ea04cb8c1da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">inequality operator for <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html" title="Tensor tile reference.">TileConstReference</a> objects  <a href="namespace_tiled_array_1_1detail.html#a804792a4a8294fbb2ca9ea04cb8c1da8">More...</a><br /></td></tr>
<tr class="separator:a804792a4a8294fbb2ca9ea04cb8c1da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff7f022aafbfb5bac3eaf2afc31cae6"><td class="memTemplParams" colspan="2">template&lt;typename Impl &gt; </td></tr>
<tr class="memitem:aaff7f022aafbfb5bac3eaf2afc31cae6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aaff7f022aafbfb5bac3eaf2afc31cae6">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html">TileConstReference</a>&lt; Impl &gt; &amp;a)</td></tr>
<tr class="memdesc:aaff7f022aafbfb5bac3eaf2afc31cae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">redirect operator to std::ostream for <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html" title="Tensor tile reference.">TileConstReference</a> objects  <a href="namespace_tiled_array_1_1detail.html#aaff7f022aafbfb5bac3eaf2afc31cae6">More...</a><br /></td></tr>
<tr class="separator:aaff7f022aafbfb5bac3eaf2afc31cae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6fcb450ef829c3ad4e8e1db5be514a"><td class="memTemplParams" colspan="2">template&lt;typename B &gt; </td></tr>
<tr class="memitem:a1d6fcb450ef829c3ad4e8e1db5be514a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a1d6fcb450ef829c3ad4e8e1db5be514a">swap</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; B &gt; &amp;b0, <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; B &gt; &amp;b1)</td></tr>
<tr class="separator:a1d6fcb450ef829c3ad4e8e1db5be514a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47735f4cdfcb24330a02fe4d9e68b8e7"><td class="memTemplParams" colspan="2">template&lt;typename Block &gt; </td></tr>
<tr class="memitem:a47735f4cdfcb24330a02fe4d9e68b8e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a47735f4cdfcb24330a02fe4d9e68b8e7">operator&amp;</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; left, const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;right)</td></tr>
<tr class="memdesc:a47735f4cdfcb24330a02fe4d9e68b8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise and operator of bitset.  <a href="namespace_tiled_array_1_1detail.html#a47735f4cdfcb24330a02fe4d9e68b8e7">More...</a><br /></td></tr>
<tr class="separator:a47735f4cdfcb24330a02fe4d9e68b8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0266e20b12eefced1cde7a01d4cdcd"><td class="memTemplParams" colspan="2">template&lt;typename Block &gt; </td></tr>
<tr class="memitem:a0d0266e20b12eefced1cde7a01d4cdcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a0d0266e20b12eefced1cde7a01d4cdcd">operator|</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; left, const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;right)</td></tr>
<tr class="memdesc:a0d0266e20b12eefced1cde7a01d4cdcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise or operator of bitset.  <a href="namespace_tiled_array_1_1detail.html#a0d0266e20b12eefced1cde7a01d4cdcd">More...</a><br /></td></tr>
<tr class="separator:a0d0266e20b12eefced1cde7a01d4cdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c12507ffe191d9e79b32f6687ec46b1"><td class="memTemplParams" colspan="2">template&lt;typename Block &gt; </td></tr>
<tr class="memitem:a9c12507ffe191d9e79b32f6687ec46b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a9c12507ffe191d9e79b32f6687ec46b1">operator^</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; left, const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;right)</td></tr>
<tr class="memdesc:a9c12507ffe191d9e79b32f6687ec46b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise xor operator of bitset.  <a href="namespace_tiled_array_1_1detail.html#a9c12507ffe191d9e79b32f6687ec46b1">More...</a><br /></td></tr>
<tr class="separator:a9c12507ffe191d9e79b32f6687ec46b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf888c0b992f597156737f71e2bc6d32"><td class="memTemplParams" colspan="2">template&lt;typename Block &gt; </td></tr>
<tr class="memitem:aaf888c0b992f597156737f71e2bc6d32"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aaf888c0b992f597156737f71e2bc6d32">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;bitset)</td></tr>
<tr class="separator:aaf888c0b992f597156737f71e2bc6d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead432075c6c7f2e9f7c329c96bc4d4a"><td class="memTemplParams" colspan="2">template&lt;typename DistArray_ , typename BTAS_Tensor_ &gt; </td></tr>
<tr class="memitem:aead432075c6c7f2e9f7c329c96bc4d4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aead432075c6c7f2e9f7c329c96bc4d4a">counted_btas_subtensor_to_tensor</a> (const BTAS_Tensor_ *src, DistArray_ *dst, const typename DistArray_::ordinal_type i, madness::AtomicInt *counter)</td></tr>
<tr class="separator:aead432075c6c7f2e9f7c329c96bc4d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae305e910ce674d71f550e104c354cb5"><td class="memTemplParams" colspan="2">template&lt;typename TA_Tensor_ , typename BTAS_Tensor_ &gt; </td></tr>
<tr class="memitem:aae305e910ce674d71f550e104c354cb5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aae305e910ce674d71f550e104c354cb5">counted_tensor_to_btas_subtensor</a> (const TA_Tensor_ &amp;src, BTAS_Tensor_ *dst, madness::AtomicInt *counter)</td></tr>
<tr class="memdesc:aae305e910ce674d71f550e104c354cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task function for assigning a tensor to an <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> submatrix.  <a href="namespace_tiled_array_1_1detail.html#aae305e910ce674d71f550e104c354cb5">More...</a><br /></td></tr>
<tr class="separator:aae305e910ce674d71f550e104c354cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46d9580d4d2230d0e34ee0ccfdafc72"><td class="memTemplParams" colspan="2">template&lt;bool sparse&gt; </td></tr>
<tr class="memitem:ab46d9580d4d2230d0e34ee0ccfdafc72"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ab46d9580d4d2230d0e34ee0ccfdafc72">make_shape</a> (World &amp;world, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> &amp;trange)</td></tr>
<tr class="separator:ab46d9580d4d2230d0e34ee0ccfdafc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f1aefd43dea7ce3158f142a57e5994"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a39f1aefd43dea7ce3158f142a57e5994"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a39f1aefd43dea7ce3158f142a57e5994">make_shape&lt; true &gt;</a> (World &amp;world, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> &amp;trange)</td></tr>
<tr class="separator:a39f1aefd43dea7ce3158f142a57e5994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2a3fd528183d1884b5f53d1d0d89fa"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a2b2a3fd528183d1884b5f53d1d0d89fa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a2b2a3fd528183d1884b5f53d1d0d89fa">make_shape&lt; false &gt;</a> (World &amp;, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> &amp;)</td></tr>
<tr class="separator:a2b2a3fd528183d1884b5f53d1d0d89fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5235a162fdccd242f61ab4fb2818bf83"><td class="memTemplParams" colspan="2">template&lt;typename A , typename Derived &gt; </td></tr>
<tr class="memitem:a5235a162fdccd242f61ab4fb2818bf83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a5235a162fdccd242f61ab4fb2818bf83">counted_eigen_submatrix_to_tensor</a> (const Eigen::MatrixBase&lt; Derived &gt; *matrix, A *array, const typename A::ordinal_type i, madness::AtomicInt *counter)</td></tr>
<tr class="memdesc:a5235a162fdccd242f61ab4fb2818bf83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task function for converting <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> submatrix to a tensor.  <a href="namespace_tiled_array_1_1detail.html#a5235a162fdccd242f61ab4fb2818bf83">More...</a><br /></td></tr>
<tr class="separator:a5235a162fdccd242f61ab4fb2818bf83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe493525138ef355ba76900e56ae8cf2"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename T &gt; </td></tr>
<tr class="memitem:afe493525138ef355ba76900e56ae8cf2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#afe493525138ef355ba76900e56ae8cf2">counted_tensor_to_eigen_submatrix</a> (const T &amp;tensor, Eigen::MatrixBase&lt; Derived &gt; *matrix, madness::AtomicInt *counter)</td></tr>
<tr class="memdesc:afe493525138ef355ba76900e56ae8cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task function for assigning a tensor to an <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> submatrix.  <a href="namespace_tiled_array_1_1detail.html#afe493525138ef355ba76900e56ae8cf2">More...</a><br /></td></tr>
<tr class="separator:afe493525138ef355ba76900e56ae8cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad764271dc2e35268ab009b2dbdb140"><td class="memTemplParams" colspan="2">template&lt;bool inplace = false, typename Op , typename ResultTile , typename ArgTile , typename Policy , typename... ArgTiles&gt; </td></tr>
<tr class="memitem:a9ad764271dc2e35268ab009b2dbdb140"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt; Policy &gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ResultTile, Policy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a9ad764271dc2e35268ab009b2dbdb140">foreach</a> (Op &amp;&amp;op, <a class="el" href="namespace_tiled_array_1_1detail.html#a196b35f7b6b1ccdb872eeca1353bb26b">const_if_t</a>&lt; not inplace, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ArgTile, Policy &gt;&gt; &amp;arg, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ArgTiles, Policy &gt; &amp;... args)</td></tr>
<tr class="memdesc:a9ad764271dc2e35268ab009b2dbdb140"><td class="mdescLeft">&#160;</td><td class="mdescRight">base implementation of dense <a class="el" href="namespace_tiled_array.html#a7945ee30f3a11a878035bb9e89dfe958" title="Apply a function to each tile of a dense Array.">TiledArray::foreach</a>  <a href="namespace_tiled_array_1_1detail.html#a9ad764271dc2e35268ab009b2dbdb140">More...</a><br /></td></tr>
<tr class="separator:a9ad764271dc2e35268ab009b2dbdb140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad1e3676bf04e4d918a1703e07dd025"><td class="memTemplParams" colspan="2">template&lt;bool inplace = false, typename Op , typename ResultTile , typename ArgTile , typename Policy , typename... ArgTiles&gt; </td></tr>
<tr class="memitem:a2ad1e3676bf04e4d918a1703e07dd025"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt; Policy &gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ResultTile, Policy &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a2ad1e3676bf04e4d918a1703e07dd025">foreach</a> (Op &amp;&amp;op, const <a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07">ShapeReductionMethod</a> shape_reduction, <a class="el" href="namespace_tiled_array_1_1detail.html#a196b35f7b6b1ccdb872eeca1353bb26b">const_if_t</a>&lt; not inplace, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ArgTile, Policy &gt;&gt; &amp;arg, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ArgTiles, Policy &gt; &amp;... args)</td></tr>
<tr class="memdesc:a2ad1e3676bf04e4d918a1703e07dd025"><td class="mdescLeft">&#160;</td><td class="mdescRight">base implementation of sparse <a class="el" href="namespace_tiled_array.html#a7945ee30f3a11a878035bb9e89dfe958" title="Apply a function to each tile of a dense Array.">TiledArray::foreach</a>  <a href="namespace_tiled_array_1_1detail.html#a2ad1e3676bf04e4d918a1703e07dd025">More...</a><br /></td></tr>
<tr class="separator:a2ad1e3676bf04e4d918a1703e07dd025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0780ab65ca5778bd4ee8f2783a082a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TA::TiledRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a3f0780ab65ca5778bd4ee8f2783a082a">prepend_dim_to_trange</a> (std::size_t array_rank, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> &amp;array_trange, std::size_t block_size=1)</td></tr>
<tr class="memdesc:a3f0780ab65ca5778bd4ee8f2783a082a"><td class="mdescLeft">&#160;</td><td class="mdescRight">prepends an extra dimension to a TRange  <a href="namespace_tiled_array_1_1detail.html#a3f0780ab65ca5778bd4ee8f2783a082a">More...</a><br /></td></tr>
<tr class="separator:a3f0780ab65ca5778bd4ee8f2783a082a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716b4de519b8ce66cdf12b9e6578f30b"><td class="memTemplParams" colspan="2">template&lt;typename Tile &gt; </td></tr>
<tr class="memitem:a716b4de519b8ce66cdf12b9e6578f30b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_sparse_shape.html">TA::SparseShape</a>&lt; float &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a716b4de519b8ce66cdf12b9e6578f30b">fuse_vector_of_shapes_tiles</a> (madness::World &amp;global_world, const std::vector&lt; <a class="el" href="class_tiled_array_1_1_dist_array.html">TA::DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">TA::SparsePolicy</a> &gt;&gt; &amp;arrays, const std::size_t array_rank, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TA::TiledRange</a> &amp;fused_trange)</td></tr>
<tr class="memdesc:a716b4de519b8ce66cdf12b9e6578f30b"><td class="mdescLeft">&#160;</td><td class="mdescRight">fuses the <a class="el" href="class_tiled_array_1_1_sparse_shape.html" title="Frobenius-norm-based sparse shape.">SparseShape</a> objects of a tilewise-round-robin distributed vector of Arrays into single <a class="el" href="class_tiled_array_1_1_sparse_shape.html" title="Frobenius-norm-based sparse shape.">SparseShape</a> object, with the vector index forming the first dimension.  <a href="namespace_tiled_array_1_1detail.html#a716b4de519b8ce66cdf12b9e6578f30b">More...</a><br /></td></tr>
<tr class="separator:a716b4de519b8ce66cdf12b9e6578f30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4f5f01de2e42a291b42f9f2b55eaa6"><td class="memTemplParams" colspan="2">template&lt;typename Tile &gt; </td></tr>
<tr class="memitem:aad4f5f01de2e42a291b42f9f2b55eaa6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dense_shape.html">TA::DenseShape</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aad4f5f01de2e42a291b42f9f2b55eaa6">fuse_vector_of_shapes_tiles</a> (madness::World &amp;, const std::vector&lt; <a class="el" href="class_tiled_array_1_1_dist_array.html">TA::DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">TA::DensePolicy</a> &gt;&gt; &amp;arrays, const std::size_t array_rank, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TA::TiledRange</a> &amp;fused_trange)</td></tr>
<tr class="memdesc:aad4f5f01de2e42a291b42f9f2b55eaa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">fuses the <a class="el" href="class_tiled_array_1_1_dense_shape.html" title="Dense shape of an array.">DenseShape</a> objects of a tilewise-round-robin distributed vector of Arrays into single <a class="el" href="class_tiled_array_1_1_dense_shape.html" title="Dense shape of an array.">DenseShape</a> object, with the vector index forming the first dimension.  <a href="namespace_tiled_array_1_1detail.html#aad4f5f01de2e42a291b42f9f2b55eaa6">More...</a><br /></td></tr>
<tr class="separator:aad4f5f01de2e42a291b42f9f2b55eaa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29fcee5d56ed2b3110413f3d8d31d2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_sparse_shape.html">TA::SparseShape</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af29fcee5d56ed2b3110413f3d8d31d2f">subshape_from_fused_tile</a> (const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TA::TiledRange</a> &amp;split_trange, const <a class="el" href="class_tiled_array_1_1_sparse_policy.html#a27268892fb7382991d0d11f78f7c717e">TA::SparsePolicy::shape_type</a> &amp;shape, const std::size_t tile_idx, const std::size_t split_ntiles, const std::size_t tile_size)</td></tr>
<tr class="memdesc:af29fcee5d56ed2b3110413f3d8d31d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">extracts the shape of a slice of a fused array created with fuse_vector_of_arrays  <a href="namespace_tiled_array_1_1detail.html#af29fcee5d56ed2b3110413f3d8d31d2f">More...</a><br /></td></tr>
<tr class="separator:af29fcee5d56ed2b3110413f3d8d31d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0313bd43006c929b4caf02174eb069a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dense_shape.html">TA::DenseShape</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a0313bd43006c929b4caf02174eb069a1">subshape_from_fused_tile</a> (const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TA::TiledRange</a> &amp;split_trange, const <a class="el" href="class_tiled_array_1_1_dense_policy.html#a8577445584fe74ab5616e266be3ce3fd">TA::DensePolicy::shape_type</a> &amp;shape, const std::size_t tile_idx, const std::size_t split_ntiles, const std::size_t tile_size)</td></tr>
<tr class="memdesc:a0313bd43006c929b4caf02174eb069a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">extracts the shape of a subarray of a fused array created with fuse_vector_of_arrays  <a href="namespace_tiled_array_1_1detail.html#a0313bd43006c929b4caf02174eb069a1">More...</a><br /></td></tr>
<tr class="separator:a0313bd43006c929b4caf02174eb069a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45190dfcad5ef2b9af5b4aa000c844b0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_tiled_array_1_1_range.html">TiledArray::Range</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a45190dfcad5ef2b9af5b4aa000c844b0">make_ta_range</a> (const <a class="el" href="class_tiled_array_1_1_range.html">TiledArray::Range</a> &amp;range)</td></tr>
<tr class="separator:a45190dfcad5ef2b9af5b4aa000c844b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763c40422c3621a425739070cf164db1"><td class="memTemplParams" colspan="2">template&lt;::blas::Layout Order, typename... Args&gt; </td></tr>
<tr class="memitem:a763c40422c3621a425739070cf164db1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_range.html">TiledArray::Range</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a763c40422c3621a425739070cf164db1">make_ta_range</a> (const btas::RangeNd&lt; Order, Args... &gt; &amp;range)</td></tr>
<tr class="memdesc:a763c40422c3621a425739070cf164db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">makes <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">TiledArray::Range</a> from a btas::RangeNd  <a href="namespace_tiled_array_1_1detail.html#a763c40422c3621a425739070cf164db1">More...</a><br /></td></tr>
<tr class="separator:a763c40422c3621a425739070cf164db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd1e7c394cfe8c14fe1419e4320b97d"><td class="memTemplParams" colspan="2">template&lt;typename Perm , typename Arg , typename Result , typename  = std::enable_if_t&lt;is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:a2cd1e7c394cfe8c14fe1419e4320b97d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a2cd1e7c394cfe8c14fe1419e4320b97d">permute_array</a> (const Perm &amp;perm, const Arg &amp;arg, Result &amp;result)</td></tr>
<tr class="memdesc:a2cd1e7c394cfe8c14fe1419e4320b97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a permuted copy of an array.  <a href="namespace_tiled_array_1_1detail.html#a2cd1e7c394cfe8c14fe1419e4320b97d">More...</a><br /></td></tr>
<tr class="separator:a2cd1e7c394cfe8c14fe1419e4320b97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b1ec146fbd546954d72262124a5b74"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Container &gt; </td></tr>
<tr class="memitem:a48b1ec146fbd546954d72262124a5b74"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a48b1ec146fbd546954d72262124a5b74">operator==</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;left_it, const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;right_it)</td></tr>
<tr class="memdesc:a48b1ec146fbd546954d72262124a5b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="namespace_tiled_array_1_1detail.html#a48b1ec146fbd546954d72262124a5b74">More...</a><br /></td></tr>
<tr class="separator:a48b1ec146fbd546954d72262124a5b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3699581fa58aa15f3376c5e6f66f68b3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Container &gt; </td></tr>
<tr class="memitem:a3699581fa58aa15f3376c5e6f66f68b3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a3699581fa58aa15f3376c5e6f66f68b3">operator!=</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;left_it, const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;right_it)</td></tr>
<tr class="memdesc:a3699581fa58aa15f3376c5e6f66f68b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="namespace_tiled_array_1_1detail.html#a3699581fa58aa15f3376c5e6f66f68b3">More...</a><br /></td></tr>
<tr class="separator:a3699581fa58aa15f3376c5e6f66f68b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af085e2abd40acbf24fbc80033634097b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af085e2abd40acbf24fbc80033634097b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af085e2abd40acbf24fbc80033634097b">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const <a class="el" href="class_tiled_array_1_1detail_1_1_size_array.html">SizeArray</a>&lt; T &gt; &amp;orig)</td></tr>
<tr class="separator:af085e2abd40acbf24fbc80033634097b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7179e9c73eed3c5738bf4d0c5ebd068d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7179e9c73eed3c5738bf4d0c5ebd068d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a7179e9c73eed3c5738bf4d0c5ebd068d">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1detail_1_1_size_array.html">SizeArray</a>&lt; T &gt; &amp;size_array)</td></tr>
<tr class="separator:a7179e9c73eed3c5738bf4d0c5ebd068d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c7d290f2fb4704eecc33b0894de068"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_range.html">Range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ae2c7d290f2fb4704eecc33b0894de068">diagonal_range</a> (<a class="el" href="class_tiled_array_1_1_range.html">Range</a> const &amp;rng)</td></tr>
<tr class="memdesc:ae2c7d290f2fb4704eecc33b0894de068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a range of the diagonal elements (if any) in a rank-d <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a>.  <a href="namespace_tiled_array_1_1detail.html#ae2c7d290f2fb4704eecc33b0894de068">More...</a><br /></td></tr>
<tr class="separator:ae2c7d290f2fb4704eecc33b0894de068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33aa537f17e1c4de2e8abf7093e29699"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a33aa537f17e1c4de2e8abf7093e29699"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; float &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a33aa537f17e1c4de2e8abf7093e29699">diagonal_shape</a> (<a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> const &amp;trange, T val)</td></tr>
<tr class="memdesc:a33aa537f17e1c4de2e8abf7093e29699"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes shape data (i.e. Frobenius norms of the tiles) for a constant diagonal tensor  <a href="namespace_tiled_array_1_1detail.html#a33aa537f17e1c4de2e8abf7093e29699">More...</a><br /></td></tr>
<tr class="separator:a33aa537f17e1c4de2e8abf7093e29699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354bb1fd3beebc3c8c47805bc43cd01c"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator &gt; </td></tr>
<tr class="memitem:a354bb1fd3beebc3c8c47805bc43cd01c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator.html">is_iterator</a>&lt; RandomAccessIterator &gt;::value, <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; float &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a354bb1fd3beebc3c8c47805bc43cd01c">diagonal_shape</a> (<a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> const &amp;trange, RandomAccessIterator diagonals_begin, RandomAccessIterator diagonals_end={})</td></tr>
<tr class="memdesc:a354bb1fd3beebc3c8c47805bc43cd01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes shape data (i.e. Frobenius norms of the tiles) for a non-constant diagonal tensor  <a href="namespace_tiled_array_1_1detail.html#a354bb1fd3beebc3c8c47805bc43cd01c">More...</a><br /></td></tr>
<tr class="separator:a354bb1fd3beebc3c8c47805bc43cd01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808571423d2d6d551e9844f0b38369a8"><td class="memTemplParams" colspan="2">template&lt;typename Array , typename T &gt; </td></tr>
<tr class="memitem:a808571423d2d6d551e9844f0b38369a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a808571423d2d6d551e9844f0b38369a8">write_diag_tiles_to_array_val</a> (<a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &amp;A, T val)</td></tr>
<tr class="memdesc:a808571423d2d6d551e9844f0b38369a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes tiles of a constant diagonal array.  <a href="namespace_tiled_array_1_1detail.html#a808571423d2d6d551e9844f0b38369a8">More...</a><br /></td></tr>
<tr class="separator:a808571423d2d6d551e9844f0b38369a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c268a352be16fc597e6ad2c7d6a7560"><td class="memTemplParams" colspan="2">template&lt;typename Array , typename RandomAccessIterator &gt; </td></tr>
<tr class="memitem:a8c268a352be16fc597e6ad2c7d6a7560"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator.html">is_iterator</a>&lt; RandomAccessIterator &gt;::value, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a8c268a352be16fc597e6ad2c7d6a7560">write_diag_tiles_to_array_rng</a> (<a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &amp;A, RandomAccessIterator diagonals_begin)</td></tr>
<tr class="memdesc:a8c268a352be16fc597e6ad2c7d6a7560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes tiles of a nonconstant diagonal array.  <a href="namespace_tiled_array_1_1detail.html#a8c268a352be16fc597e6ad2c7d6a7560">More...</a><br /></td></tr>
<tr class="separator:a8c268a352be16fc597e6ad2c7d6a7560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a7abe197b45ae95a4132fc240ed383"><td class="memTemplParams" colspan="2">template&lt;typename R , typename std::enable_if&lt; is_numeric_v&lt; R &gt; &amp;&amp;!is_complex&lt; R &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a32a7abe197b45ae95a4132fc240ed383"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383">conj</a> (const R r)</td></tr>
<tr class="memdesc:a32a7abe197b45ae95a4132fc240ed383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function for <code>std::conj</code>  <a href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383">More...</a><br /></td></tr>
<tr class="separator:a32a7abe197b45ae95a4132fc240ed383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381e9dfb596a18e208171ce358fa6f16"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a381e9dfb596a18e208171ce358fa6f16"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE std::complex&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a381e9dfb596a18e208171ce358fa6f16">conj</a> (const std::complex&lt; R &gt; z)</td></tr>
<tr class="memdesc:a381e9dfb596a18e208171ce358fa6f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function for std::conj.  <a href="namespace_tiled_array_1_1detail.html#a381e9dfb596a18e208171ce358fa6f16">More...</a><br /></td></tr>
<tr class="separator:a381e9dfb596a18e208171ce358fa6f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5031b9fe59e7561b395a2ef1c6b5e719"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R , typename std::enable_if&lt; is_numeric_v&lt; L &gt; &amp;&amp;!is_complex&lt; L &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a5031b9fe59e7561b395a2ef1c6b5e719"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a5031b9fe59e7561b395a2ef1c6b5e719">inner_product</a> (const L l, const R r)</td></tr>
<tr class="memdesc:a5031b9fe59e7561b395a2ef1c6b5e719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inner product of a real value and a numeric value.  <a href="namespace_tiled_array_1_1detail.html#a5031b9fe59e7561b395a2ef1c6b5e719">More...</a><br /></td></tr>
<tr class="separator:a5031b9fe59e7561b395a2ef1c6b5e719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af885da1706c23576a28eb38b7afab176"><td class="memTemplParams" colspan="2">template&lt;typename R , typename std::enable_if&lt; is_numeric_v&lt; R &gt; &amp;&amp;!is_complex&lt; R &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:af885da1706c23576a28eb38b7afab176"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af885da1706c23576a28eb38b7afab176">norm</a> (const R r)</td></tr>
<tr class="memdesc:af885da1706c23576a28eb38b7afab176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function for <code>std::norm</code>  <a href="namespace_tiled_array_1_1detail.html#af885da1706c23576a28eb38b7afab176">More...</a><br /></td></tr>
<tr class="separator:af885da1706c23576a28eb38b7afab176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af182bb984874298c8351edad6f03517c"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:af182bb984874298c8351edad6f03517c"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af182bb984874298c8351edad6f03517c">norm</a> (const std::complex&lt; R &gt; z)</td></tr>
<tr class="memdesc:af182bb984874298c8351edad6f03517c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the norm of a complex number <code>z</code>  <a href="namespace_tiled_array_1_1detail.html#af182bb984874298c8351edad6f03517c">More...</a><br /></td></tr>
<tr class="separator:af182bb984874298c8351edad6f03517c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78aafa383b1b3e69b6e57b6b78c61306"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a78aafa383b1b3e69b6e57b6b78c61306"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a78aafa383b1b3e69b6e57b6b78c61306">conj_op</a> (const S factor)</td></tr>
<tr class="memdesc:a78aafa383b1b3e69b6e57b6b78c61306"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a> operator factory function.  <a href="namespace_tiled_array_1_1detail.html#a78aafa383b1b3e69b6e57b6b78c61306">More...</a><br /></td></tr>
<tr class="separator:a78aafa383b1b3e69b6e57b6b78c61306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c470158b2bbbdb712cbbaf18a55101"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ab2c470158b2bbbdb712cbbaf18a55101">conj_op</a> ()</td></tr>
<tr class="memdesc:ab2c470158b2bbbdb712cbbaf18a55101"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a> operator factory function.  <a href="namespace_tiled_array_1_1detail.html#ab2c470158b2bbbdb712cbbaf18a55101">More...</a><br /></td></tr>
<tr class="separator:ab2c470158b2bbbdb712cbbaf18a55101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02d47cab0fc5866bf2eb5c13acf659b"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ad02d47cab0fc5866bf2eb5c13acf659b"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ad02d47cab0fc5866bf2eb5c13acf659b">operator*</a> (const L value, const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; R &gt; op)</td></tr>
<tr class="separator:ad02d47cab0fc5866bf2eb5c13acf659b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee93af26740ea0ee7c7f67db9a46601"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:a8ee93af26740ea0ee7c7f67db9a46601"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a8ee93af26740ea0ee7c7f67db9a46601">operator*</a> (const L value, const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt; &amp;)</td></tr>
<tr class="separator:a8ee93af26740ea0ee7c7f67db9a46601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e797cf6d3cd288a14452f32071b7a93"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:a6e797cf6d3cd288a14452f32071b7a93"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a6e797cf6d3cd288a14452f32071b7a93">operator*</a> (const L value, const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1_complex_neg_tag.html">ComplexNegTag</a> &gt; &amp;)</td></tr>
<tr class="separator:a6e797cf6d3cd288a14452f32071b7a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f8563d428af127b0abe38a93863ead"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:a69f8563d428af127b0abe38a93863ead"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a69f8563d428af127b0abe38a93863ead">operator*</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; L &gt; op, const R value)</td></tr>
<tr class="separator:a69f8563d428af127b0abe38a93863ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31df1c69fe31afa87b68fb74323ec6a4"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a31df1c69fe31afa87b68fb74323ec6a4"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a31df1c69fe31afa87b68fb74323ec6a4">operator*</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt;, const R value)</td></tr>
<tr class="separator:a31df1c69fe31afa87b68fb74323ec6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6a9baaee6dc713469802694a8f82d6"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:acc6a9baaee6dc713469802694a8f82d6"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#acc6a9baaee6dc713469802694a8f82d6">operator*</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1_complex_neg_tag.html">ComplexNegTag</a> &gt;, const R value)</td></tr>
<tr class="separator:acc6a9baaee6dc713469802694a8f82d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea2c5a93d37330153912da87c7c3877"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R , typename std::enable_if&lt;!std::is_void&lt; R &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:acea2c5a93d37330153912da87c7c3877"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE L &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#acea2c5a93d37330153912da87c7c3877">operator*=</a> (L &amp;value, const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; R &gt; op)</td></tr>
<tr class="separator:acea2c5a93d37330153912da87c7c3877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa443b57aebf3d340cc65deeeb00c2073"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:aa443b57aebf3d340cc65deeeb00c2073"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE L &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aa443b57aebf3d340cc65deeeb00c2073">operator*=</a> (L &amp;value, const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt; &amp;)</td></tr>
<tr class="separator:aa443b57aebf3d340cc65deeeb00c2073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4bd519fc858458a6bf061c1ef2ef5b3"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:ab4bd519fc858458a6bf061c1ef2ef5b3"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE L &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ab4bd519fc858458a6bf061c1ef2ef5b3">operator*=</a> (L &amp;value, const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1_complex_neg_tag.html">ComplexNegTag</a> &gt; &amp;)</td></tr>
<tr class="separator:ab4bd519fc858458a6bf061c1ef2ef5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61cbefb29ceef11f580804c689464d1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af61cbefb29ceef11f580804c689464d1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af61cbefb29ceef11f580804c689464d1">abs</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:af61cbefb29ceef11f580804c689464d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bafe4052acf5d99d2ef8010f362648"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a96bafe4052acf5d99d2ef8010f362648">abs</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt; &amp;a)</td></tr>
<tr class="separator:a96bafe4052acf5d99d2ef8010f362648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d3ac1bd3e7b1b004f489db1b4ce8be"><td class="memTemplParams" colspan="2">template&lt;typename TR , typename Op , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value||is_tensor_of_tensor&lt; TR, T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ab9d3ac1bd3e7b1b004f489db1b4ce8be"><td class="memTemplItemLeft" align="right" valign="top">TR&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ab9d3ac1bd3e7b1b004f489db1b4ce8be">tensor_op</a> (Op &amp;&amp;op, const T1 &amp;tensor1, const Ts &amp;... tensors)</td></tr>
<tr class="memdesc:ab9d3ac1bd3e7b1b004f489db1b4ce8be"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> operations with contiguous data.  <a href="namespace_tiled_array_1_1detail.html#ab9d3ac1bd3e7b1b004f489db1b4ce8be">More...</a><br /></td></tr>
<tr class="separator:ab9d3ac1bd3e7b1b004f489db1b4ce8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f0f7c8a549579e118a89827e98726b"><td class="memTemplParams" colspan="2">template&lt;typename TR , typename Op , typename T1 , typename... Ts, typename std::enable_if&lt;(is_tensor&lt; T1, Ts... &gt;::value||is_tensor_of_tensor&lt; TR, T1, Ts... &gt;::value) &amp;&amp;is_contiguous_tensor&lt; T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a82f0f7c8a549579e118a89827e98726b"><td class="memTemplItemLeft" align="right" valign="top">TR&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a82f0f7c8a549579e118a89827e98726b">tensor_op</a> (Op &amp;&amp;op, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const T1 &amp;tensor1, const Ts &amp;... tensors)</td></tr>
<tr class="memdesc:a82f0f7c8a549579e118a89827e98726b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> permutation operations with contiguous data.  <a href="namespace_tiled_array_1_1detail.html#a82f0f7c8a549579e118a89827e98726b">More...</a><br /></td></tr>
<tr class="separator:a82f0f7c8a549579e118a89827e98726b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c2574bd1506d0e811e2c0eb58fb1e3"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename TR , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, Ts... &gt;::value &amp;&amp;is_contiguous_tensor&lt; TR, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ac7c2574bd1506d0e811e2c0eb58fb1e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ac7c2574bd1506d0e811e2c0eb58fb1e3">inplace_tensor_op</a> (Op &amp;&amp;op, TR &amp;result, const Ts &amp;... tensors)</td></tr>
<tr class="memdesc:ac7c2574bd1506d0e811e2c0eb58fb1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place tensor operations with contiguous data.  <a href="namespace_tiled_array_1_1detail.html#ac7c2574bd1506d0e811e2c0eb58fb1e3">More...</a><br /></td></tr>
<tr class="separator:ac7c2574bd1506d0e811e2c0eb58fb1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af174120ffd75a14d13077eff16452d9b"><td class="memTemplParams" colspan="2">template&lt;typename InputOp , typename OutputOp , typename TR , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value &amp;&amp;is_contiguous_tensor&lt; TR, T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:af174120ffd75a14d13077eff16452d9b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af174120ffd75a14d13077eff16452d9b">inplace_tensor_op</a> (InputOp &amp;&amp;input_op, OutputOp &amp;&amp;output_op, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, TR &amp;result, const T1 &amp;tensor1, const Ts &amp;... tensors)</td></tr>
<tr class="memdesc:af174120ffd75a14d13077eff16452d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place tensor permutation operations with contiguous data.  <a href="namespace_tiled_array_1_1detail.html#af174120ffd75a14d13077eff16452d9b">More...</a><br /></td></tr>
<tr class="separator:af174120ffd75a14d13077eff16452d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa32053a2cef8c73b71763a0e01cd95"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename TR , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, Ts... &gt;::value &amp;&amp;is_contiguous_tensor&lt; TR, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a2fa32053a2cef8c73b71763a0e01cd95"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a2fa32053a2cef8c73b71763a0e01cd95">tensor_init</a> (Op &amp;&amp;op, TR &amp;result, const Ts &amp;... tensors)</td></tr>
<tr class="memdesc:a2fa32053a2cef8c73b71763a0e01cd95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize tensor with contiguous tensor arguments.  <a href="namespace_tiled_array_1_1detail.html#a2fa32053a2cef8c73b71763a0e01cd95">More...</a><br /></td></tr>
<tr class="separator:a2fa32053a2cef8c73b71763a0e01cd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2788b8e3e27331097aa656a0e6e36b20"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename TR , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a2788b8e3e27331097aa656a0e6e36b20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a2788b8e3e27331097aa656a0e6e36b20">tensor_init</a> (Op &amp;&amp;op, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, TR &amp;result, const T1 &amp;tensor1, const Ts &amp;... tensors)</td></tr>
<tr class="memdesc:a2788b8e3e27331097aa656a0e6e36b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize tensor with permuted tensor arguments.  <a href="namespace_tiled_array_1_1detail.html#a2788b8e3e27331097aa656a0e6e36b20">More...</a><br /></td></tr>
<tr class="separator:a2788b8e3e27331097aa656a0e6e36b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5132fe4d73d49d24d2dcd60f06849f9"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename TR , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value &amp;&amp;is_contiguous_tensor&lt; TR &gt;::value &amp;&amp;!is_contiguous_tensor&lt; T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ac5132fe4d73d49d24d2dcd60f06849f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ac5132fe4d73d49d24d2dcd60f06849f9">tensor_init</a> (Op &amp;&amp;op, TR &amp;result, const T1 &amp;tensor1, const Ts &amp;... tensors)</td></tr>
<tr class="memdesc:ac5132fe4d73d49d24d2dcd60f06849f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize tensor with one or more non-contiguous tensor arguments.  <a href="namespace_tiled_array_1_1detail.html#ac5132fe4d73d49d24d2dcd60f06849f9">More...</a><br /></td></tr>
<tr class="separator:ac5132fe4d73d49d24d2dcd60f06849f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab957a79bba9735ad3e405dbb8dd53796"><td class="memTemplParams" colspan="2">template&lt;typename ReduceOp , typename JoinOp , typename Scalar , typename T1 , typename... Ts, typename std::enable_if_t&lt; is_tensor&lt; T1, Ts... &gt;::value &amp;&amp;is_contiguous_tensor&lt; T1, Ts... &gt;::value &amp;&amp;!is_reduce_op_v&lt; std::decay_t&lt; ReduceOp &gt;, std::decay_t&lt; Scalar &gt;, std::decay_t&lt; T1 &gt;, std::decay_t&lt; Ts &gt;... &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab957a79bba9735ad3e405dbb8dd53796"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ab957a79bba9735ad3e405dbb8dd53796">tensor_reduce</a> (ReduceOp &amp;&amp;reduce_op, JoinOp &amp;&amp;join_op, Scalar identity, const T1 &amp;tensor1, const Ts &amp;... tensors)</td></tr>
<tr class="memdesc:ab957a79bba9735ad3e405dbb8dd53796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduction operation for contiguous tensors.  <a href="namespace_tiled_array_1_1detail.html#ab957a79bba9735ad3e405dbb8dd53796">More...</a><br /></td></tr>
<tr class="separator:ab957a79bba9735ad3e405dbb8dd53796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c80429be52090559d58f18c011ce30"><td class="memTemplParams" colspan="2">template&lt;typename SizeType , typename ExtentType &gt; </td></tr>
<tr class="memitem:a38c80429be52090559d58f18c011ce30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a38c80429be52090559d58f18c011ce30">fuse_dimensions</a> (SizeType *MADNESS_RESTRICT const fused_size, SizeType *MADNESS_RESTRICT const fused_weight, const ExtentType *MADNESS_RESTRICT const size, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:a38c80429be52090559d58f18c011ce30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the fused dimensions for permutation.  <a href="namespace_tiled_array_1_1detail.html#a38c80429be52090559d58f18c011ce30">More...</a><br /></td></tr>
<tr class="separator:a38c80429be52090559d58f18c011ce30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f41e1794be8e3f5515437c8301585a9"><td class="memTemplParams" colspan="2">template&lt;typename InputOp , typename OutputOp , typename Result , typename Perm , typename Arg0 , typename... Args, typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:a3f41e1794be8e3f5515437c8301585a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a3f41e1794be8e3f5515437c8301585a9">permute</a> (InputOp &amp;&amp;input_op, OutputOp &amp;&amp;output_op, Result &amp;result, const Perm &amp;perm, const Arg0 &amp;arg0, const Args &amp;... args)</td></tr>
<tr class="memdesc:a3f41e1794be8e3f5515437c8301585a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a permuted tensor copy.  <a href="namespace_tiled_array_1_1detail.html#a3f41e1794be8e3f5515437c8301585a9">More...</a><br /></td></tr>
<tr class="separator:a3f41e1794be8e3f5515437c8301585a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49fdad6dffe4694cd2f6568461a409c"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:aa49fdad6dffe4694cd2f6568461a409c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aa49fdad6dffe4694cd2f6568461a409c">is_range_congruent</a> (const Left &amp;left, const <a class="el" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html">ShiftWrapper</a>&lt; Right &gt; &amp;right)</td></tr>
<tr class="memdesc:aa49fdad6dffe4694cd2f6568461a409c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for congruent range objects with a shifted tensor.  <a href="namespace_tiled_array_1_1detail.html#aa49fdad6dffe4694cd2f6568461a409c">More...</a><br /></td></tr>
<tr class="separator:aa49fdad6dffe4694cd2f6568461a409c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42595fd971b6420e4b921afb9eef9cb8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range , typename OpResult &gt; </td></tr>
<tr class="memitem:a42595fd971b6420e4b921afb9eef9cb8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a42595fd971b6420e4b921afb9eef9cb8">operator==</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">TensorInterface</a>&lt; T, <a class="el" href="class_tiled_array_1_1_range.html">Range</a>, OpResult &gt; &amp;first, const <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">TensorInterface</a>&lt; T, <a class="el" href="class_tiled_array_1_1_range.html">Range</a>, OpResult &gt; &amp;second)</td></tr>
<tr class="memdesc:a42595fd971b6420e4b921afb9eef9cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shallow comparison operator.  <a href="namespace_tiled_array_1_1detail.html#a42595fd971b6420e4b921afb9eef9cb8">More...</a><br /></td></tr>
<tr class="separator:a42595fd971b6420e4b921afb9eef9cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3099e3f966559b8e09bca8d63327117"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ab3099e3f966559b8e09bca8d63327117"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ab3099e3f966559b8e09bca8d63327117">clone_range</a> (const T &amp;tensor)</td></tr>
<tr class="memdesc:ab3099e3f966559b8e09bca8d63327117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of the range of the tensor.  <a href="namespace_tiled_array_1_1detail.html#ab3099e3f966559b8e09bca8d63327117">More...</a><br /></td></tr>
<tr class="separator:ab3099e3f966559b8e09bca8d63327117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd25794432f3ae654ef616a170280af3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; !is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:afd25794432f3ae654ef616a170280af3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_range.html">Range</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#afd25794432f3ae654ef616a170280af3">clone_range</a> (const T &amp;tensor)</td></tr>
<tr class="memdesc:afd25794432f3ae654ef616a170280af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a contiguous copy of the range of the tensor.  <a href="namespace_tiled_array_1_1detail.html#afd25794432f3ae654ef616a170280af3">More...</a><br /></td></tr>
<tr class="separator:afd25794432f3ae654ef616a170280af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9a43dfee2749874d4677ea89ab4188"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt;!(is_shifted&lt; T1 &gt;::value||is_shifted&lt; T2 &gt;::value)&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a0b9a43dfee2749874d4677ea89ab4188"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a0b9a43dfee2749874d4677ea89ab4188">is_range_congruent</a> (const T1 &amp;tensor1, const T2 &amp;tensor2)</td></tr>
<tr class="memdesc:a0b9a43dfee2749874d4677ea89ab4188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the ranges of a pair of tensors are congruent.  <a href="namespace_tiled_array_1_1detail.html#a0b9a43dfee2749874d4677ea89ab4188">More...</a><br /></td></tr>
<tr class="separator:a0b9a43dfee2749874d4677ea89ab4188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35b616db0b6d4da11b862de9570fb93"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt;!(is_shifted&lt; T1 &gt;::value||is_shifted&lt; T2 &gt;::value)&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aa35b616db0b6d4da11b862de9570fb93"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aa35b616db0b6d4da11b862de9570fb93">is_range_congruent</a> (const T1 &amp;tensor1, const T2 &amp;tensor2, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:aa35b616db0b6d4da11b862de9570fb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the ranges of a pair of permuted tensors are congruent.  <a href="namespace_tiled_array_1_1detail.html#aa35b616db0b6d4da11b862de9570fb93">More...</a><br /></td></tr>
<tr class="separator:aa35b616db0b6d4da11b862de9570fb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d75a0a0d43e9a5d8beec072cdbe678c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0d75a0a0d43e9a5d8beec072cdbe678c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c">is_range_set_congruent</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const T &amp;tensor)</td></tr>
<tr class="memdesc:a0d75a0a0d43e9a5d8beec072cdbe678c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the ranges of a permuted tensor is congruent with itself.  <a href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c">More...</a><br /></td></tr>
<tr class="separator:a0d75a0a0d43e9a5d8beec072cdbe678c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a1f5fb2f3d857ee31e66ba3deabf20"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename... Ts&gt; </td></tr>
<tr class="memitem:a42a1f5fb2f3d857ee31e66ba3deabf20"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a42a1f5fb2f3d857ee31e66ba3deabf20">is_range_set_congruent</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const T1 &amp;tensor1, const T2 &amp;tensor2, const Ts &amp;... tensors)</td></tr>
<tr class="memdesc:a42a1f5fb2f3d857ee31e66ba3deabf20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the ranges of a permuted set of tensors are congruent.  <a href="namespace_tiled_array_1_1detail.html#a42a1f5fb2f3d857ee31e66ba3deabf20">More...</a><br /></td></tr>
<tr class="separator:a42a1f5fb2f3d857ee31e66ba3deabf20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d01c42f84f360ae79da4a0c8e5b84a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d01c42f84f360ae79da4a0c8e5b84a2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a8d01c42f84f360ae79da4a0c8e5b84a2">is_range_set_congruent</a> (const T &amp;tensor)</td></tr>
<tr class="memdesc:a8d01c42f84f360ae79da4a0c8e5b84a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the ranges of a tensor is congruent with itself.  <a href="namespace_tiled_array_1_1detail.html#a8d01c42f84f360ae79da4a0c8e5b84a2">More...</a><br /></td></tr>
<tr class="separator:a8d01c42f84f360ae79da4a0c8e5b84a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81ff970acbf1f37236b31c6d19f8e27"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename... Ts&gt; </td></tr>
<tr class="memitem:af81ff970acbf1f37236b31c6d19f8e27"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af81ff970acbf1f37236b31c6d19f8e27">is_range_set_congruent</a> (const T1 &amp;tensor1, const T2 &amp;tensor2, const Ts &amp;... tensors)</td></tr>
<tr class="memdesc:af81ff970acbf1f37236b31c6d19f8e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the ranges of a set of tensors are congruent.  <a href="namespace_tiled_array_1_1detail.html#af81ff970acbf1f37236b31c6d19f8e27">More...</a><br /></td></tr>
<tr class="separator:af81ff970acbf1f37236b31c6d19f8e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85557b284f443993530894acbb158b58"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a85557b284f443993530894acbb158b58"><td class="memTemplItemLeft" align="right" valign="top">T::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a85557b284f443993530894acbb158b58">inner_size_helper</a> (const T &amp;tensor)</td></tr>
<tr class="memdesc:a85557b284f443993530894acbb158b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the inner size.  <a href="namespace_tiled_array_1_1detail.html#a85557b284f443993530894acbb158b58">More...</a><br /></td></tr>
<tr class="separator:a85557b284f443993530894acbb158b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227f69a3e3e5de0854bac8e8f2ec6cee"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a227f69a3e3e5de0854bac8e8f2ec6cee"><td class="memTemplItemLeft" align="right" valign="top">T1::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a227f69a3e3e5de0854bac8e8f2ec6cee">inner_size_helper</a> (const T1 &amp;tensor1, const T2 &amp;tensor2)</td></tr>
<tr class="memdesc:a227f69a3e3e5de0854bac8e8f2ec6cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the inner size of two tensors.  <a href="namespace_tiled_array_1_1detail.html#a227f69a3e3e5de0854bac8e8f2ec6cee">More...</a><br /></td></tr>
<tr class="separator:a227f69a3e3e5de0854bac8e8f2ec6cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ec4c7e7bd4d19b11f0674903ce630a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt;!is_contiguous_tensor&lt; T1 &gt;::value &amp;&amp;is_contiguous_tensor&lt; T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a91ec4c7e7bd4d19b11f0674903ce630a"><td class="memTemplItemLeft" align="right" valign="top">T1::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a91ec4c7e7bd4d19b11f0674903ce630a">inner_size</a> (const T1 &amp;tensor1, const T2 &amp;)</td></tr>
<tr class="memdesc:a91ec4c7e7bd4d19b11f0674903ce630a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the inner size of two tensors.  <a href="namespace_tiled_array_1_1detail.html#a91ec4c7e7bd4d19b11f0674903ce630a">More...</a><br /></td></tr>
<tr class="separator:a91ec4c7e7bd4d19b11f0674903ce630a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b57f060bc5b930d00c088dc270cf15b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; !is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a4b57f060bc5b930d00c088dc270cf15b"><td class="memTemplItemLeft" align="right" valign="top">T::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a4b57f060bc5b930d00c088dc270cf15b">inner_size</a> (const T &amp;tensor)</td></tr>
<tr class="memdesc:a4b57f060bc5b930d00c088dc270cf15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the inner size.  <a href="namespace_tiled_array_1_1detail.html#a4b57f060bc5b930d00c088dc270cf15b">More...</a><br /></td></tr>
<tr class="separator:a4b57f060bc5b930d00c088dc270cf15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b25c9db0387e3327718de2cbc9112c6"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a2b25c9db0387e3327718de2cbc9112c6">empty</a> ()</td></tr>
<tr class="memdesc:a2b25c9db0387e3327718de2cbc9112c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for empty tensors in an empty list.  <a href="namespace_tiled_array_1_1detail.html#a2b25c9db0387e3327718de2cbc9112c6">More...</a><br /></td></tr>
<tr class="separator:a2b25c9db0387e3327718de2cbc9112c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9662eaa03fe6d3cdbe380e9cf5dea3e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename... Ts&gt; </td></tr>
<tr class="memitem:ad9662eaa03fe6d3cdbe380e9cf5dea3e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ad9662eaa03fe6d3cdbe380e9cf5dea3e">empty</a> (const T1 &amp;tensor1, const Ts &amp;... tensors)</td></tr>
<tr class="memdesc:ad9662eaa03fe6d3cdbe380e9cf5dea3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for empty tensors.  <a href="namespace_tiled_array_1_1detail.html#ad9662eaa03fe6d3cdbe380e9cf5dea3e">More...</a><br /></td></tr>
<tr class="separator:ad9662eaa03fe6d3cdbe380e9cf5dea3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada724a31400bb94f55097560394438de"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada724a31400bb94f55097560394438de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ada724a31400bb94f55097560394438de">make_tile</a> (T &amp;&amp;t)</td></tr>
<tr class="memdesc:ada724a31400bb94f55097560394438de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function for tiles.  <a href="namespace_tiled_array_1_1detail.html#ada724a31400bb94f55097560394438de">More...</a><br /></td></tr>
<tr class="separator:ada724a31400bb94f55097560394438de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f2092d8f52e938f74173f7ede0b07d"><td class="memTemplParams" colspan="2">template&lt;typename Iter1 , typename Iter2 , typename Op &gt; </td></tr>
<tr class="memitem:a58f2092d8f52e938f74173f7ede0b07d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_binary_transform_iterator.html">BinaryTransformIterator</a>&lt; Iter1, Iter2, Op &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a58f2092d8f52e938f74173f7ede0b07d">make_tran_it</a> (Iter1 it1, Iter2 it2, Op op)</td></tr>
<tr class="memdesc:a58f2092d8f52e938f74173f7ede0b07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary Transform iterator factory.  <a href="namespace_tiled_array_1_1detail.html#a58f2092d8f52e938f74173f7ede0b07d">More...</a><br /></td></tr>
<tr class="separator:a58f2092d8f52e938f74173f7ede0b07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52e422e441d6c6cd06db1812f784e1c"><td class="memTemplParams" colspan="2">template&lt;typename Iter , typename Op &gt; </td></tr>
<tr class="memitem:ab52e422e441d6c6cd06db1812f784e1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_unary_transform_iterator.html">UnaryTransformIterator</a>&lt; Iter, Op &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ab52e422e441d6c6cd06db1812f784e1c">make_tran_it</a> (Iter it, Op op)</td></tr>
<tr class="memdesc:ab52e422e441d6c6cd06db1812f784e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary Transform iterator factory.  <a href="namespace_tiled_array_1_1detail.html#ab52e422e441d6c6cd06db1812f784e1c">More...</a><br /></td></tr>
<tr class="separator:ab52e422e441d6c6cd06db1812f784e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfac8561aed9b008518116e11d9bdca0"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, typename T &gt; </td></tr>
<tr class="memitem:abfac8561aed9b008518116e11d9bdca0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#abfac8561aed9b008518116e11d9bdca0">get</a> (T &amp;&amp;t)</td></tr>
<tr class="separator:abfac8561aed9b008518116e11d9bdca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ea1372c2353060fba2943065fcc26f"><td class="memTemplParams" colspan="2">template&lt;typename GeneralizedPair , typename  = std::enable_if_t&lt;is_gpair_v&lt;GeneralizedPair&gt;&gt;&gt; </td></tr>
<tr class="memitem:a72ea1372c2353060fba2943065fcc26f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a72ea1372c2353060fba2943065fcc26f">at</a> (GeneralizedPair &amp;&amp;v, std::size_t idx)</td></tr>
<tr class="memdesc:a72ea1372c2353060fba2943065fcc26f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>at(pair, i)</code> extracts i-th element from gpair  <a href="namespace_tiled_array_1_1detail.html#a72ea1372c2353060fba2943065fcc26f">More...</a><br /></td></tr>
<tr class="separator:a72ea1372c2353060fba2943065fcc26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c44cde899d571534b6ff2e9d22ed75"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a05c44cde899d571534b6ff2e9d22ed75">dummy_annotation</a> (unsigned int n_outer_size, unsigned int n_inner_size=0)</td></tr>
<tr class="separator:a05c44cde899d571534b6ff2e9d22ed75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7723231012d7f0f700b31406de463ae4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a7723231012d7f0f700b31406de463ae4">remove_whitespace</a> (std::string s)</td></tr>
<tr class="separator:a7723231012d7f0f700b31406de463ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8995a103b8540e3506a34377ea37f331"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a8995a103b8540e3506a34377ea37f331">tokenize_index</a> (const std::string &amp;s, char delim)</td></tr>
<tr class="separator:a8995a103b8540e3506a34377ea37f331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73854ab2c5a308c4c3f16544f6480b68"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a73854ab2c5a308c4c3f16544f6480b68">is_valid_index</a> (const std::string &amp;idx)</td></tr>
<tr class="separator:a73854ab2c5a308c4c3f16544f6480b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab69b5c6e7fe9114b25b22231b63aff4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aab69b5c6e7fe9114b25b22231b63aff4">is_tot_index</a> (const std::string &amp;idx)</td></tr>
<tr class="separator:aab69b5c6e7fe9114b25b22231b63aff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a4bb50000c2c62628719892888b8bb"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af1a4bb50000c2c62628719892888b8bb">split_index</a> (const std::string &amp;idx)</td></tr>
<tr class="separator:af1a4bb50000c2c62628719892888b8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd635d089830705f84e08204967760d"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a5cd635d089830705f84e08204967760d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a5cd635d089830705f84e08204967760d">print_array</a> (std::ostream &amp;out, const A &amp;a, const std::size_t n)</td></tr>
<tr class="memdesc:a5cd635d089830705f84e08204967760d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the content of an array like object.  <a href="namespace_tiled_array_1_1detail.html#a5cd635d089830705f84e08204967760d">More...</a><br /></td></tr>
<tr class="separator:a5cd635d089830705f84e08204967760d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0a678c425372465314f925b87612ce"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a2c0a678c425372465314f925b87612ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a2c0a678c425372465314f925b87612ce">print_array</a> (std::ostream &amp;out, const A &amp;a)</td></tr>
<tr class="memdesc:a2c0a678c425372465314f925b87612ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the content of an array like object.  <a href="namespace_tiled_array_1_1detail.html#a2c0a678c425372465314f925b87612ce">More...</a><br /></td></tr>
<tr class="separator:a2c0a678c425372465314f925b87612ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d036f88ab05ca2cbd5c2e10175d93c"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; bool &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aa8d036f88ab05ca2cbd5c2e10175d93c">ignore_tile_position_accessor</a> ()</td></tr>
<tr class="separator:aa8d036f88ab05ca2cbd5c2e10175d93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26bd55f3154ac62a00c6ff633db1d40"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa26bd55f3154ac62a00c6ff633db1d40"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aa26bd55f3154ac62a00c6ff633db1d40">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1detail_1_1_val_array.html">ValArray</a>&lt; T &gt; &amp;val_array)</td></tr>
<tr class="separator:aa26bd55f3154ac62a00c6ff633db1d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab0fc4bbe2156233325dde23dc13042f8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0fc4bbe2156233325dde23dc13042f8"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ab0fc4bbe2156233325dde23dc13042f8">is_btas_tensor_v</a> = <a class="el" href="struct_tiled_array_1_1detail_1_1is__btas__tensor.html">is_btas_tensor</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ab0fc4bbe2156233325dde23dc13042f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e51e98990f8ec0f01aa129358ccfdf"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ab8e51e98990f8ec0f01aa129358ccfdf"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ab8e51e98990f8ec0f01aa129358ccfdf">is_tensor_v</a> = <a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor.html">is_tensor</a>&lt;Ts...&gt;::value</td></tr>
<tr class="separator:ab8e51e98990f8ec0f01aa129358ccfdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac758e2af2b4381cceea4816706e2d088"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ac758e2af2b4381cceea4816706e2d088"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ac758e2af2b4381cceea4816706e2d088">is_tensor_of_tensor_v</a> = <a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor.html">is_tensor_of_tensor</a>&lt;Ts...&gt;::value</td></tr>
<tr class="separator:ac758e2af2b4381cceea4816706e2d088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b2fe8adc99e9f280d17d7944b15bdf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a61b2fe8adc99e9f280d17d7944b15bdf"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a61b2fe8adc99e9f280d17d7944b15bdf">is_ta_tensor_v</a> = <a class="el" href="struct_tiled_array_1_1detail_1_1is__ta__tensor.html">is_ta_tensor</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a61b2fe8adc99e9f280d17d7944b15bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777fdd832b3e46e8d73323db6b3b32d3"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a777fdd832b3e46e8d73323db6b3b32d3"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a777fdd832b3e46e8d73323db6b3b32d3">is_contiguous_tensor_v</a></td></tr>
<tr class="separator:a777fdd832b3e46e8d73323db6b3b32d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c85c1749c56d6a8156eee0d6756d825"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a8c85c1749c56d6a8156eee0d6756d825"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a8c85c1749c56d6a8156eee0d6756d825">is_shifted_v</a> = <a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted.html">is_shifted</a>&lt;Ts...&gt;::value</td></tr>
<tr class="separator:a8c85c1749c56d6a8156eee0d6756d825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562496bd6662c46c3f33528f6560aa2a"><td class="memTemplParams" colspan="2">template&lt;typename ReduceOp , typename Result , typename... Args&gt; </td></tr>
<tr class="memitem:a562496bd6662c46c3f33528f6560aa2a"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a562496bd6662c46c3f33528f6560aa2a">is_reduce_op_v</a></td></tr>
<tr class="separator:a562496bd6662c46c3f33528f6560aa2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b5d0dceea692165fc0b10fba571020"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a90b5d0dceea692165fc0b10fba571020"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a90b5d0dceea692165fc0b10fba571020">trace_is_defined_v</a> = <a class="el" href="struct_tiled_array_1_1detail_1_1_trace_is_defined.html">TraceIsDefined</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a90b5d0dceea692165fc0b10fba571020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0329ff8ebbd09a1c3ab85f2a43e4d486"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0329ff8ebbd09a1c3ab85f2a43e4d486"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a0329ff8ebbd09a1c3ab85f2a43e4d486">is_type_v</a> = <a class="el" href="struct_tiled_array_1_1detail_1_1is__type.html">is_type</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a0329ff8ebbd09a1c3ab85f2a43e4d486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eeab9da39bfd45539541d0ba245d5cf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0eeab9da39bfd45539541d0ba245d5cf"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a0eeab9da39bfd45539541d0ba245d5cf">is_complete_type_v</a> = <a class="el" href="struct_tiled_array_1_1detail_1_1is__complete__type.html">is_complete_type</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a0eeab9da39bfd45539541d0ba245d5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738e87dbca1a453733cb85b6c9d9fc24"><td class="memTemplParams" colspan="2">template&lt;class From , class To &gt; </td></tr>
<tr class="memitem:a738e87dbca1a453733cb85b6c9d9fc24"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a738e87dbca1a453733cb85b6c9d9fc24">has_conversion_operator_v</a></td></tr>
<tr class="separator:a738e87dbca1a453733cb85b6c9d9fc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87f63a46517a49b9362c388cbe57dc3"><td class="memTemplParams" colspan="2">template&lt;class From , class To &gt; </td></tr>
<tr class="memitem:ad87f63a46517a49b9362c388cbe57dc3"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ad87f63a46517a49b9362c388cbe57dc3">is_explicitly_convertible_v</a></td></tr>
<tr class="separator:ad87f63a46517a49b9362c388cbe57dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28ffa77b69964713adc5cf642fa23c3"><td class="memTemplParams" colspan="2">template&lt;class From , class To &gt; </td></tr>
<tr class="memitem:aa28ffa77b69964713adc5cf642fa23c3"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aa28ffa77b69964713adc5cf642fa23c3">is_implicitly_convertible_v</a></td></tr>
<tr class="separator:aa28ffa77b69964713adc5cf642fa23c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e024e5b73dac0ce527c0799b758fc22"><td class="memTemplParams" colspan="2">template&lt;class From , class To &gt; </td></tr>
<tr class="memitem:a6e024e5b73dac0ce527c0799b758fc22"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a6e024e5b73dac0ce527c0799b758fc22">is_convertible_v</a> = <a class="el" href="struct_tiled_array_1_1detail_1_1is__convertible.html">is_convertible</a>&lt;From, To&gt;::value</td></tr>
<tr class="separator:a6e024e5b73dac0ce527c0799b758fc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32d54448887aacc8b40faaff4ba3af8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa32d54448887aacc8b40faaff4ba3af8"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aa32d54448887aacc8b40faaff4ba3af8">is_complex_v</a> = <a class="el" href="struct_tiled_array_1_1detail_1_1is__complex.html">is_complex</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:aa32d54448887aacc8b40faaff4ba3af8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>is_complex_v&lt;T&gt;</code> is an alias for <code>is_complex&lt;T&gt;::value</code>  <a href="namespace_tiled_array_1_1detail.html#aa32d54448887aacc8b40faaff4ba3af8">More...</a><br /></td></tr>
<tr class="separator:aa32d54448887aacc8b40faaff4ba3af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a8587fd56f077ba909b14bca4609d9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae9a8587fd56f077ba909b14bca4609d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ae9a8587fd56f077ba909b14bca4609d9">is_numeric_v</a> = <a class="el" href="struct_tiled_array_1_1detail_1_1is__numeric.html">is_numeric</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ae9a8587fd56f077ba909b14bca4609d9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>is_numeric_v&lt;T&gt;</code> is an alias for <code>is_numeric&lt;T&gt;::value</code>  <a href="namespace_tiled_array_1_1detail.html#ae9a8587fd56f077ba909b14bca4609d9">More...</a><br /></td></tr>
<tr class="separator:ae9a8587fd56f077ba909b14bca4609d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e22c293cfc55984e9ed1df68a77d275"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e22c293cfc55984e9ed1df68a77d275"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a6e22c293cfc55984e9ed1df68a77d275">is_scalar_v</a> = <a class="el" href="struct_tiled_array_1_1detail_1_1is__scalar.html">is_scalar</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a6e22c293cfc55984e9ed1df68a77d275"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>is_scalar_v&lt;T&gt;</code> is an alias for <code>is_scalar_v&lt;T&gt;</code>  <a href="namespace_tiled_array_1_1detail.html#a6e22c293cfc55984e9ed1df68a77d275">More...</a><br /></td></tr>
<tr class="separator:a6e22c293cfc55984e9ed1df68a77d275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c761f7fc2da5f75088312b2ac6b420"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a70c761f7fc2da5f75088312b2ac6b420"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a70c761f7fc2da5f75088312b2ac6b420">is_array_tile_v</a> = <a class="el" href="struct_tiled_array_1_1detail_1_1is__array__tile.html">is_array_tile</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a70c761f7fc2da5f75088312b2ac6b420"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>is_array_tile_v&lt;T&gt;</code> is an alias for <code>is_array_tile&lt;T&gt;::value</code>  <a href="namespace_tiled_array_1_1detail.html#a70c761f7fc2da5f75088312b2ac6b420">More...</a><br /></td></tr>
<tr class="separator:a70c761f7fc2da5f75088312b2ac6b420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d4bf07d4d516136a2aefa7deb770d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a00d4bf07d4d516136a2aefa7deb770d6"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a00d4bf07d4d516136a2aefa7deb770d6">is_non_array_lazy_tile_v</a></td></tr>
<tr class="separator:a00d4bf07d4d516136a2aefa7deb770d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652d029d8bd7e5758b370f2ca46982d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a652d029d8bd7e5758b370f2ca46982d7"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a652d029d8bd7e5758b370f2ca46982d7">is_strictly_ordered_v</a> = <a class="el" href="struct_tiled_array_1_1detail_1_1is__strictly__ordered.html">is_strictly_ordered</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a652d029d8bd7e5758b370f2ca46982d7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>is_strictly_ordered_v&lt;T&gt;</code> is an alias for <code>is_strictly_ordered&lt;T&gt;::value</code>  <a href="namespace_tiled_array_1_1detail.html#a652d029d8bd7e5758b370f2ca46982d7">More...</a><br /></td></tr>
<tr class="separator:a652d029d8bd7e5758b370f2ca46982d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae0a0fc086bf1faa014545962ad1781"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a3ae0a0fc086bf1faa014545962ad1781"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a3ae0a0fc086bf1faa014545962ad1781">is_integral_list_v</a> = <a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__list.html">is_integral_list</a>&lt;Ts...&gt;::value</td></tr>
<tr class="memdesc:a3ae0a0fc086bf1faa014545962ad1781"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>is_integral_list_v&lt;T&gt;</code> is an alias for <code>is_integral_list&lt;T&gt;::value</code>  <a href="namespace_tiled_array_1_1detail.html#a3ae0a0fc086bf1faa014545962ad1781">More...</a><br /></td></tr>
<tr class="separator:a3ae0a0fc086bf1faa014545962ad1781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fb59e16578e42b5c80d5002250218a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a44fb59e16578e42b5c80d5002250218a"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a44fb59e16578e42b5c80d5002250218a">is_tuple_v</a> = <a class="el" href="struct_tiled_array_1_1detail_1_1is__tuple.html">is_tuple</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a44fb59e16578e42b5c80d5002250218a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>is_tuple_v&lt;T&gt;</code> is an alias for <code>is_tuple&lt;T&gt;::value</code>  <a href="namespace_tiled_array_1_1detail.html#a44fb59e16578e42b5c80d5002250218a">More...</a><br /></td></tr>
<tr class="separator:a44fb59e16578e42b5c80d5002250218a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65d6a1933a7fe06fc26e9e9268f19e1"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, typename T &gt; </td></tr>
<tr class="memitem:ae65d6a1933a7fe06fc26e9e9268f19e1"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ae65d6a1933a7fe06fc26e9e9268f19e1">is_std_gettable_v</a> = <a class="el" href="struct_tiled_array_1_1detail_1_1is__std__gettable.html">is_std_gettable</a>&lt;I, T&gt;::value</td></tr>
<tr class="separator:ae65d6a1933a7fe06fc26e9e9268f19e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456ed5bf7a518ffadf8cfe088b327fdc"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, typename T &gt; </td></tr>
<tr class="memitem:a456ed5bf7a518ffadf8cfe088b327fdc"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a456ed5bf7a518ffadf8cfe088b327fdc">is_boost_gettable_v</a> = <a class="el" href="struct_tiled_array_1_1detail_1_1is__boost__gettable.html">is_boost_gettable</a>&lt;I, T&gt;::value</td></tr>
<tr class="separator:a456ed5bf7a518ffadf8cfe088b327fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fd750917972e009569639cc5263e9d"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, typename T &gt; </td></tr>
<tr class="memitem:ab0fd750917972e009569639cc5263e9d"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ab0fd750917972e009569639cc5263e9d">is_gettable_v</a></td></tr>
<tr class="separator:ab0fd750917972e009569639cc5263e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873d66153e5b72fbc331401fca1317d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a873d66153e5b72fbc331401fca1317d7"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a873d66153e5b72fbc331401fca1317d7">is_gettable_pair_v</a> = <a class="el" href="struct_tiled_array_1_1detail_1_1is__gettable__pair.html">is_gettable_pair</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a873d66153e5b72fbc331401fca1317d7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>is_gettable_pair_v&lt;T&gt;</code> is an alias for <code>is_gettable_pair&lt;T&gt;::value</code>  <a href="namespace_tiled_array_1_1detail.html#a873d66153e5b72fbc331401fca1317d7">More...</a><br /></td></tr>
<tr class="separator:a873d66153e5b72fbc331401fca1317d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185876cbe702ca84ba0549ccb1bc23a4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a185876cbe702ca84ba0549ccb1bc23a4"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a185876cbe702ca84ba0549ccb1bc23a4">is_integral_pair_v</a> = <a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__pair.html">is_integral_pair</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a185876cbe702ca84ba0549ccb1bc23a4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>is_integral_pair_v&lt;T&gt;</code> is an alias for <code>is_integral_pair&lt;T&gt;::value</code>  <a href="namespace_tiled_array_1_1detail.html#a185876cbe702ca84ba0549ccb1bc23a4">More...</a><br /></td></tr>
<tr class="separator:a185876cbe702ca84ba0549ccb1bc23a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f60d0f0032505a78e85a7cfad30b0d4"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a5f60d0f0032505a78e85a7cfad30b0d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a5f60d0f0032505a78e85a7cfad30b0d4">is_integral_pair_list_v</a></td></tr>
<tr class="separator:a5f60d0f0032505a78e85a7cfad30b0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bbbecc0133c913cf854acaafa37c3a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad9bbbecc0133c913cf854acaafa37c3a"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ad9bbbecc0133c913cf854acaafa37c3a">is_integral_tuple_v</a> = <a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__tuple.html">is_integral_tuple</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ad9bbbecc0133c913cf854acaafa37c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>is_integral_tuple_v&lt;T&gt;</code> is an alias for <code>is_integral_tuple&lt;T&gt;::value</code>  <a href="namespace_tiled_array_1_1detail.html#ad9bbbecc0133c913cf854acaafa37c3a">More...</a><br /></td></tr>
<tr class="separator:ad9bbbecc0133c913cf854acaafa37c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6619b110eb049fc229952dd9333028c2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6619b110eb049fc229952dd9333028c2"><td class="memTemplItemLeft" align="right" valign="top">constexpr const bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a6619b110eb049fc229952dd9333028c2">is_pair_v</a> = <a class="el" href="struct_tiled_array_1_1detail_1_1is__pair.html">is_pair</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a6619b110eb049fc229952dd9333028c2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>is_pair_v&lt;T&gt;</code> is an alias for <code>is_pair&lt;T&gt;::value</code>  <a href="namespace_tiled_array_1_1detail.html#a6619b110eb049fc229952dd9333028c2">More...</a><br /></td></tr>
<tr class="separator:a6619b110eb049fc229952dd9333028c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="af97c9bf4ef025af9a6a81c86b49d2fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97c9bf4ef025af9a6a81c86b49d2fad">&#9670;&nbsp;</a></span>add_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar1 , typename Scalar2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#af97c9bf4ef025af9a6a81c86b49d2fad">TiledArray::detail::add_t</a> = typedef decltype(std::declval&lt;Scalar1&gt;() + std::declval&lt;Scalar2&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l01153">1153</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a196b35f7b6b1ccdb872eeca1353bb26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196b35f7b6b1ccdb872eeca1353bb26b">&#9670;&nbsp;</a></span>const_if_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool B, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a196b35f7b6b1ccdb872eeca1353bb26b">TiledArray::detail::const_if_t</a> = typedef typename std::conditional&lt;B, const T, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prepends <code>const</code> to <code>T</code> if <code>B</code> is <code>true</code> </p>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00966">966</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a65a45262917781cbe96e0397ecf16fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a45262917781cbe96e0397ecf16fc0">&#9670;&nbsp;</a></span>default_permutation_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tensor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a65a45262917781cbe96e0397ecf16fc0">TiledArray::detail::default_permutation_t</a> = typedef typename <a class="el" href="struct_tiled_array_1_1detail_1_1default__permutation.html">default_permutation</a>&lt;<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_2type__traits_8h_source.html#l00290">290</a> of file <a class="el" href="tensor_2type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="af8a075f6329670e34ca33ad4ac48a64c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a075f6329670e34ca33ad4ac48a64c">&#9670;&nbsp;</a></span>enable_if_can_make_random_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#af8a075f6329670e34ca33ad4ac48a64c">TiledArray::detail::enable_if_can_make_random_t</a> = typedef std::enable_if_t&lt;can_make_random_v&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables a function only when we can generate a random value of type <code>T</code></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of random value we are attempting to generate. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="random_8h_source.html#l00077">77</a> of file <a class="el" href="random_8h_source.html">random.h</a>.</p>

</div>
</div>
<a id="a5da5cff0e02d481c8a9e83169d39885d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da5cff0e02d481c8a9e83169d39885d">&#9670;&nbsp;</a></span>enable_if_numeric_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a5da5cff0e02d481c8a9e83169d39885d">TiledArray::detail::enable_if_numeric_t</a> = typedef std::enable_if_t&lt;<a class="el" href="namespace_tiled_array_1_1detail.html#ae9a8587fd56f077ba909b14bca4609d9">is_numeric_v</a>&lt;T&gt;, U&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SFINAE type for enabling code when <code>T</code> is a numeric type. </p>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00649">649</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="ad934b0052446ed0de31bf4b3e2c2d148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad934b0052446ed0de31bf4b3e2c2d148">&#9670;&nbsp;</a></span>enable_if_trace_is_defined_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#ad934b0052446ed0de31bf4b3e2c2d148">TiledArray::detail::enable_if_trace_is_defined_t</a> = typedef std::enable_if_t&lt;<a class="el" href="namespace_tiled_array_1_1detail.html#a90b5d0dceea692165fc0b10fba571020">trace_is_defined_v</a>&lt;T&gt;, U&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SFINAE type for enabling code when the trace operation is defined. </p>

<p class="definition">Definition at line <a class="el" href="trace_8h_source.html#l00061">61</a> of file <a class="el" href="trace_8h_source.html">trace.h</a>.</p>

</div>
</div>
<a id="aebf7de66db96d83d8c9d1a990a9604b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf7de66db96d83d8c9d1a990a9604b3">&#9670;&nbsp;</a></span>iterator_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#aebf7de66db96d83d8c9d1a990a9604b3">TiledArray::detail::iterator_t</a> = typedef decltype(std::begin(std::declval&lt;T&amp;&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>a range type <code>iterator_t&lt;T&gt;</code> is the iterator type, i.e. the type returned by <code>std::begin(T&amp;)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>will be replaced by C++20 ranges::iterator_t </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l01106">1106</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a1742d20935b7b111e19dd4da10428db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1742d20935b7b111e19dd4da10428db3">&#9670;&nbsp;</a></span>matrix_il</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a1742d20935b7b111e19dd4da10428db3">TiledArray::detail::matrix_il</a> = typedef std::initializer_list&lt;<a class="el" href="namespace_tiled_array_1_1detail.html#a4c255a1c329b316421179dcb22fb044b">vector_il</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="initializer__list_8h_source.html#l00381">381</a> of file <a class="el" href="initializer__list_8h_source.html">initializer_list.h</a>.</p>

</div>
</div>
<a id="a0808e462394d3ca16b63a873448283bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0808e462394d3ca16b63a873448283bd">&#9670;&nbsp;</a></span>mult_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar1 , typename Scalar2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a0808e462394d3ca16b63a873448283bd">TiledArray::detail::mult_t</a> = typedef decltype(std::declval&lt;Scalar1&gt;() * std::declval&lt;Scalar2&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l01159">1159</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a763e783371e091990055d391dc6d2090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763e783371e091990055d391dc6d2090">&#9670;&nbsp;</a></span>numeric_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a763e783371e091990055d391dc6d2090">TiledArray::detail::numeric_t</a> = typedef typename <a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type.html">TiledArray::detail::numeric_type</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>numeric_t&lt;T&gt;</code> is an alias for <code>numeric_type&lt;T&gt;::type</code> </p>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00730">730</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a0d58e523957afcbcb1a47b8d98ab30d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d58e523957afcbcb1a47b8d98ab30d5">&#9670;&nbsp;</a></span>param_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a0d58e523957afcbcb1a47b8d98ab30d5">TiledArray::detail::param_type</a> = typedef typename <a class="el" href="struct_tiled_array_1_1detail_1_1param.html">param</a>&lt;U&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00991">991</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a11981ec4cf6f0e145fe51fa42c93ec10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11981ec4cf6f0e145fe51fa42c93ec10">&#9670;&nbsp;</a></span>pmap_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a11981ec4cf6f0e145fe51fa42c93ec10">TiledArray::detail::pmap_t</a> = typedef typename T::pmap_interface</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l01177">1177</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a187720de6c845523407c42fb2ebe0385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187720de6c845523407c42fb2ebe0385">&#9670;&nbsp;</a></span>policy_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a187720de6c845523407c42fb2ebe0385">TiledArray::detail::policy_t</a> = typedef typename T::policy_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l01180">1180</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a8d14af13df5092911ff84d4c1e8b0461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d14af13df5092911ff84d4c1e8b0461">&#9670;&nbsp;</a></span>remove_cvr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a8d14af13df5092911ff84d4c1e8b0461">TiledArray::detail::remove_cvr_t</a> = typedef typename <a class="el" href="struct_tiled_array_1_1detail_1_1remove__cvr.html">remove_cvr</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00962">962</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a5d3c6ec63959b5ed57e480adf45732d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3c6ec63959b5ed57e480adf45732d7">&#9670;&nbsp;</a></span>scalar_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a5d3c6ec63959b5ed57e480adf45732d7">TiledArray::detail::scalar_t</a> = typedef typename <a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type.html">TiledArray::detail::scalar_type</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>scalar_t&lt;T&gt;</code> is an alias for <code>scalar_type&lt;T&gt;::type</code> </p>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00760">760</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a3199b02c7815c0d03a919fc87807656a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3199b02c7815c0d03a919fc87807656a">&#9670;&nbsp;</a></span>shape_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a3199b02c7815c0d03a919fc87807656a">TiledArray::detail::shape_t</a> = typedef typename T::shape_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l01174">1174</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="abeb1097bfa2f729cf40656648ed4116a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb1097bfa2f729cf40656648ed4116a">&#9670;&nbsp;</a></span>subt_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar1 , typename Scalar2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#abeb1097bfa2f729cf40656648ed4116a">TiledArray::detail::subt_t</a> = typedef decltype(std::declval&lt;Scalar1&gt;() - std::declval&lt;Scalar2&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l01156">1156</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="aaf318ba869ec2393a479afc716b081f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf318ba869ec2393a479afc716b081f4">&#9670;&nbsp;</a></span>tensor3_il</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#aaf318ba869ec2393a479afc716b081f4">TiledArray::detail::tensor3_il</a> = typedef std::initializer_list&lt;<a class="el" href="namespace_tiled_array_1_1detail.html#a1742d20935b7b111e19dd4da10428db3">matrix_il</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="initializer__list_8h_source.html#l00385">385</a> of file <a class="el" href="initializer__list_8h_source.html">initializer_list.h</a>.</p>

</div>
</div>
<a id="a1adca399248d0a48c5e912e702dc7985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adca399248d0a48c5e912e702dc7985">&#9670;&nbsp;</a></span>tensor4_il</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a1adca399248d0a48c5e912e702dc7985">TiledArray::detail::tensor4_il</a> = typedef std::initializer_list&lt;<a class="el" href="namespace_tiled_array_1_1detail.html#aaf318ba869ec2393a479afc716b081f4">tensor3_il</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="initializer__list_8h_source.html#l00389">389</a> of file <a class="el" href="initializer__list_8h_source.html">initializer_list.h</a>.</p>

</div>
</div>
<a id="a99f9d4ee3832912b4bcd51316feb99e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f9d4ee3832912b4bcd51316feb99e6">&#9670;&nbsp;</a></span>tensor5_il</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a99f9d4ee3832912b4bcd51316feb99e6">TiledArray::detail::tensor5_il</a> = typedef std::initializer_list&lt;<a class="el" href="namespace_tiled_array_1_1detail.html#a1adca399248d0a48c5e912e702dc7985">tensor4_il</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="initializer__list_8h_source.html#l00393">393</a> of file <a class="el" href="initializer__list_8h_source.html">initializer_list.h</a>.</p>

</div>
</div>
<a id="afe872421c2ccfb55ec6e98e9f139086d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe872421c2ccfb55ec6e98e9f139086d">&#9670;&nbsp;</a></span>tensor6_il</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#afe872421c2ccfb55ec6e98e9f139086d">TiledArray::detail::tensor6_il</a> = typedef std::initializer_list&lt;<a class="el" href="namespace_tiled_array_1_1detail.html#a99f9d4ee3832912b4bcd51316feb99e6">tensor5_il</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="initializer__list_8h_source.html#l00397">397</a> of file <a class="el" href="initializer__list_8h_source.html">initializer_list.h</a>.</p>

</div>
</div>
<a id="a06e12c23ae1ad65ad65ef54b041abb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e12c23ae1ad65ad65ef54b041abb37">&#9670;&nbsp;</a></span>trange_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a06e12c23ae1ad65ad65ef54b041abb37">TiledArray::detail::trange_t</a> = typedef typename T::trange_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l01171">1171</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a8a4894269f42087aba45c572ad95aae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4894269f42087aba45c572ad95aae0">&#9670;&nbsp;</a></span>value_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a8a4894269f42087aba45c572ad95aae0">TiledArray::detail::value_t</a> = typedef <a class="el" href="namespace_tiled_array_1_1detail.html#a8d14af13df5092911ff84d4c1e8b0461">remove_cvr_t</a>&lt;decltype(*std::begin(std::declval&lt;T&amp;&gt;()))&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>a range type <code>value_t&lt;T&gt;</code> is the value type, i.e. the type to which <code>std::begin(T&amp;)</code> dereferences to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>will be replaced by C++20 ranges::value_t </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l01113">1113</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a4c255a1c329b316421179dcb22fb044b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c255a1c329b316421179dcb22fb044b">&#9670;&nbsp;</a></span>vector_il</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a4c255a1c329b316421179dcb22fb044b">TiledArray::detail::vector_il</a> = typedef std::initializer_list&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="initializer__list_8h_source.html#l00377">377</a> of file <a class="el" href="initializer__list_8h_source.html">initializer_list.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af61cbefb29ceef11f580804c689464d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61cbefb29ceef11f580804c689464d1">&#9670;&nbsp;</a></span>abs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::detail::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00270">270</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_af61cbefb29ceef11f580804c689464d1_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_af61cbefb29ceef11f580804c689464d1_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_af61cbefb29ceef11f580804c689464d1_cgraph" id="anamespace_tiled_array_1_1detail_af61cbefb29ceef11f580804c689464d1_cgraph">
<area shape="rect" title=" " alt="" coords="5,39,169,65"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a96bafe4052acf5d99d2ef8010f362648" title=" " alt="" coords="217,5,381,32"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html#a941fc6f3a110343828055a79096748ec" title=" " alt="" coords="218,56,381,112"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_af61cbefb29ceef11f580804c689464d1_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_af61cbefb29ceef11f580804c689464d1_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_af61cbefb29ceef11f580804c689464d1_icgraph" id="anamespace_tiled_array_1_1detail_af61cbefb29ceef11f580804c689464d1_icgraph">
<area shape="rect" title=" " alt="" coords="732,238,896,265"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a5f7a6a051f5d87261a8b71a078d68624" title="Absolute maximum element." alt="" coords="481,5,672,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aadf392a65c7edfe026984dc11b0d47d8" title="Absolute maximum element." alt="" coords="478,71,675,112"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#ae6914ca99f535592a4477df637511b58" title="Absolute minimum element." alt="" coords="483,136,670,177"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a19eafabec70f0ff8c67d5a48a41db533" title="Absolute minimum element." alt="" coords="480,201,673,243"/>
<area shape="rect" href="class_tiled_array_1_1_sparse_shape.html#a6e638781d0d2ec4347947b7ed627b9e5" title=" " alt="" coords="471,267,683,294"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1linalg_1_1_d_i_i_s.html#a7785ec26d7d007cf4f4d1f0fddf303fe" title=" " alt="" coords="469,318,684,374"/>
<area shape="rect" href="class_tiled_array_1_1_abs_min_reduction.html#acf3f9d18d0be4c35a32cf796ed015391" title=" " alt="" coords="472,399,681,440"/>
<area shape="rect" href="class_tiled_array_1_1_abs_max_reduction.html#ab05cf71172dd6761932d3053d5be99bb" title=" " alt="" coords="470,464,683,505"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1linalg_1_1_d_i_i_s.html#abf98aae362b3e309c5cfa170ae305ba2" title=" " alt="" coords="247,325,421,367"/>
<area shape="rect" href="struct_tiled_array_1_1math_1_1linalg_1_1_conjugate_gradient_solver.html#a76d41343afbc8d219dcaafb4ab32a64e" title=" " alt="" coords="5,318,199,374"/>
</map>
</div>

</div>
</div>
<a id="a96bafe4052acf5d99d2ef8010f362648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96bafe4052acf5d99d2ef8010f362648">&#9670;&nbsp;</a></span>abs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int TiledArray::detail::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00274">274</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a96bafe4052acf5d99d2ef8010f362648_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a96bafe4052acf5d99d2ef8010f362648_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a96bafe4052acf5d99d2ef8010f362648_icgraph" id="anamespace_tiled_array_1_1detail_a96bafe4052acf5d99d2ef8010f362648_icgraph">
<area shape="rect" title=" " alt="" coords="944,238,1108,265"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#af61cbefb29ceef11f580804c689464d1" title=" " alt="" coords="732,238,896,265"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a5f7a6a051f5d87261a8b71a078d68624" title="Absolute maximum element." alt="" coords="481,5,672,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aadf392a65c7edfe026984dc11b0d47d8" title="Absolute maximum element." alt="" coords="478,71,675,112"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#ae6914ca99f535592a4477df637511b58" title="Absolute minimum element." alt="" coords="483,136,670,177"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a19eafabec70f0ff8c67d5a48a41db533" title="Absolute minimum element." alt="" coords="480,201,673,243"/>
<area shape="rect" href="class_tiled_array_1_1_sparse_shape.html#a6e638781d0d2ec4347947b7ed627b9e5" title=" " alt="" coords="471,267,683,294"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1linalg_1_1_d_i_i_s.html#a7785ec26d7d007cf4f4d1f0fddf303fe" title=" " alt="" coords="469,318,684,374"/>
<area shape="rect" href="class_tiled_array_1_1_abs_min_reduction.html#acf3f9d18d0be4c35a32cf796ed015391" title=" " alt="" coords="472,399,681,440"/>
<area shape="rect" href="class_tiled_array_1_1_abs_max_reduction.html#ab05cf71172dd6761932d3053d5be99bb" title=" " alt="" coords="470,464,683,505"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1linalg_1_1_d_i_i_s.html#abf98aae362b3e309c5cfa170ae305ba2" title=" " alt="" coords="247,325,421,367"/>
<area shape="rect" href="struct_tiled_array_1_1math_1_1linalg_1_1_conjugate_gradient_solver.html#a76d41343afbc8d219dcaafb4ab32a64e" title=" " alt="" coords="5,318,199,374"/>
</map>
</div>

</div>
</div>
<a id="a72ea1372c2353060fba2943065fcc26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ea1372c2353060fba2943065fcc26f">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeneralizedPair , typename  = std::enable_if_t&lt;is_gpair_v&lt;GeneralizedPair&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) TiledArray::detail::at </td>
          <td>(</td>
          <td class="paramtype">GeneralizedPair &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>at(pair, i)</code> extracts i-th element from gpair </p>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l01268">1268</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a72ea1372c2353060fba2943065fcc26f_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a72ea1372c2353060fba2943065fcc26f_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a72ea1372c2353060fba2943065fcc26f_icgraph" id="anamespace_tiled_array_1_1detail_a72ea1372c2353060fba2943065fcc26f_icgraph">
<area shape="rect" title="at(pair, i) extracts i&#45;th element from gpair" alt="" coords="336,60,491,87"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_blk_tsr_expr_base.html#a1cef296df22d5e802c41ef108483588e" title="Block expression constructor." alt="" coords="5,5,288,61"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_bipartite_index_list.html#aa63a683ac69b98c163ad0c01beb4fbda" title=" " alt="" coords="59,85,234,141"/>
</map>
</div>

</div>
</div>
<a id="ab3099e3f966559b8e09bca8d63327117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3099e3f966559b8e09bca8d63327117">&#9670;&nbsp;</a></span>clone_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::detail::clone_range </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of the range of the tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor with the range to be cloned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A contiguous range with the same lower and upper bounds as the range of <code>tensor</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00047">47</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ab3099e3f966559b8e09bca8d63327117_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_ab3099e3f966559b8e09bca8d63327117_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ab3099e3f966559b8e09bca8d63327117_icgraph" id="anamespace_tiled_array_1_1detail_ab3099e3f966559b8e09bca8d63327117_icgraph">
<area shape="rect" title="Create a copy of the range of the tensor." alt="" coords="687,153,820,195"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ae11a9e70ba98eccc31ef6b8a265cc369" title="Use a binary, element wise operation to construct a new tensor." alt="" coords="450,80,629,121"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a864d3eed3caa265526a36b1e042aaeb9" title=" " alt="" coords="440,153,639,195"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ae5f80c1e7c2e5855313fad6ad10375b3" title="Use a unary, element wise operation to construct a new tensor." alt="" coords="452,235,627,276"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a0ef9fb1d4cd22af3bb02002209eb31f0" title="Add this and other to construct a new tensors." alt="" coords="225,5,387,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#af0e2f37b46d3c3c0fcc3ab77d8594b6f" title="Multiply this by right to create a new tensor." alt="" coords="222,71,390,112"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a8361c0f82bfdfcf468247cf566c87a89" title="Subtract this and right to construct a new tensor." alt="" coords="223,136,389,177"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a0f3da596fb623188a555eee31e968225" title="Subtract a constant from a copy of this tensor." alt="" coords="5,5,172,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a31362893bb066fe8568529f881028611" title="Add a constant to a copy of this tensor." alt="" coords="225,201,387,243"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a115f6c8f776a9d58a238dfc810758b34" title="Create a negated copy of this tensor." alt="" coords="225,267,387,308"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a4738cdadac53a8979ffb09d1409e0a1e" title="Construct a scaled copy of this tensor." alt="" coords="220,332,392,373"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#abe962a9632cf8da0e5bbcf7c12420acd" title="Create a complex conjugated copy of this tensor." alt="" coords="6,332,171,373"/>
</map>
</div>

</div>
</div>
<a id="afd25794432f3ae654ef616a170280af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd25794432f3ae654ef616a170280af3">&#9670;&nbsp;</a></span>clone_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; !is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_range.html">Range</a> TiledArray::detail::clone_range </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a contiguous copy of the range of the tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor with the range to be cloned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A contiguous range with the same lower and upper bounds as the range of <code>tensor</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00059">59</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a id="a32a7abe197b45ae95a4132fc240ed383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a7abe197b45ae95a4132fc240ed383">&#9670;&nbsp;</a></span>conj() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename std::enable_if&lt; is_numeric_v&lt; R &gt; &amp;&amp;!is_complex&lt; R &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE R TiledArray::detail::conj </td>
          <td>(</td>
          <td class="paramtype">const R&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper function for <code>std::conj</code> </p>
<p>This function disables the call to <code>std::conj</code> for real values to prevent the result from being converted into a complex value. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>A real scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The real scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>r</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00045">45</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a32a7abe197b45ae95a4132fc240ed383_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a32a7abe197b45ae95a4132fc240ed383_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a32a7abe197b45ae95a4132fc240ed383_icgraph" id="anamespace_tiled_array_1_1detail_a32a7abe197b45ae95a4132fc240ed383_icgraph">
<area shape="rect" title="Wrapper function for std::conj" alt="" coords="252,203,385,244"/>
<area shape="rect" href="namespace_tiled_array_1_1expressions.html#ae722690ae817f2c2c146501b91571b63" title="Conjugated addition expression factor." alt="" coords="17,5,192,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_contract_reduce_3_01_result_00_01_left_00_01_right_00_01_tiled_a9a56f685ff213c256976617604736135.html#a1d62bd1335311d0dbe8238448ec6d588" title="Post processing step." alt="" coords="5,71,204,157"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_contract_reduce_3_01_result_00_01_left_00_01_right_00_01_tiled_ac747358d5737d2beb853a2e1d5509b1f.html#a45a9acd171ceb8dc827b91bd9274eccd" title="Post processing step." alt="" coords="5,181,204,266"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#ad02d47cab0fc5866bf2eb5c13acf659b" title=" " alt="" coords="38,291,171,332"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#acea2c5a93d37330153912da87c7c3877" title=" " alt="" coords="38,356,171,397"/>
</map>
</div>

</div>
</div>
<a id="a381e9dfb596a18e208171ce358fa6f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381e9dfb596a18e208171ce358fa6f16">&#9670;&nbsp;</a></span>conj() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE std::complex&lt;R&gt; TiledArray::detail::conj </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; R &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper function for std::conj. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>The scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>The complex scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The complex conjugate of <code>z</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00055">55</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>

</div>
</div>
<a id="ab2c470158b2bbbdb712cbbaf18a55101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c470158b2bbbdb712cbbaf18a55101">&#9670;&nbsp;</a></span>conj_op() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt;void&gt; TiledArray::detail::conj_op </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a> operator factory function. </p>
<dl class="section return"><dt>Returns</dt><dd>A complex conjugate operator </dd></dl>

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00211">211</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>

</div>
</div>
<a id="a78aafa383b1b3e69b6e57b6b78c61306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78aafa383b1b3e69b6e57b6b78c61306">&#9670;&nbsp;</a></span>conj_op() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt;S&gt; TiledArray::detail::conj_op </td>
          <td>(</td>
          <td class="paramtype">const S&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a> operator factory function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A scaling complex conjugate operator </dd></dl>

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00204">204</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a78aafa383b1b3e69b6e57b6b78c61306_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a78aafa383b1b3e69b6e57b6b78c61306_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a78aafa383b1b3e69b6e57b6b78c61306_icgraph" id="anamespace_tiled_array_1_1detail_a78aafa383b1b3e69b6e57b6b78c61306_icgraph">
<area shape="rect" title="ComplexConjugate operator factory function." alt="" coords="244,364,377,405"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_blk_tsr_expr.html#a11b87883dd26561d3ac7a252ccd37f42" title="Conjugated block tensor expression factory." alt="" coords="13,5,188,47"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_blk_tsr_expr_3_01const_01_array_00_01true_01_4.html#ab72ba1e9a6126fe2b2e45bddaf1e08ab" title="Conjugated block tensor expression factory." alt="" coords="5,71,196,127"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_tsr_expr.html#a4a4bbfbd8b479f439045e28b747a9eee" title="Conjugated&#45;tensor expression factor." alt="" coords="13,152,188,193"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_tsr_expr_3_01const_01_array_00_01true_01_4.html#a67dd7bde45b64a4376abf5b7e1d51885" title="Conjugated&#45;tensor expression factor." alt="" coords="13,218,188,274"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a78bda38f32136cd4fea2d438e13ca7ab" title="Create a complex conjugated copy of this tensor." alt="" coords="21,299,180,340"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#abe962a9632cf8da0e5bbcf7c12420acd" title="Create a complex conjugated copy of this tensor." alt="" coords="18,364,183,405"/>
<area shape="rect" href="namespace_tiled_array_1_1expressions.html#a2f6eaac7474c21d2dcf7011c9482d451" title="Conjugated addition expression factory." alt="" coords="13,429,188,471"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#af3ada2b7db72107f273a04394bdccac5" title="Complex conjugate this tensor." alt="" coords="11,495,190,536"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a176752a6002f24f0e378f27d94a8bba8" title="Complex conjugate this tensor." alt="" coords="8,560,193,601"/>
<area shape="rect" href="namespace_tiled_array_1_1expressions.html#adcbec0b860ce069ce48c75a3e0557e1b" title="Scaled&#45;conjugated addition expression factor." alt="" coords="13,625,188,667"/>
<area shape="rect" href="namespace_tiled_array_1_1expressions.html#aaebd5a10232ff66a66c441743ca395a8" title="Negated&#45;conjugated addition expression factor." alt="" coords="13,691,188,732"/>
</map>
</div>

</div>
</div>
<a id="aead432075c6c7f2e9f7c329c96bc4d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead432075c6c7f2e9f7c329c96bc4d4a">&#9670;&nbsp;</a></span>counted_btas_subtensor_to_tensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DistArray_ , typename BTAS_Tensor_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::counted_btas_subtensor_to_tensor </td>
          <td>(</td>
          <td class="paramtype">const BTAS_Tensor_ *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DistArray_ *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DistArray_::ordinal_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">madness::AtomicInt *&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Task function for converting btas::Tensor subblock to a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">TiledArray::DistArray</a> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DistArray_</td><td>a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">TiledArray::DistArray</a> type </td></tr>
    <tr><td class="paramname">TArgs</td><td>the type pack in btas::Tensor&lt;TArgs...&gt; type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The btas::Tensor object whose block will be copied </td></tr>
    <tr><td class="paramname">dst</td><td>The array that will hold the result </td></tr>
    <tr><td class="paramname">i</td><td>The index of the tile to be copied </td></tr>
    <tr><td class="paramname">counter</td><td>The task counter </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2btas_8h_source.html#l00126">126</a> of file <a class="el" href="conversions_2btas_8h_source.html">btas.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_aead432075c6c7f2e9f7c329c96bc4d4a_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_aead432075c6c7f2e9f7c329c96bc4d4a_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_aead432075c6c7f2e9f7c329c96bc4d4a_cgraph" id="anamespace_tiled_array_1_1detail_aead432075c6c7f2e9f7c329c96bc4d4a_cgraph">
<area shape="rect" title=" " alt="" coords="5,82,193,138"/>
<area shape="rect" href="namespace_tiled_array.html#ace7fbc10ae58bc49609c93b31fa7d4e1" title="Copy a block of a btas::Tensor into a TiledArray::Tensor." alt="" coords="241,89,436,131"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ab4da186af12caf4000fd293eaf2c744e" title="Range lower bound accessor." alt="" coords="517,5,662,47"/>
<area shape="rect" href="namespace_tiled_array.html#a4fc8675b642f53bdab884e5a6c473103" title=" " alt="" coords="484,71,695,98"/>
<area shape="rect" href="namespace_tiled_array.html#a676ce2ab1b89d4f820aba886f9ce12a7" title=" " alt="" coords="505,122,673,149"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a45190dfcad5ef2b9af5b4aa000c844b0" title=" " alt="" coords="523,173,656,215"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ac1fe1f599524763265207c84e909dd15" title="Range lower bound data accessor." alt="" coords="743,5,888,47"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a2208a1aeda0c14164e2689ee284aace2" title=" " alt="" coords="936,13,1111,39"/>
</map>
</div>

</div>
</div>
<a id="a5235a162fdccd242f61ab4fb2818bf83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5235a162fdccd242f61ab4fb2818bf83">&#9670;&nbsp;</a></span>counted_eigen_submatrix_to_tensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::counted_eigen_submatrix_to_tensor </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename A::ordinal_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">madness::AtomicInt *&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task function for converting <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> submatrix to a tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>Array type </td></tr>
    <tr><td class="paramname">Derived</td><td>The matrix type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix that will be copied </td></tr>
    <tr><td class="paramname">array</td><td>The array that will hold the result </td></tr>
    <tr><td class="paramname">i</td><td>The index of the tile to be copied </td></tr>
    <tr><td class="paramname">counter</td><td>The task counter </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00338">338</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a5235a162fdccd242f61ab4fb2818bf83_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a5235a162fdccd242f61ab4fb2818bf83_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a5235a162fdccd242f61ab4fb2818bf83_cgraph" id="anamespace_tiled_array_1_1detail_a5235a162fdccd242f61ab4fb2818bf83_cgraph">
<area shape="rect" title="Task function for converting Eigen submatrix to a tensor." alt="" coords="5,5,204,61"/>
<area shape="rect" href="namespace_tiled_array.html#ab7d37708c45657fc2af47759b65e607a" title="Copy a block of an Eigen matrix into a tensor." alt="" coords="252,13,457,54"/>
<area shape="rect" href="namespace_tiled_array.html#a03e3bc36192ae1bb9b4f6e3da001023a" title="Construct a const Eigen::Map object for a given Tensor object." alt="" coords="505,20,673,47"/>
</map>
</div>

</div>
</div>
<a id="aae305e910ce674d71f550e104c354cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae305e910ce674d71f550e104c354cb5">&#9670;&nbsp;</a></span>counted_tensor_to_btas_subtensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TA_Tensor_ , typename BTAS_Tensor_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::counted_tensor_to_btas_subtensor </td>
          <td>(</td>
          <td class="paramtype">const TA_Tensor_ &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BTAS_Tensor_ *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">madness::AtomicInt *&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task function for assigning a tensor to an <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> submatrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tensor_</td><td>a <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">TiledArray::Tensor</a> type </td></tr>
    <tr><td class="paramname">TArgs</td><td>the type pack in btas::Tensor&lt;TArgs...&gt; type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source tensor </td></tr>
    <tr><td class="paramname">dst</td><td>The destination tensor </td></tr>
    <tr><td class="paramname">counter</td><td>The task counter </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2btas_8h_source.html#l00143">143</a> of file <a class="el" href="conversions_2btas_8h_source.html">btas.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_aae305e910ce674d71f550e104c354cb5_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_aae305e910ce674d71f550e104c354cb5_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_aae305e910ce674d71f550e104c354cb5_cgraph" id="anamespace_tiled_array_1_1detail_aae305e910ce674d71f550e104c354cb5_cgraph">
<area shape="rect" title="Task function for assigning a tensor to an Eigen submatrix." alt="" coords="5,82,156,138"/>
<area shape="rect" href="namespace_tiled_array.html#ad8cb3eac6d5a72fae3c98b4d78f5b77a" title="Copy a block of a btas::Tensor into a TiledArray::Tensor." alt="" coords="204,89,352,131"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ab4da186af12caf4000fd293eaf2c744e" title="Range lower bound accessor." alt="" coords="433,5,578,47"/>
<area shape="rect" href="namespace_tiled_array.html#a4fc8675b642f53bdab884e5a6c473103" title=" " alt="" coords="400,71,611,98"/>
<area shape="rect" href="namespace_tiled_array.html#a676ce2ab1b89d4f820aba886f9ce12a7" title=" " alt="" coords="421,122,589,149"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a45190dfcad5ef2b9af5b4aa000c844b0" title=" " alt="" coords="439,173,572,215"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ac1fe1f599524763265207c84e909dd15" title="Range lower bound data accessor." alt="" coords="659,5,804,47"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a2208a1aeda0c14164e2689ee284aace2" title=" " alt="" coords="852,13,1027,39"/>
</map>
</div>

</div>
</div>
<a id="afe493525138ef355ba76900e56ae8cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe493525138ef355ba76900e56ae8cf2">&#9670;&nbsp;</a></span>counted_tensor_to_eigen_submatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::counted_tensor_to_eigen_submatrix </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; Derived &gt; *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">madness::AtomicInt *&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task function for assigning a tensor to an <a class="el" href="namespace_eigen.html" title="Forward declarations.">Eigen</a> submatrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>The matrix type </td></tr>
    <tr><td class="paramname">T</td><td><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix to be assigned </td></tr>
    <tr><td class="paramname">tensor</td><td>The tensor to be copied </td></tr>
    <tr><td class="paramname">counter</td><td>The task counter </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00356">356</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_afe493525138ef355ba76900e56ae8cf2_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_afe493525138ef355ba76900e56ae8cf2_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_afe493525138ef355ba76900e56ae8cf2_cgraph" id="anamespace_tiled_array_1_1detail_afe493525138ef355ba76900e56ae8cf2_cgraph">
<area shape="rect" title="Task function for assigning a tensor to an Eigen submatrix." alt="" coords="5,5,156,61"/>
<area shape="rect" href="namespace_tiled_array.html#a3f423f82e222f193a882c9ea1cb7567f" title="Copy the content of a tensor into an Eigen matrix block." alt="" coords="204,13,363,54"/>
<area shape="rect" href="namespace_tiled_array.html#a03e3bc36192ae1bb9b4f6e3da001023a" title="Construct a const Eigen::Map object for a given Tensor object." alt="" coords="411,20,579,47"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_afe493525138ef355ba76900e56ae8cf2_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_afe493525138ef355ba76900e56ae8cf2_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_afe493525138ef355ba76900e56ae8cf2_icgraph" id="anamespace_tiled_array_1_1detail_afe493525138ef355ba76900e56ae8cf2_icgraph">
<area shape="rect" title="Task function for assigning a tensor to an Eigen submatrix." alt="" coords="204,5,355,61"/>
<area shape="rect" href="namespace_tiled_array.html#ad4ffc6de9b633a34e7d724191cd11f3f" title="Convert an Array object into an Eigen matrix object." alt="" coords="5,13,156,54"/>
</map>
</div>

</div>
</div>
<a id="ae2c7d290f2fb4704eecc33b0894de068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c7d290f2fb4704eecc33b0894de068">&#9670;&nbsp;</a></span>diagonal_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_range.html">Range</a> TiledArray::detail::diagonal_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_range.html">Range</a> const &amp;&#160;</td>
          <td class="paramname"><em>rng</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a range of the diagonal elements (if any) in a rank-d <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a>. </p>
<p>computes [min,max) describing the diagonal elements that rank-d <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a> contains; if the input <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a> contains no diagonal elements this return an empty <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a></p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rng</td><td>an input (rank-d) <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range of diagonal elements, as a rank-1 <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">Range</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="diagonal__array_8h_source.html#l00045">45</a> of file <a class="el" href="diagonal__array_8h_source.html">diagonal_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ae2c7d290f2fb4704eecc33b0894de068_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_ae2c7d290f2fb4704eecc33b0894de068_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ae2c7d290f2fb4704eecc33b0894de068_cgraph" id="anamespace_tiled_array_1_1detail_ae2c7d290f2fb4704eecc33b0894de068_cgraph">
<area shape="rect" title="Computes a range of the diagonal elements (if any) in a rank&#45;d Range." alt="" coords="5,93,139,135"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ac1fe1f599524763265207c84e909dd15" title="Range lower bound data accessor." alt="" coords="201,5,347,47"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a491195742ae543d2e53d2234bbd0b631" title="Rank accessor." alt="" coords="187,71,361,98"/>
<area shape="rect" href="namespace_tiled_array.html#ae6e2da9f3855369c97e61e9105cce50a" title=" " alt="" coords="211,189,337,215"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a7ee2666c973a1cc4a17845f6a410dbe9" title="Range upper bound data accessor." alt="" coords="201,123,347,164"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a2208a1aeda0c14164e2689ee284aace2" title=" " alt="" coords="409,71,584,98"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="418,181,575,223"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ae2c7d290f2fb4704eecc33b0894de068_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_ae2c7d290f2fb4704eecc33b0894de068_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ae2c7d290f2fb4704eecc33b0894de068_icgraph" id="anamespace_tiled_array_1_1detail_ae2c7d290f2fb4704eecc33b0894de068_icgraph">
<area shape="rect" title="Computes a range of the diagonal elements (if any) in a rank&#45;d Range." alt="" coords="407,79,540,120"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a33aa537f17e1c4de2e8abf7093e29699" title="computes shape data (i.e. Frobenius norms of the tiles) for a constant diagonal tensor" alt="" coords="215,5,349,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a8c268a352be16fc597e6ad2c7d6a7560" title="Writes tiles of a nonconstant diagonal array." alt="" coords="205,71,359,127"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a808571423d2d6d551e9844f0b38369a8" title="Writes tiles of a constant diagonal array." alt="" coords="205,151,359,207"/>
<area shape="rect" href="namespace_tiled_array.html#a8d2668989011ee62fa6314733cfc4a32" title="Creates a constant diagonal DistArray." alt="" coords="5,83,157,124"/>
</map>
</div>

</div>
</div>
<a id="a354bb1fd3beebc3c8c47805bc43cd01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354bb1fd3beebc3c8c47805bc43cd01c">&#9670;&nbsp;</a></span>diagonal_shape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator.html">is_iterator</a>&lt;RandomAccessIterator&gt;::value, <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;float&gt; &gt; TiledArray::detail::diagonal_shape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> const &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>diagonals_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>diagonals_end</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes shape data (i.e. Frobenius norms of the tiles) for a non-constant diagonal tensor </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomAccessIterator</td><td>an iterator over the range of diagonal elements</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trange</td><td>a <a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array.">TiledRange</a> of the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diagonals_begin</td><td>the begin iterator of the range of the diagonals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diagonals_end</td><td>the end iterator of the range of the diagonals; if not given, default initialized and thus will not be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a Tensor&lt;float&gt; containing the Frobenius norms of the tiles of a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> with <code>val</code> on the diagonal and zeroes elsewhere </dd></dl>

<p class="definition">Definition at line <a class="el" href="diagonal__array_8h_source.html#l00110">110</a> of file <a class="el" href="diagonal__array_8h_source.html">diagonal_array.h</a>.</p>

</div>
</div>
<a id="a33aa537f17e1c4de2e8abf7093e29699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33aa537f17e1c4de2e8abf7093e29699">&#9670;&nbsp;</a></span>diagonal_shape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;float&gt; TiledArray::detail::diagonal_shape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> const &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes shape data (i.e. Frobenius norms of the tiles) for a constant diagonal tensor </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>a numeric type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trange</td><td>a <a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array.">TiledRange</a> of the result</td></tr>
    <tr><td class="paramname">val</td><td>value of the diagonal elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a Tensor&lt;float&gt; containing the Frobenius norms of the tiles of a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> with <code>val</code> on the diagonal and zeroes elsewhere </dd></dl>

<p class="definition">Definition at line <a class="el" href="diagonal__array_8h_source.html#l00070">70</a> of file <a class="el" href="diagonal__array_8h_source.html">diagonal_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a33aa537f17e1c4de2e8abf7093e29699_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a33aa537f17e1c4de2e8abf7093e29699_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a33aa537f17e1c4de2e8abf7093e29699_cgraph" id="anamespace_tiled_array_1_1detail_a33aa537f17e1c4de2e8abf7093e29699_cgraph">
<area shape="rect" title="computes shape data (i.e. Frobenius norms of the tiles) for a constant diagonal tensor" alt="" coords="5,305,139,347"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#ae2c7d290f2fb4704eecc33b0894de068" title="Computes a range of the diagonal elements (if any) in a rank&#45;d Range." alt="" coords="205,123,338,164"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a0e4a2c7494c37bf43a7aa51387c8e596" title="Convert an element index to a tile index." alt="" coords="187,188,356,229"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#ac8c1d53822fd3da51824e4d97a11dd2a" title="The rank accessor." alt="" coords="407,247,576,288"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a968fbd936a1606e7885e0912a739f331" title="Access the element range." alt="" coords="187,305,356,347"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ae240375dff3cdc73e249dfa9ee91c1b4" title="Range extent accessor." alt="" coords="199,371,344,412"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a3b9b907038dcf65d86d1bc12811c8333" title="Construct a range for the tile indexed by the given ordinal index." alt="" coords="187,436,356,477"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a1980b233eaa1fc559b62cc8affc2bd34" title="Access the tile range." alt="" coords="407,465,576,507"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ac1fe1f599524763265207c84e909dd15" title="Range lower bound data accessor." alt="" coords="419,64,564,105"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a491195742ae543d2e53d2234bbd0b631" title="Rank accessor." alt="" coords="404,195,579,222"/>
<area shape="rect" href="namespace_tiled_array.html#ae6e2da9f3855369c97e61e9105cce50a" title=" " alt="" coords="429,13,554,39"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a7ee2666c973a1cc4a17845f6a410dbe9" title="Range upper bound data accessor." alt="" coords="419,129,564,171"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a2208a1aeda0c14164e2689ee284aace2" title=" " alt="" coords="627,137,801,163"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="635,5,793,47"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ad3a6a74a7146b195f299c49c843b6fa5" title="Range extent data accessor." alt="" coords="419,341,564,383"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a33aa537f17e1c4de2e8abf7093e29699_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a33aa537f17e1c4de2e8abf7093e29699_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a33aa537f17e1c4de2e8abf7093e29699_icgraph" id="anamespace_tiled_array_1_1detail_a33aa537f17e1c4de2e8abf7093e29699_icgraph">
<area shape="rect" title="computes shape data (i.e. Frobenius norms of the tiles) for a constant diagonal tensor" alt="" coords="205,5,339,47"/>
<area shape="rect" href="namespace_tiled_array.html#a8d2668989011ee62fa6314733cfc4a32" title="Creates a constant diagonal DistArray." alt="" coords="5,5,157,47"/>
</map>
</div>

</div>
</div>
<a id="a05c44cde899d571534b6ff2e9d22ed75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c44cde899d571534b6ff2e9d22ed75">&#9670;&nbsp;</a></span>dummy_annotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string TiledArray::detail::dummy_annotation </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n_outer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n_inner_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="annotation_8h_source.html#l00035">35</a> of file <a class="el" href="annotation_8h_source.html">annotation.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a05c44cde899d571534b6ff2e9d22ed75_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a05c44cde899d571534b6ff2e9d22ed75_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a05c44cde899d571534b6ff2e9d22ed75_icgraph" id="anamespace_tiled_array_1_1detail_a05c44cde899d571534b6ff2e9d22ed75_icgraph">
<area shape="rect" title=" " alt="" coords="1005,505,1163,547"/>
<area shape="rect" href="namespace_tiled_array.html#a37032bc091e5e9452a6385ebbce0dc94" title=" " alt="" coords="785,97,940,123"/>
<area shape="rect" href="namespace_tiled_array.html#ad09edca89f7e0f6b29c03206118a9c49" title=" " alt="" coords="787,315,938,342"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg.html#a92c5af2b767e01e343ac5bbede88b0b8" title=" " alt="" coords="507,509,682,551"/>
<area shape="rect" href="namespace_tiled_array.html#a56e8a14dc06218506b921b90d86bf622" title=" " alt="" coords="804,458,921,485"/>
<area shape="rect" href="namespace_tiled_array.html#a2108251710c269618bbdf6291f16a340" title=" " alt="" coords="770,641,955,667"/>
<area shape="rect" href="namespace_tiled_array.html#a93e85683a584368627bbc160569c246f" title=" " alt="" coords="797,563,928,590"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg.html#aed164664129bc2babc1ee7122c06fad2" title=" " alt="" coords="775,785,950,827"/>
<area shape="rect" href="namespace_tiled_array.html#a2208f3d88d7e5293d2fc6b1fc01768fd" title=" " alt="" coords="768,969,957,995"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg.html#aedd5240dad16cf9d351dbc30b34568e6" title=" " alt="" coords="247,224,421,265"/>
<area shape="rect" href="group___tile_interface.html#ga86214f440122e8aac85a93dce17e0d7d" title="Absolute maximum element of a tile." alt="" coords="517,71,672,98"/>
<area shape="rect" href="struct_tiled_array_1_1math_1_1linalg_1_1_conjugate_gradient_solver.html#a76d41343afbc8d219dcaafb4ab32a64e" title=" " alt="" coords="5,590,199,646"/>
<area shape="rect" href="class_tiled_array_1_1_abs_max_reduction.html#ad9c41c32c3fd91dc3f89cd2202b9e202" title=" " alt="" coords="488,5,701,47"/>
<area shape="rect" href="group___tile_interface.html#gac89ec1d5bad433cb8a9ee8612a6d88fd" title="Absolute mainimum element of a tile." alt="" coords="519,290,670,317"/>
<area shape="rect" href="class_tiled_array_1_1_abs_min_reduction.html#a1df628e219703bf23d42ebf0ddb3e930" title=" " alt="" coords="490,224,699,265"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1linalg_1_1_d_i_i_s.html#abf98aae362b3e309c5cfa170ae305ba2" title=" " alt="" coords="247,743,421,784"/>
<area shape="rect" href="group___tile_interface.html#gaf71813b13896a29698efff4232719d70" title="Vector dot product of a tile." alt="" coords="536,458,653,485"/>
<area shape="rect" href="class_tiled_array_1_1_dot_reduction.html#ae9f6343d37bfa088e4a28896cac26f7a" title=" " alt="" coords="503,392,687,433"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1linalg_1_1_d_i_i_s.html#a7785ec26d7d007cf4f4d1f0fddf303fe" title=" " alt="" coords="487,742,702,798"/>
<area shape="rect" href="group___tile_interface.html#gac817534360dc7eb173c22113bc49522f" title="Vector inner product of a tile." alt="" coords="502,641,687,667"/>
<area shape="rect" href="class_tiled_array_1_1_inner_product_reduction.html#aeb0e3c839f596a9ad5cf626ba6fee0f0" title=" " alt="" coords="505,575,684,616"/>
<area shape="rect" href="namespace_tiled_array_1_1math_1_1linalg.html#a1ad6389967920621411c2d56b487605b" title=" " alt="" coords="507,823,682,864"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1linalg_1_1_d_i_i_s.html#a1e21c0afce21586679b3ab7c5983bcd0" title=" " alt="" coords="247,823,421,864"/>
<area shape="rect" href="namespace_tiled_array.html#a736de0045a7f48b5df63e3137260e40b" title=" " alt="" coords="265,939,403,966"/>
<area shape="rect" href="class_tiled_array_1_1_squared_norm_reduction.html#ae29200c16028bc21d3a944a09f042a9c" title=" " alt="" coords="469,991,720,1032"/>
<area shape="rect" href="group___tile_interface.html#ga0367bc300cd4417138d2ac139048c234" title="Squared vector 2&#45;norm of the elements of a tile." alt="" coords="500,1057,689,1083"/>
</map>
</div>

</div>
</div>
<a id="a2b25c9db0387e3327718de2cbc9112c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b25c9db0387e3327718de2cbc9112c6">&#9670;&nbsp;</a></span>empty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool TiledArray::detail::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for empty tensors in an empty list. </p>
<p>This function is used as the termination step for the recursive <a class="el" href="namespace_tiled_array_1_1detail.html#a2b25c9db0387e3327718de2cbc9112c6" title="Test for empty tensors in an empty list.">empty()</a> function. It also handles the case where there are no tensors in the list. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00320">320</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a2b25c9db0387e3327718de2cbc9112c6_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a2b25c9db0387e3327718de2cbc9112c6_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a2b25c9db0387e3327718de2cbc9112c6_icgraph" id="anamespace_tiled_array_1_1detail_a2b25c9db0387e3327718de2cbc9112c6_icgraph">
<area shape="rect" title="Test for empty tensors in an empty list." alt="" coords="1073,500,1207,541"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#ad9662eaa03fe6d3cdbe380e9cf5dea3e" title="Test for empty tensors." alt="" coords="844,172,977,213"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#ac7c2574bd1506d0e811e2c0eb58fb1e3" title="In&#45;place tensor operations with contiguous data." alt="" coords="837,237,985,279"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_contract_reduce.html#a3edb113a3e4524ffa21985587b0b7311" title="Post processing step." alt="" coords="796,303,1025,432"/>
<area shape="rect" href="struct_tiled_array_1_1detail_1_1transform.html#ae00da3d0d2f66eecc0bd866b737d1008" title=" " alt="" coords="827,456,994,497"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_contract_reduce_3_01_result_00_01_left_00_01_right_00_01_tiled_a9a56f685ff213c256976617604736135.html#a1d62bd1335311d0dbe8238448ec6d588" title="Post processing step." alt="" coords="811,522,1010,607"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_contract_reduce_3_01_result_00_01_left_00_01_right_00_01_tiled_ac747358d5737d2beb853a2e1d5509b1f.html#a45a9acd171ceb8dc827b91bd9274eccd" title="Post processing step." alt="" coords="811,631,1010,717"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a2fa32053a2cef8c73b71763a0e01cd95" title="Initialize tensor with contiguous tensor arguments." alt="" coords="844,741,977,783"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#ab957a79bba9735ad3e405dbb8dd53796" title="Reduction operation for contiguous tensors." alt="" coords="844,1177,977,1219"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a272585651b1233bb8f90d23c88a12c61" title="Use a binary, element wise operation to modify this tensor." alt="" coords="544,11,723,67"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aedf1dc6f6754af31fdfcc8ee86b0c73d" title="Use a binary, element wise operation to modify this tensor." alt="" coords="541,91,726,147"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#af23df0d855cd33e6e977bd39e780ca9a" title="Use a unary, element wise operation to modify this tensor." alt="" coords="522,172,745,213"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a8cc4b0e0e82ab58dad40a01b4530b94b" title="Use a unary, element wise operation to modify this tensor." alt="" coords="519,237,748,279"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a864d3eed3caa265526a36b1e042aaeb9" title=" " alt="" coords="534,303,733,344"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a70f6e8ca6afdfd889fac691a39f7a57e" title=" " alt="" coords="531,368,735,409"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html#a6f2e00b7e50f7ba5858e3fa472d3e917" title="Assignment operator." alt="" coords="539,433,727,475"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a2d65efd4c6093a5373e836d74619b738" title="Add other to this tensor." alt="" coords="264,5,447,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a2cd3d6f515b31751c9fcc26e48f2e3ed" title="Multiply this tensor by right." alt="" coords="261,71,449,112"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a69ca8d8ac4237fb53887d69ffc4c5225" title="Subtract right from this tensor." alt="" coords="262,136,449,177"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ac61eb093688f07b96c65966428502452" title="Subtract a constant from this tensor." alt="" coords="5,5,192,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a5c3cfbd8b10ff2801543f4584d753a5f" title="Add a constant to this tensor." alt="" coords="264,201,447,243"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ae8094e4b120557459a28f1f21513f774" title="Negate elements of this tensor." alt="" coords="264,267,447,308"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#afdf25cc0015b6214fac0682074137d33" title="Scale this tensor." alt="" coords="259,332,451,373"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a176752a6002f24f0e378f27d94a8bba8" title="Complex conjugate this tensor." alt="" coords="6,332,191,373"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ae11a9e70ba98eccc31ef6b8a265cc369" title="Use a binary, element wise operation to construct a new tensor." alt="" coords="544,611,723,652"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aebc5c8b00cc397f5ba32ea426d1ddcc3" title=" " alt="" coords="537,676,730,717"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#ad06d56e445f36d572109abbafc1a32e5" title="Construct a tensor with a fill value." alt="" coords="546,741,721,783"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ae5f80c1e7c2e5855313fad6ad10375b3" title="Use a unary, element wise operation to construct a new tensor." alt="" coords="546,807,721,848"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a0ef9fb1d4cd22af3bb02002209eb31f0" title="Add this and other to construct a new tensors." alt="" coords="274,545,437,587"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#af0e2f37b46d3c3c0fcc3ab77d8594b6f" title="Multiply this by right to create a new tensor." alt="" coords="271,611,439,652"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a8361c0f82bfdfcf468247cf566c87a89" title="Subtract this and right to construct a new tensor." alt="" coords="272,676,439,717"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a0f3da596fb623188a555eee31e968225" title="Subtract a constant from a copy of this tensor." alt="" coords="15,545,182,587"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a31362893bb066fe8568529f881028611" title="Add a constant to a copy of this tensor." alt="" coords="274,741,437,783"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a115f6c8f776a9d58a238dfc810758b34" title="Create a negated copy of this tensor." alt="" coords="274,807,437,848"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a4738cdadac53a8979ffb09d1409e0a1e" title="Construct a scaled copy of this tensor." alt="" coords="269,872,441,913"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#abe962a9632cf8da0e5bbcf7c12420acd" title="Create a complex conjugated copy of this tensor." alt="" coords="16,872,181,913"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aad1e3e351ce4d80310c368f77375198c" title="Unary reduction operation." alt="" coords="542,1177,725,1219"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#ac7e2825494e7578e27becf11d2a6b794" title="Unary reduction operation." alt="" coords="545,1243,721,1284"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aadf392a65c7edfe026984dc11b0d47d8" title="Absolute maximum element." alt="" coords="257,937,454,979"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a19eafabec70f0ff8c67d5a48a41db533" title="Absolute minimum element." alt="" coords="259,1003,452,1044"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a2f3626dbf2d39bbc8abcd9c9c4c31b46" title="Vector dot product." alt="" coords="276,1068,435,1109"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a8690764d8a2dddcae1c41ffd903f9741" title=" " alt="" coords="270,1134,441,1190"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#af3a337e3cd4f50cb9bbcc4abc3e54bc1" title="Maximum element." alt="" coords="272,1215,439,1256"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#af06857f977bbfd0e4ea9fca89ed7bc2e" title="Minimum element." alt="" coords="274,1280,437,1321"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#af055ceb310d932e5ca4041972e86edd5" title="Product of elements." alt="" coords="262,1345,449,1387"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#acb4cc909b548c92259bba323ff9a1c08" title="Square of vector 2&#45;norm." alt="" coords="240,1411,471,1452"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a95349207699d2a263ed9eb7953f7fba8" title="Sum of elements." alt="" coords="272,1476,439,1517"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a38c72b1c4a3214b9eb06349ff17f46e3" title="Vector 2&#45;norm." alt="" coords="13,1411,185,1452"/>
</map>
</div>

</div>
</div>
<a id="ad9662eaa03fe6d3cdbe380e9cf5dea3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9662eaa03fe6d3cdbe380e9cf5dea3e">&#9670;&nbsp;</a></span>empty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::empty </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for empty tensors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to test </td></tr>
    <tr><td class="paramname">tensors</td><td>The remaining tensors to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if one <em>or</em> more tensors are empty </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00330">330</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ad9662eaa03fe6d3cdbe380e9cf5dea3e_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_ad9662eaa03fe6d3cdbe380e9cf5dea3e_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ad9662eaa03fe6d3cdbe380e9cf5dea3e_cgraph" id="anamespace_tiled_array_1_1detail_ad9662eaa03fe6d3cdbe380e9cf5dea3e_cgraph">
<area shape="rect" title="Test for empty tensors." alt="" coords="5,5,139,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a2b25c9db0387e3327718de2cbc9112c6" title="Test for empty tensors in an empty list." alt="" coords="187,5,320,47"/>
</map>
</div>

</div>
</div>
<a id="a2ad1e3676bf04e4d918a1703e07dd025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad1e3676bf04e4d918a1703e07dd025">&#9670;&nbsp;</a></span>foreach() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool inplace = false, typename Op , typename ResultTile , typename ArgTile , typename Policy , typename... ArgTiles&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if_t&lt;!<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt;Policy&gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;ResultTile, Policy&gt; &gt; TiledArray::detail::foreach </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07">ShapeReductionMethod</a>&#160;</td>
          <td class="paramname"><em>shape_reduction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array_1_1detail.html#a196b35f7b6b1ccdb872eeca1353bb26b">const_if_t</a>&lt; not inplace, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ArgTile, Policy &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ArgTiles, Policy &gt; &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>base implementation of sparse <a class="el" href="namespace_tiled_array.html#a7945ee30f3a11a878035bb9e89dfe958" title="Apply a function to each tile of a dense Array.">TiledArray::foreach</a> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>the operation type, the following expression must be valid and return <code>void</code> or be convertible to <code><a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a>&lt;ArgTile</code>, Policy&gt;::shape_type::value_type :<div class="fragment"><div class="line"><a class="code" href="namespace_tiled_array_1_1math_1_1blas.html#a8f5d668dcf6615ea14cf699ab5fdd898">Op</a>(ResultTile&amp;, <span class="keyword">const</span></div>
<div class="line">          ArgTile&amp;, <span class="keyword">const</span> ArgTiles&amp;...) </div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>can't autodeduce <code>ResultTile</code> from <code>void</code> <code>Op(ResultTile,ArgTile)</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00243">243</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a2ad1e3676bf04e4d918a1703e07dd025_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a2ad1e3676bf04e4d918a1703e07dd025_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a2ad1e3676bf04e4d918a1703e07dd025_cgraph" id="anamespace_tiled_array_1_1detail_a2ad1e3676bf04e4d918a1703e07dd025_cgraph">
<area shape="rect" title="base implementation of sparse TiledArray::foreach" alt="" coords="5,200,139,241"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a2ade24f4de11bf1d530e7873dfd19599" title="Find local or remote tile by index." alt="" coords="187,139,344,180"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#ab824f8b38418197da56e2e52d611681c" title="Check for zero tiles." alt="" coords="392,201,549,243"/>
<area shape="rect" href="namespace_tiled_array.html#aa44cdecfe02b2ca9f8134aed6c94f39c" title=" " alt="" coords="188,259,343,300"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_array_impl.html#a7d58f40964ccb5a9be544414f987e258" title="Tile future accessor." alt="" coords="404,136,537,177"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_distributed_storage.html#a1f2ed572953ea119f4cfb8505fca50b6" title="Get local or remote element." alt="" coords="597,5,779,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a2c5ad33baf5e6d3778e685929ca78504" title="Query for a zero tile." alt="" coords="611,201,765,243"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#acc3da081fcb2fd124122dc750d182a96" title="Tiles range accessor." alt="" coords="597,71,779,112"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a1a16c42818cf3c0174187604ed457e79" title="Tiled range accessor." alt="" coords="613,136,763,177"/>
</map>
</div>

</div>
</div>
<a id="a9ad764271dc2e35268ab009b2dbdb140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad764271dc2e35268ab009b2dbdb140">&#9670;&nbsp;</a></span>foreach() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool inplace = false, typename Op , typename ResultTile , typename ArgTile , typename Policy , typename... ArgTiles&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if_t&lt;<a class="el" href="namespace_tiled_array.html#ad73c8b5fc3cf99546cf08ec8c8d755fd">is_dense_v</a>&lt;Policy&gt;, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;ResultTile, Policy&gt; &gt; TiledArray::detail::foreach </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array_1_1detail.html#a196b35f7b6b1ccdb872eeca1353bb26b">const_if_t</a>&lt; not inplace, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ArgTile, Policy &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ArgTiles, Policy &gt; &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>base implementation of dense <a class="el" href="namespace_tiled_array.html#a7945ee30f3a11a878035bb9e89dfe958" title="Apply a function to each tile of a dense Array.">TiledArray::foreach</a> </p>
<dl class="section note"><dt>Note</dt><dd>can't autodeduce <code>ResultTile</code> from <code>void</code> <code>Op(ResultTile,ArgTile)</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00173">173</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a9ad764271dc2e35268ab009b2dbdb140_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a9ad764271dc2e35268ab009b2dbdb140_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a9ad764271dc2e35268ab009b2dbdb140_cgraph" id="anamespace_tiled_array_1_1detail_a9ad764271dc2e35268ab009b2dbdb140_cgraph">
<area shape="rect" title="base implementation of dense TiledArray::foreach" alt="" coords="5,169,139,211"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a2ade24f4de11bf1d530e7873dfd19599" title="Find local or remote tile by index." alt="" coords="187,104,344,145"/>
<area shape="rect" href="namespace_tiled_array.html#aa44cdecfe02b2ca9f8134aed6c94f39c" title=" " alt="" coords="188,169,343,211"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor." alt="" coords="187,235,344,276"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_array_impl.html#a7d58f40964ccb5a9be544414f987e258" title="Tile future accessor." alt="" coords="392,104,525,145"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_distributed_storage.html#a1f2ed572953ea119f4cfb8505fca50b6" title="Get local or remote element." alt="" coords="573,5,755,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a2c5ad33baf5e6d3778e685929ca78504" title="Query for a zero tile." alt="" coords="587,71,741,112"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#acc3da081fcb2fd124122dc750d182a96" title="Tiles range accessor." alt="" coords="573,136,755,177"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a1a16c42818cf3c0174187604ed457e79" title="Tiled range accessor." alt="" coords="589,201,739,243"/>
</map>
</div>

</div>
</div>
<a id="a38c80429be52090559d58f18c011ce30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c80429be52090559d58f18c011ce30">&#9670;&nbsp;</a></span>fuse_dimensions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeType , typename ExtentType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::fuse_dimensions </td>
          <td>(</td>
          <td class="paramtype">SizeType *MADNESS_RESTRICT const&#160;</td>
          <td class="paramname"><em>fused_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeType *MADNESS_RESTRICT const&#160;</td>
          <td class="paramname"><em>fused_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExtentType *MADNESS_RESTRICT const&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the fused dimensions for permutation. </p>
<p>This function will compute the fused dimensions of a tensor for use in permutation algorithms. The idea is to partition the stride 1 dimensions in both the input and output tensor, which yields a forth-order tensor (second- and third-order tensors have size of 1 and stride of 0 in the unused dimensions). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SizeType</td><td>An unsigned integral type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">fused_size</td><td>An array for the fused size output </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fused_weight</td><td>An array for the fused weight output </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>An array that holds the unfused size information of the argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation that will be applied to the argument tensor(s). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2permute_8h_source.html#l00051">51</a> of file <a class="el" href="tensor_2permute_8h_source.html">permute.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a38c80429be52090559d58f18c011ce30_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a38c80429be52090559d58f18c011ce30_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a38c80429be52090559d58f18c011ce30_cgraph" id="anamespace_tiled_array_1_1detail_a38c80429be52090559d58f18c011ce30_cgraph">
<area shape="rect" title="Compute the fused dimensions for permutation." alt="" coords="5,5,145,47"/>
<area shape="rect" href="class_tiled_array_1_1_permutation.html#aacb3f970f21779e9a6c2024790dc7270" title="Domain size accessor." alt="" coords="193,5,369,47"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a38c80429be52090559d58f18c011ce30_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a38c80429be52090559d58f18c011ce30_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a38c80429be52090559d58f18c011ce30_icgraph" id="anamespace_tiled_array_1_1detail_a38c80429be52090559d58f18c011ce30_icgraph">
<area shape="rect" title="Compute the fused dimensions for permutation." alt="" coords="464,115,604,156"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a3f41e1794be8e3f5515437c8301585a9" title="Construct a permuted tensor copy." alt="" coords="283,115,416,156"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#af174120ffd75a14d13077eff16452d9b" title="In&#45;place tensor permutation operations with contiguous data." alt="" coords="46,5,194,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_contract_reduce.html#a3edb113a3e4524ffa21985587b0b7311" title="Post processing step." alt="" coords="5,71,235,200"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a2788b8e3e27331097aa656a0e6e36b20" title="Initialize tensor with permuted tensor arguments." alt="" coords="53,224,187,265"/>
</map>
</div>

</div>
</div>
<a id="aad4f5f01de2e42a291b42f9f2b55eaa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4f5f01de2e42a291b42f9f2b55eaa6">&#9670;&nbsp;</a></span>fuse_vector_of_shapes_tiles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dense_shape.html">TA::DenseShape</a> TiledArray::detail::fuse_vector_of_shapes_tiles </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_tiled_array_1_1_dist_array.html">TA::DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">TA::DensePolicy</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>array_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TA::TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>fused_trange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fuses the <a class="el" href="class_tiled_array_1_1_dense_shape.html" title="Dense shape of an array.">DenseShape</a> objects of a tilewise-round-robin distributed vector of Arrays into single <a class="el" href="class_tiled_array_1_1_dense_shape.html" title="Dense shape of an array.">DenseShape</a> object, with the vector index forming the first dimension. </p>
<p>This is the same as the sparse version above, but far simpler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">global_world</td><td>the World object in which the new fused array will live </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrays</td><td>a vector of <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> objects; these are local components of a vector distributed tilewise in round-robin manner; each element of <code>arrays</code> must have the same <a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array.">TiledRange</a>; </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">array_rank</td><td>Sum of the sizes of <code>arrays</code> on each rank (the size of <code>arrays</code> on each rank will depend on world.size) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fused_trange</td><td>the <a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array.">TiledRange</a> of the fused <code>arrays</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_tiled_array_1_1_dense_shape.html" title="Dense shape of an array.">DenseShape</a> of fused Array object </dd></dl>

<p class="definition">Definition at line <a class="el" href="vector__of__arrays_8h_source.html#l00159">159</a> of file <a class="el" href="vector__of__arrays_8h_source.html">vector_of_arrays.h</a>.</p>

</div>
</div>
<a id="a716b4de519b8ce66cdf12b9e6578f30b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716b4de519b8ce66cdf12b9e6578f30b">&#9670;&nbsp;</a></span>fuse_vector_of_shapes_tiles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_sparse_shape.html">TA::SparseShape</a>&lt;float&gt; TiledArray::detail::fuse_vector_of_shapes_tiles </td>
          <td>(</td>
          <td class="paramtype">madness::World &amp;&#160;</td>
          <td class="paramname"><em>global_world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_tiled_array_1_1_dist_array.html">TA::DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">TA::SparsePolicy</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>array_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TA::TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>fused_trange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fuses the <a class="el" href="class_tiled_array_1_1_sparse_shape.html" title="Frobenius-norm-based sparse shape.">SparseShape</a> objects of a tilewise-round-robin distributed vector of Arrays into single <a class="el" href="class_tiled_array_1_1_sparse_shape.html" title="Frobenius-norm-based sparse shape.">SparseShape</a> object, with the vector index forming the first dimension. </p>
<p>This is used to fuse shapes of a sequence of N-dimensional arrays into the shape of the fused (N+1)-dimensional array. The sequence is <em>tiled</em>, and the tiles are round-robin distributed. Hence for p ranks tile I will reside on processor Ip ; this tile includes shapes of arrays [I*b, (I+1)*b).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">global_world</td><td>the World object in which the new fused array will live </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrays</td><td>a vector of <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> objects; these are local components of a vector distributed tilewise in round-robin manner; each element of <code>arrays</code> must have the same <a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array.">TiledRange</a>; </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">array_rank</td><td>Sum of the sizes of <code>arrays</code> on each rank (the size of <code>arrays</code> on each rank will depend on world.size) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fused_trange</td><td>the <a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array.">TiledRange</a> of the fused <code>arrays</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_tiled_array_1_1_sparse_shape.html" title="Frobenius-norm-based sparse shape.">SparseShape</a> of fused Array object TODO rename to fuse_tilewise_vector_of_shapes </dd></dl>

<p class="definition">Definition at line <a class="el" href="vector__of__arrays_8h_source.html#l00071">71</a> of file <a class="el" href="vector__of__arrays_8h_source.html">vector_of_arrays.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a716b4de519b8ce66cdf12b9e6578f30b_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a716b4de519b8ce66cdf12b9e6578f30b_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a716b4de519b8ce66cdf12b9e6578f30b_cgraph" id="anamespace_tiled_array_1_1detail_a716b4de519b8ce66cdf12b9e6578f30b_cgraph">
<area shape="rect" title="fuses the SparseShape objects of a tilewise&#45;round&#45;robin distributed vector of Arrays into single Spar..." alt="" coords="5,129,220,171"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range1.html#a804300d74a4872393801144e33ad9963" title="Returns an iterator to the first tile in the range." alt="" coords="281,5,458,47"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a9270d658412efce71cde14a4e9488664" title="Data direct access." alt="" coords="300,71,439,112"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a42bfd3b3ccab2835c75af773050444b7" title="Accessor of the tiled range for one of the dimensions." alt="" coords="268,137,471,163"/>
<area shape="rect" href="namespace_tiled_array.html#ae6e2da9f3855369c97e61e9105cce50a" title=" " alt="" coords="307,187,432,214"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a1980b233eaa1fc559b62cc8affc2bd34" title="Access the tile range." alt="" coords="285,239,454,280"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#ac8c1d53822fd3da51824e4d97a11dd2a" title="The rank accessor." alt="" coords="519,121,688,163"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="525,187,682,228"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a716b4de519b8ce66cdf12b9e6578f30b_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a716b4de519b8ce66cdf12b9e6578f30b_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a716b4de519b8ce66cdf12b9e6578f30b_icgraph" id="anamespace_tiled_array_1_1detail_a716b4de519b8ce66cdf12b9e6578f30b_icgraph">
<area shape="rect" title="fuses the SparseShape objects of a tilewise&#45;round&#45;robin distributed vector of Arrays into single Spar..." alt="" coords="225,5,440,47"/>
<area shape="rect" href="namespace_tiled_array.html#ac602cf7316f1296d1f59f76975f5cdfb" title="fuses a vector of DistArray objects, each with the same TiledRange into a DistArray with 1 more dimen..." alt="" coords="5,5,177,47"/>
</map>
</div>

</div>
</div>
<a id="abfac8561aed9b008518116e11d9bdca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfac8561aed9b008518116e11d9bdca0">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::detail::get </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00858">858</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="aa8d036f88ab05ca2cbd5c2e10175d93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d036f88ab05ca2cbd5c2e10175d93c">&#9670;&nbsp;</a></span>ignore_tile_position_accessor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;bool&gt;&amp; TiledArray::detail::ignore_tile_position_accessor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utility_8h_source.html#l00068">68</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_aa8d036f88ab05ca2cbd5c2e10175d93c_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_aa8d036f88ab05ca2cbd5c2e10175d93c_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_aa8d036f88ab05ca2cbd5c2e10175d93c_icgraph" id="anamespace_tiled_array_1_1detail_aa8d036f88ab05ca2cbd5c2e10175d93c_icgraph">
<area shape="rect" title=" " alt="" coords="641,61,800,117"/>
<area shape="rect" href="namespace_tiled_array.html#ab0b271d3125f302d86bcfbfae903a907" title=" " alt="" coords="456,68,593,109"/>
<area shape="rect" href="namespacebtas.html#a48efb9fdd3f5acac9f55e9aabf683173" title=" " alt="" coords="271,46,371,73"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#ae91166d3998a0f1ea70bd76ea3a4fcab" title="Contract this tensor with other." alt="" coords="233,97,408,139"/>
<area shape="rect" href="class_tiled_array_1_1_sparse_shape.html#aa31679be37deccd633495b5901868d3b" title=" " alt="" coords="5,5,185,47"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#af12cb6d7375f20c89f8a42327efe2fa5" title="Contract two tensors and accumulate the scaled result to this tensor." alt="" coords="8,71,183,112"/>
</map>
</div>

</div>
</div>
<a id="a5031b9fe59e7561b395a2ef1c6b5e719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5031b9fe59e7561b395a2ef1c6b5e719">&#9670;&nbsp;</a></span>inner_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L , typename R , typename std::enable_if&lt; is_numeric_v&lt; L &gt; &amp;&amp;!is_complex&lt; L &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE auto TiledArray::detail::inner_product </td>
          <td>(</td>
          <td class="paramtype">const L&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inner product of a real value and a numeric value. </p>
<p>Inner product of a complex value and a numeric value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">L</td><td>A real scalar type </td></tr>
    <tr><td class="paramname">R</td><td>A numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>r</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">L</td><td>A complex type </td></tr>
    <tr><td class="paramname">R</td><td>A numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>r</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00067">67</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a5031b9fe59e7561b395a2ef1c6b5e719_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a5031b9fe59e7561b395a2ef1c6b5e719_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a5031b9fe59e7561b395a2ef1c6b5e719_icgraph" id="anamespace_tiled_array_1_1detail_a5031b9fe59e7561b395a2ef1c6b5e719_icgraph">
<area shape="rect" title="Inner product of a real value and a numeric value." alt="" coords="224,53,357,94"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a82161c441a1caca56cb1a894c6ebc7b0" title="Vector inner product." alt="" coords="8,5,173,61"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a8690764d8a2dddcae1c41ffd903f9741" title=" " alt="" coords="5,85,176,141"/>
</map>
</div>

</div>
</div>
<a id="a4b57f060bc5b930d00c088dc270cf15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b57f060bc5b930d00c088dc270cf15b">&#9670;&nbsp;</a></span>inner_size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; !is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::size_type TiledArray::detail::inner_size </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the inner size. </p>
<p>This function searches of the largest contiguous size in the range of a non-contiguous tensor. At a minimum, this is equal to the size of the stride-one dimension. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest contiguous, inner-dimension size. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00310">310</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a4b57f060bc5b930d00c088dc270cf15b_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a4b57f060bc5b930d00c088dc270cf15b_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a4b57f060bc5b930d00c088dc270cf15b_cgraph" id="anamespace_tiled_array_1_1detail_a4b57f060bc5b930d00c088dc270cf15b_cgraph">
<area shape="rect" title="Get the inner size." alt="" coords="5,39,139,80"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a85557b284f443993530894acbb158b58" title="Get the inner size." alt="" coords="187,39,331,80"/>
<area shape="rect" href="namespace_tiled_array.html#aea673bd36f494b9b4c040ea0e09c00bd" title=" " alt="" coords="379,46,524,73"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a911b5f4183473c9c9300c370b90374df" title="Returns the number of tiles in the tensor." alt="" coords="572,5,729,47"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="572,71,729,112"/>
</map>
</div>

</div>
</div>
<a id="a91ec4c7e7bd4d19b11f0674903ce630a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ec4c7e7bd4d19b11f0674903ce630a">&#9670;&nbsp;</a></span>inner_size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt;!is_contiguous_tensor&lt; T1 &gt;::value &amp;&amp;is_contiguous_tensor&lt; T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1::size_type TiledArray::detail::inner_size </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>tensor2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the inner size of two tensors. </p>
<p>This function searches of the largest, common contiguous size in the ranges of two non-contiguous tensors. At a minimum, this is equal to the size of the stride-one dimension. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The secont tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest contiguous, inner-dimension size.</dd></dl>
<p>This function searches of the largest, common contiguous size in the ranges of two non-contiguous tensors. At a minimum, this is equal to the size of the stride-one dimension. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The secont tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor2</td><td>The second tensor to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest contiguous, inner-dimension size.</dd></dl>
<p>This function searches of the largest, common contiguous size in the ranges of two non-contiguous tensors. At a minimum, this is equal to the size of the stride-one dimension. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The secont tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be tested </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest common, contiguous inner-dimension size of the two tensors. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00260">260</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a91ec4c7e7bd4d19b11f0674903ce630a_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a91ec4c7e7bd4d19b11f0674903ce630a_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a91ec4c7e7bd4d19b11f0674903ce630a_cgraph" id="anamespace_tiled_array_1_1detail_a91ec4c7e7bd4d19b11f0674903ce630a_cgraph">
<area shape="rect" title="Get the inner size of two tensors." alt="" coords="5,39,139,80"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a85557b284f443993530894acbb158b58" title="Get the inner size." alt="" coords="187,39,331,80"/>
<area shape="rect" href="namespace_tiled_array.html#aea673bd36f494b9b4c040ea0e09c00bd" title=" " alt="" coords="379,46,524,73"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a911b5f4183473c9c9300c370b90374df" title="Returns the number of tiles in the tensor." alt="" coords="572,5,729,47"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="572,71,729,112"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a91ec4c7e7bd4d19b11f0674903ce630a_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a91ec4c7e7bd4d19b11f0674903ce630a_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a91ec4c7e7bd4d19b11f0674903ce630a_icgraph" id="anamespace_tiled_array_1_1detail_a91ec4c7e7bd4d19b11f0674903ce630a_icgraph">
<area shape="rect" title="Get the inner size of two tensors." alt="" coords="247,104,380,145"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#affe584326250186e9764756598f7eefd" title="Use a binary, element wise operation to construct a new, permuted tensor." alt="" coords="13,5,191,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aebc5c8b00cc397f5ba32ea426d1ddcc3" title=" " alt="" coords="5,71,199,112"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#ac5132fe4d73d49d24d2dcd60f06849f9" title="Initialize tensor with one or more non&#45;contiguous tensor arguments." alt="" coords="35,136,169,177"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aab51b68f811fbe0fbb29909202ad3b30" title="Use a unary, element wise operation to construct a new, permuted tensor." alt="" coords="15,201,189,243"/>
</map>
</div>

</div>
</div>
<a id="a85557b284f443993530894acbb158b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85557b284f443993530894acbb158b58">&#9670;&nbsp;</a></span>inner_size_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::size_type TiledArray::detail::inner_size_helper </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the inner size. </p>
<p>This function searches of the largest contiguous size in the range of a non-contiguous tensor. At a minimum, this is equal to the size of the stride-one dimension. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest contiguous, inner-dimension size. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00192">192</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a85557b284f443993530894acbb158b58_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a85557b284f443993530894acbb158b58_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a85557b284f443993530894acbb158b58_cgraph" id="anamespace_tiled_array_1_1detail_a85557b284f443993530894acbb158b58_cgraph">
<area shape="rect" title="Get the inner size." alt="" coords="5,39,149,80"/>
<area shape="rect" href="namespace_tiled_array.html#aea673bd36f494b9b4c040ea0e09c00bd" title=" " alt="" coords="197,46,343,73"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a911b5f4183473c9c9300c370b90374df" title="Returns the number of tiles in the tensor." alt="" coords="391,5,548,47"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="391,71,548,112"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a85557b284f443993530894acbb158b58_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a85557b284f443993530894acbb158b58_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a85557b284f443993530894acbb158b58_icgraph" id="anamespace_tiled_array_1_1detail_a85557b284f443993530894acbb158b58_icgraph">
<area shape="rect" title="Get the inner size." alt="" coords="428,104,572,145"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a91ec4c7e7bd4d19b11f0674903ce630a" title="Get the inner size of two tensors." alt="" coords="247,104,380,145"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#affe584326250186e9764756598f7eefd" title="Use a binary, element wise operation to construct a new, permuted tensor." alt="" coords="13,5,191,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aebc5c8b00cc397f5ba32ea426d1ddcc3" title=" " alt="" coords="5,71,199,112"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#ac5132fe4d73d49d24d2dcd60f06849f9" title="Initialize tensor with one or more non&#45;contiguous tensor arguments." alt="" coords="35,136,169,177"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aab51b68f811fbe0fbb29909202ad3b30" title="Use a unary, element wise operation to construct a new, permuted tensor." alt="" coords="15,201,189,243"/>
</map>
</div>

</div>
</div>
<a id="a227f69a3e3e5de0854bac8e8f2ec6cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227f69a3e3e5de0854bac8e8f2ec6cee">&#9670;&nbsp;</a></span>inner_size_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1::size_type TiledArray::detail::inner_size_helper </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>tensor2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the inner size of two tensors. </p>
<p>This function searches of the largest, common contiguous size in the ranges of two non-contiguous tensors. At a minimum, this is equal to the size of the stride-one dimension. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The secont tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be tested </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest contiguous, inner-dimension size of the two tensors. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00221">221</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a227f69a3e3e5de0854bac8e8f2ec6cee_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a227f69a3e3e5de0854bac8e8f2ec6cee_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a227f69a3e3e5de0854bac8e8f2ec6cee_cgraph" id="anamespace_tiled_array_1_1detail_a227f69a3e3e5de0854bac8e8f2ec6cee_cgraph">
<area shape="rect" title="Get the inner size of two tensors." alt="" coords="5,5,149,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#aa49fdad6dffe4694cd2f6568461a409c" title="Check for congruent range objects with a shifted tensor." alt="" coords="197,5,355,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html#a1d098067185016b50f5f7670e9a29bc4" title="Tensor type conversion operator." alt="" coords="403,5,561,47"/>
</map>
</div>

</div>
</div>
<a id="af174120ffd75a14d13077eff16452d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af174120ffd75a14d13077eff16452d9b">&#9670;&nbsp;</a></span>inplace_tensor_op() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputOp , typename OutputOp , typename TR , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value &amp;&amp;is_contiguous_tensor&lt; TR, T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::inplace_tensor_op </td>
          <td>(</td>
          <td class="paramtype">InputOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>input_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>output_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TR &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place tensor permutation operations with contiguous data. </p>
<p>In-place tensor of tensors permutation operations with contiguous data.</p>
<p>This function sets the <code>i</code> -th element of <code>result</code> with the result of <code>op(tensor1[i],tensors[i]...)</code> The expected signature of the input operations is: </p><div class="fragment"><div class="line">Result::value_type op(<span class="keyword">const</span> T1::value_type, <span class="keyword">const</span> Ts::value_type...)</div>
</div><!-- fragment --><p> The expected signature of the output operations is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> op(TR::value_type*, <span class="keyword">const</span> TR::value_type)</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputOp</td><td>The input operation type </td></tr>
    <tr><td class="paramname">OutputOp</td><td>The output operation type </td></tr>
    <tr><td class="paramname">TR</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_op</td><td>The operation that is used to generate the output value from the input arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_op</td><td>The operation that is used to set the value of the result tensor given the element pointer and the result value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation applied to the argument tensors </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The remaining argument tensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the <code>i</code> -th element of <code>result</code> with the result of <code>op(tensor1[i], tensors[i]...)</code> The expected signature of the input operations is: </p><div class="fragment"><div class="line">Result::value_type op(<span class="keyword">const</span> T1::value_type::value_type, <span class="keyword">const</span></div>
<div class="line">Ts::value_type::value_type...)</div>
</div><!-- fragment --><p> The expected signature of the output operations is: </p><div class="fragment"><div class="line"> <span class="keywordtype">void</span> op(TR::value_type::value_type*, <span class="keyword">const</span></div>
<div class="line">TR::value_type::value_type)</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputOp</td><td>The input operation type </td></tr>
    <tr><td class="paramname">OutputOp</td><td>The output operation type </td></tr>
    <tr><td class="paramname">TR</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_op</td><td>The operation that is used to generate the output value from the input arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_op</td><td>The operation that is used to set the value of the result tensor given the element pointer and the result value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation applied to the argument tensors </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The remaining argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kernels_8h_source.html#l00262">262</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_af174120ffd75a14d13077eff16452d9b_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_af174120ffd75a14d13077eff16452d9b_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_af174120ffd75a14d13077eff16452d9b_cgraph" id="anamespace_tiled_array_1_1detail_af174120ffd75a14d13077eff16452d9b_cgraph">
<area shape="rect" title="In&#45;place tensor permutation operations with contiguous data." alt="" coords="5,136,153,177"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a2b25c9db0387e3327718de2cbc9112c6" title="Test for empty tensors in an empty list." alt="" coords="227,5,360,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#aa49fdad6dffe4694cd2f6568461a409c" title="Check for congruent range objects with a shifted tensor." alt="" coords="215,71,372,112"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c" title="Test that the ranges of a permuted tensor is congruent with itself." alt="" coords="201,136,385,177"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a3f41e1794be8e3f5515437c8301585a9" title="Construct a permuted tensor copy." alt="" coords="227,348,360,389"/>
<area shape="rect" href="class_tiled_array_1_1_permutation.html#aacb3f970f21779e9a6c2024790dc7270" title="Domain size accessor." alt="" coords="697,217,873,259"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html#a1d098067185016b50f5f7670e9a29bc4" title="Tensor type conversion operator." alt="" coords="455,71,614,112"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a38c80429be52090559d58f18c011ce30" title="Compute the fused dimensions for permutation." alt="" coords="465,253,605,295"/>
<area shape="rect" href="namespace_tiled_array.html#a09ca17753fe59a1d02033b03b343db89" title=" " alt="" coords="469,435,600,462"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a0734d99af5ce0b09816a2934366c9071" title="Matrix transpose and initialization." alt="" coords="433,493,636,519"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a27697ba2d56b48030427ed8996104fda" title=" " alt="" coords="445,319,624,360"/>
<area shape="rect" href="namespace_tiled_array.html#aea673bd36f494b9b4c040ea0e09c00bd" title=" " alt="" coords="462,385,607,411"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#abb08079140fa4ea486e8d6e77baf7158" title=" " alt="" coords="684,500,887,541"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1_transpose_unwind.html#af2a30045172f690528b7854f863f3c23" title=" " alt="" coords="935,431,1137,472"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1_transpose_unwind.html#a4f8998233c204a3e00403d3533a96137" title=" " alt="" coords="935,500,1137,541"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a91290718834db1912be15860e26759ba" title=" " alt="" coords="1195,399,1351,440"/>
<area shape="rect" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#a3b04e4e0fdbfa84f935a3baf0bd8aac6" title=" " alt="" coords="1410,399,1589,440"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a9a5d7ed52ec58b94cc8c9532624a45ad" title=" " alt="" coords="1195,464,1351,505"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1_block.html#a5b8fd799fcafd39809f7f7a5dcc2493f" title=" " alt="" coords="1185,529,1360,571"/>
<area shape="rect" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#a4d1f8bfb9c56806c000338fdd393c872" title=" " alt="" coords="1410,464,1589,505"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1_block.html#a8541624decd7fa535c52f85c9499a0e1" title=" " alt="" coords="1412,595,1587,636"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a6137a96c445b26d23187018efa876aa5" title=" " alt="" coords="1408,529,1591,571"/>
<area shape="rect" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#ad76cb4c4568102c1faaefb5fab603a3c" title=" " alt="" coords="1639,529,1817,571"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a814ebc5ab1105e95a4f1047cad8e598a" title=" " alt="" coords="696,304,875,345"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a91a501b77b43ce96e37799f22096012b" title=" " alt="" coords="958,363,1114,404"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a911b5f4183473c9c9300c370b90374df" title="Returns the number of tiles in the tensor." alt="" coords="707,369,864,411"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="707,435,864,476"/>
</map>
</div>

</div>
</div>
<a id="ac7c2574bd1506d0e811e2c0eb58fb1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c2574bd1506d0e811e2c0eb58fb1e3">&#9670;&nbsp;</a></span>inplace_tensor_op() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op , typename TR , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, Ts... &gt;::value &amp;&amp;is_contiguous_tensor&lt; TR, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::inplace_tensor_op </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TR &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place tensor operations with contiguous data. </p>
<p>In-place tensor of tensors operations with non-contiguous data.</p>
<p>In-place tensor operations with non-contiguous data.</p>
<p>In-place tensor of tensors operations with contiguous data.</p>
<p>This function sets the elements of <code>result</code> with the result of <code>op(tensors[i]...)</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The element initialization operation type </td></tr>
    <tr><td class="paramname">TR</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The argument tensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the <code>i</code> -th element of <code>result</code> with the result of <code>op(tensors[i]...)</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The element initialization operation type </td></tr>
    <tr><td class="paramname">TR</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kernels_8h_source.html#l00197">197</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ac7c2574bd1506d0e811e2c0eb58fb1e3_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_ac7c2574bd1506d0e811e2c0eb58fb1e3_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ac7c2574bd1506d0e811e2c0eb58fb1e3_cgraph" id="anamespace_tiled_array_1_1detail_ac7c2574bd1506d0e811e2c0eb58fb1e3_cgraph">
<area shape="rect" title="In&#45;place tensor operations with contiguous data." alt="" coords="5,104,153,145"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a2b25c9db0387e3327718de2cbc9112c6" title="Test for empty tensors in an empty list." alt="" coords="227,5,361,47"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#af3538be07513fbf1cb420e6ff0631e52" title=" " alt="" coords="201,71,387,112"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c" title="Test that the ranges of a permuted tensor is congruent with itself." alt="" coords="202,136,386,177"/>
<area shape="rect" href="namespace_tiled_array.html#aea673bd36f494b9b4c040ea0e09c00bd" title=" " alt="" coords="221,202,367,229"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a3fd6348022ed6ff4698c20bc8ec1a759" title=" " alt="" coords="435,71,620,112"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a9a5d7ed52ec58b94cc8c9532624a45ad" title=" " alt="" coords="1113,41,1269,83"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a75bfae8d964e10120d677654383c2d3b" title=" " alt="" coords="677,71,833,112"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1_block.html#a19333b411770e31611cbddf94d5c5747" title=" " alt="" coords="668,136,843,177"/>
<area shape="rect" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#a4d1f8bfb9c56806c000338fdd393c872" title=" " alt="" coords="1317,41,1496,83"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a9085136f802b954e3a2bd643cd13d8b5" title=" " alt="" coords="893,71,1063,112"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1_block.html#a8541624decd7fa535c52f85c9499a0e1" title=" " alt="" coords="891,136,1065,177"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a911b5f4183473c9c9300c370b90374df" title="Returns the number of tiles in the tensor." alt="" coords="449,165,606,207"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="449,231,606,272"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ac7c2574bd1506d0e811e2c0eb58fb1e3_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_ac7c2574bd1506d0e811e2c0eb58fb1e3_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ac7c2574bd1506d0e811e2c0eb58fb1e3_icgraph" id="anamespace_tiled_array_1_1detail_ac7c2574bd1506d0e811e2c0eb58fb1e3_icgraph">
<area shape="rect" title="In&#45;place tensor operations with contiguous data." alt="" coords="757,239,905,280"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a272585651b1233bb8f90d23c88a12c61" title="Use a binary, element wise operation to modify this tensor." alt="" coords="505,13,684,69"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aedf1dc6f6754af31fdfcc8ee86b0c73d" title="Use a binary, element wise operation to modify this tensor." alt="" coords="502,93,687,149"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#af23df0d855cd33e6e977bd39e780ca9a" title="Use a unary, element wise operation to modify this tensor." alt="" coords="483,173,706,215"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a8cc4b0e0e82ab58dad40a01b4530b94b" title="Use a unary, element wise operation to modify this tensor." alt="" coords="480,239,709,280"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a864d3eed3caa265526a36b1e042aaeb9" title=" " alt="" coords="495,304,694,345"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a70f6e8ca6afdfd889fac691a39f7a57e" title=" " alt="" coords="493,369,697,411"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html#a6f2e00b7e50f7ba5858e3fa472d3e917" title="Assignment operator." alt="" coords="501,435,689,476"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a2d65efd4c6093a5373e836d74619b738" title="Add other to this tensor." alt="" coords="245,5,427,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a2cd3d6f515b31751c9fcc26e48f2e3ed" title="Multiply this tensor by right." alt="" coords="242,71,430,112"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a69ca8d8ac4237fb53887d69ffc4c5225" title="Subtract right from this tensor." alt="" coords="243,136,429,177"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ac61eb093688f07b96c65966428502452" title="Subtract a constant from this tensor." alt="" coords="5,5,192,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a5c3cfbd8b10ff2801543f4584d753a5f" title="Add a constant to this tensor." alt="" coords="245,201,427,243"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ae8094e4b120557459a28f1f21513f774" title="Negate elements of this tensor." alt="" coords="245,267,427,308"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#afdf25cc0015b6214fac0682074137d33" title="Scale this tensor." alt="" coords="240,332,432,373"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a176752a6002f24f0e378f27d94a8bba8" title="Complex conjugate this tensor." alt="" coords="6,332,191,373"/>
</map>
</div>

</div>
</div>
<a id="aa49fdad6dffe4694cd2f6568461a409c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49fdad6dffe4694cd2f6568461a409c">&#9670;&nbsp;</a></span>is_range_congruent() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Left , typename Right &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_range_congruent </td>
          <td>(</td>
          <td class="paramtype">const Left &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html">ShiftWrapper</a>&lt; Right &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for congruent range objects with a shifted tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Left</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the lower and upper bounds of the left- and right-hand tensor ranges are equal, otherwise <code>false</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="shift__wrapper_8h_source.html#l00120">120</a> of file <a class="el" href="shift__wrapper_8h_source.html">shift_wrapper.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_aa49fdad6dffe4694cd2f6568461a409c_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_aa49fdad6dffe4694cd2f6568461a409c_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_aa49fdad6dffe4694cd2f6568461a409c_cgraph" id="anamespace_tiled_array_1_1detail_aa49fdad6dffe4694cd2f6568461a409c_cgraph">
<area shape="rect" title="Check for congruent range objects with a shifted tensor." alt="" coords="5,5,163,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html#a1d098067185016b50f5f7670e9a29bc4" title="Tensor type conversion operator." alt="" coords="211,5,369,47"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_aa49fdad6dffe4694cd2f6568461a409c_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_aa49fdad6dffe4694cd2f6568461a409c_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_aa49fdad6dffe4694cd2f6568461a409c_icgraph" id="anamespace_tiled_array_1_1detail_aa49fdad6dffe4694cd2f6568461a409c_icgraph">
<area shape="rect" title="Check for congruent range objects with a shifted tensor." alt="" coords="237,104,395,145"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a227f69a3e3e5de0854bac8e8f2ec6cee" title="Get the inner size of two tensors." alt="" coords="25,5,169,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#af174120ffd75a14d13077eff16452d9b" title="In&#45;place tensor permutation operations with contiguous data." alt="" coords="23,71,171,112"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a42a1f5fb2f3d857ee31e66ba3deabf20" title="Test that the ranges of a permuted set of tensors are congruent." alt="" coords="5,136,189,177"/>
<area shape="rect" href="struct_tiled_array_1_1detail_1_1transform.html#a1324736ab88c1fc8ec58d57b35b2b504" title=" " alt="" coords="14,201,181,243"/>
</map>
</div>

</div>
</div>
<a id="a0b9a43dfee2749874d4677ea89ab4188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b9a43dfee2749874d4677ea89ab4188">&#9670;&nbsp;</a></span>is_range_congruent() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt;!(is_shifted&lt; T1 &gt;::value||is_shifted&lt; T2 &gt;::value)&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_range_congruent </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>tensor2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the ranges of a pair of tensors are congruent. </p>
<p>Test that the ranges of a pair of shifted tensors are congruent.</p>
<p>This function tests that the rank and extent of <code>tensor1</code> are equal to those of <code>tensor2</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The second tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be compared </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the rank and extent of the two tensors equal, otherwise <code>false</code>.</dd></dl>
<p>This function tests that the extents of the two tensors are equal. One or both of the tensors may be shifted. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The second tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be compared </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the rank and extent of the two tensors equal, otherwise <code>false</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00076">76</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a0b9a43dfee2749874d4677ea89ab4188_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a0b9a43dfee2749874d4677ea89ab4188_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a0b9a43dfee2749874d4677ea89ab4188_cgraph" id="anamespace_tiled_array_1_1detail_a0b9a43dfee2749874d4677ea89ab4188_cgraph">
<area shape="rect" title="Test that the ranges of a pair of tensors are congruent." alt="" coords="5,5,163,47"/>
<area shape="rect" href="namespace_tiled_array.html#ad03979f84fd9f2823892518870a3c779" title="Test that two BlockRange objects are congruent." alt="" coords="211,13,389,39"/>
</map>
</div>

</div>
</div>
<a id="aa35b616db0b6d4da11b862de9570fb93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35b616db0b6d4da11b862de9570fb93">&#9670;&nbsp;</a></span>is_range_congruent() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt;!(is_shifted&lt; T1 &gt;::value||is_shifted&lt; T2 &gt;::value)&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_range_congruent </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>tensor2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the ranges of a pair of permuted tensors are congruent. </p>
<p>This function tests that the rank, lower bound, and upper bound of <code>tensor1</code> is equal to that of the permuted range of <code>tensor2</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The second tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be compared </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be compared </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to <code>tensor2</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the rank and extent of the two tensors equal, otherwise <code>false</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00094">94</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_aa35b616db0b6d4da11b862de9570fb93_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_aa35b616db0b6d4da11b862de9570fb93_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_aa35b616db0b6d4da11b862de9570fb93_cgraph" id="anamespace_tiled_array_1_1detail_aa35b616db0b6d4da11b862de9570fb93_cgraph">
<area shape="rect" title="Test that the ranges of a pair of permuted tensors are congruent." alt="" coords="5,5,163,47"/>
<area shape="rect" href="namespace_tiled_array.html#ad03979f84fd9f2823892518870a3c779" title="Test that two BlockRange objects are congruent." alt="" coords="211,13,389,39"/>
</map>
</div>

</div>
</div>
<a id="a0d75a0a0d43e9a5d8beec072cdbe678c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d75a0a0d43e9a5d8beec072cdbe678c">&#9670;&nbsp;</a></span>is_range_set_congruent() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool TiledArray::detail::is_range_set_congruent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the ranges of a permuted tensor is congruent with itself. </p>
<p>This function is used as the termination step for the recursive <code><a class="el" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c" title="Test that the ranges of a permuted tensor is congruent with itself.">is_range_set_congruent()</a></code> function, and to handle the case of a single tensor. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation </td></tr>
    <tr><td class="paramname">tensor</td><td>The tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00130">130</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a0d75a0a0d43e9a5d8beec072cdbe678c_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a0d75a0a0d43e9a5d8beec072cdbe678c_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a0d75a0a0d43e9a5d8beec072cdbe678c_icgraph" id="anamespace_tiled_array_1_1detail_a0d75a0a0d43e9a5d8beec072cdbe678c_icgraph">
<area shape="rect" title="Test that the ranges of a permuted tensor is congruent with itself." alt="" coords="1028,533,1212,575"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#ac7c2574bd1506d0e811e2c0eb58fb1e3" title="In&#45;place tensor operations with contiguous data." alt="" coords="814,272,962,313"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a42a1f5fb2f3d857ee31e66ba3deabf20" title="Test that the ranges of a permuted set of tensors are congruent." alt="" coords="796,468,980,509"/>
<area shape="rect" href="struct_tiled_array_1_1detail_1_1transform.html#ae00da3d0d2f66eecc0bd866b737d1008" title=" " alt="" coords="805,533,971,575"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a2fa32053a2cef8c73b71763a0e01cd95" title="Initialize tensor with contiguous tensor arguments." alt="" coords="821,599,955,640"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#ab957a79bba9735ad3e405dbb8dd53796" title="Reduction operation for contiguous tensors." alt="" coords="821,1067,955,1108"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a272585651b1233bb8f90d23c88a12c61" title="Use a binary, element wise operation to modify this tensor." alt="" coords="544,13,723,69"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aedf1dc6f6754af31fdfcc8ee86b0c73d" title="Use a binary, element wise operation to modify this tensor." alt="" coords="541,93,726,149"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#af23df0d855cd33e6e977bd39e780ca9a" title="Use a unary, element wise operation to modify this tensor." alt="" coords="522,173,745,215"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a8cc4b0e0e82ab58dad40a01b4530b94b" title="Use a unary, element wise operation to modify this tensor." alt="" coords="519,239,748,280"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a864d3eed3caa265526a36b1e042aaeb9" title=" " alt="" coords="534,304,733,345"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a70f6e8ca6afdfd889fac691a39f7a57e" title=" " alt="" coords="531,369,735,411"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html#a6f2e00b7e50f7ba5858e3fa472d3e917" title="Assignment operator." alt="" coords="539,435,727,476"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a2d65efd4c6093a5373e836d74619b738" title="Add other to this tensor." alt="" coords="264,5,447,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a2cd3d6f515b31751c9fcc26e48f2e3ed" title="Multiply this tensor by right." alt="" coords="261,71,449,112"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a69ca8d8ac4237fb53887d69ffc4c5225" title="Subtract right from this tensor." alt="" coords="262,136,449,177"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ac61eb093688f07b96c65966428502452" title="Subtract a constant from this tensor." alt="" coords="5,5,192,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a5c3cfbd8b10ff2801543f4584d753a5f" title="Add a constant to this tensor." alt="" coords="264,201,447,243"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ae8094e4b120557459a28f1f21513f774" title="Negate elements of this tensor." alt="" coords="264,267,447,308"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#afdf25cc0015b6214fac0682074137d33" title="Scale this tensor." alt="" coords="259,332,451,373"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a176752a6002f24f0e378f27d94a8bba8" title="Complex conjugate this tensor." alt="" coords="6,332,191,373"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ae11a9e70ba98eccc31ef6b8a265cc369" title="Use a binary, element wise operation to construct a new tensor." alt="" coords="544,500,723,541"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aebc5c8b00cc397f5ba32ea426d1ddcc3" title=" " alt="" coords="537,565,730,607"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#ad06d56e445f36d572109abbafc1a32e5" title="Construct a tensor with a fill value." alt="" coords="546,631,721,672"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ae5f80c1e7c2e5855313fad6ad10375b3" title="Use a unary, element wise operation to construct a new tensor." alt="" coords="546,696,721,737"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a0ef9fb1d4cd22af3bb02002209eb31f0" title="Add this and other to construct a new tensors." alt="" coords="274,435,437,476"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#af0e2f37b46d3c3c0fcc3ab77d8594b6f" title="Multiply this by right to create a new tensor." alt="" coords="271,500,439,541"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a8361c0f82bfdfcf468247cf566c87a89" title="Subtract this and right to construct a new tensor." alt="" coords="272,565,439,607"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a0f3da596fb623188a555eee31e968225" title="Subtract a constant from a copy of this tensor." alt="" coords="15,435,182,476"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a31362893bb066fe8568529f881028611" title="Add a constant to a copy of this tensor." alt="" coords="274,631,437,672"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a115f6c8f776a9d58a238dfc810758b34" title="Create a negated copy of this tensor." alt="" coords="274,696,437,737"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a4738cdadac53a8979ffb09d1409e0a1e" title="Construct a scaled copy of this tensor." alt="" coords="269,761,441,803"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#abe962a9632cf8da0e5bbcf7c12420acd" title="Create a complex conjugated copy of this tensor." alt="" coords="16,761,181,803"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aad1e3e351ce4d80310c368f77375198c" title="Unary reduction operation." alt="" coords="542,1067,725,1108"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#ac7e2825494e7578e27becf11d2a6b794" title="Unary reduction operation." alt="" coords="545,1132,721,1173"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aadf392a65c7edfe026984dc11b0d47d8" title="Absolute maximum element." alt="" coords="257,827,454,868"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a19eafabec70f0ff8c67d5a48a41db533" title="Absolute minimum element." alt="" coords="259,892,452,933"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a2f3626dbf2d39bbc8abcd9c9c4c31b46" title="Vector dot product." alt="" coords="276,957,435,999"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a8690764d8a2dddcae1c41ffd903f9741" title=" " alt="" coords="270,1023,441,1079"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#af3a337e3cd4f50cb9bbcc4abc3e54bc1" title="Maximum element." alt="" coords="272,1104,439,1145"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#af06857f977bbfd0e4ea9fca89ed7bc2e" title="Minimum element." alt="" coords="274,1169,437,1211"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#af055ceb310d932e5ca4041972e86edd5" title="Product of elements." alt="" coords="262,1235,449,1276"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#acb4cc909b548c92259bba323ff9a1c08" title="Square of vector 2&#45;norm." alt="" coords="240,1300,471,1341"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a95349207699d2a263ed9eb7953f7fba8" title="Sum of elements." alt="" coords="272,1365,439,1407"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a38c72b1c4a3214b9eb06349ff17f46e3" title="Vector 2&#45;norm." alt="" coords="13,1300,185,1341"/>
</map>
</div>

</div>
</div>
<a id="a42a1f5fb2f3d857ee31e66ba3deabf20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a1f5fb2f3d857ee31e66ba3deabf20">&#9670;&nbsp;</a></span>is_range_set_congruent() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_range_set_congruent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>tensor2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the ranges of a permuted set of tensors are congruent. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The second tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation to be applied to <code>tensor2</code> and <code>tensors</code>... </td></tr>
    <tr><td class="paramname">tensor1</td><td>The first tensor to be compared </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be compared </td></tr>
    <tr><td class="paramname">tensors</td><td>The remaining tensor to be compared in recursive steps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all permuted tensors in the list are congruent with the first tensor in the set, otherwise <code>false</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00147">147</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a42a1f5fb2f3d857ee31e66ba3deabf20_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a42a1f5fb2f3d857ee31e66ba3deabf20_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a42a1f5fb2f3d857ee31e66ba3deabf20_cgraph" id="anamespace_tiled_array_1_1detail_a42a1f5fb2f3d857ee31e66ba3deabf20_cgraph">
<area shape="rect" title="Test that the ranges of a permuted set of tensors are congruent." alt="" coords="5,39,189,80"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#aa49fdad6dffe4694cd2f6568461a409c" title="Check for congruent range objects with a shifted tensor." alt="" coords="251,5,408,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c" title="Test that the ranges of a permuted tensor is congruent with itself." alt="" coords="237,71,421,112"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html#a1d098067185016b50f5f7670e9a29bc4" title="Tensor type conversion operator." alt="" coords="469,5,628,47"/>
</map>
</div>

</div>
</div>
<a id="a8d01c42f84f360ae79da4a0c8e5b84a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d01c42f84f360ae79da4a0c8e5b84a2">&#9670;&nbsp;</a></span>is_range_set_congruent() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool TiledArray::detail::is_range_set_congruent </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the ranges of a tensor is congruent with itself. </p>
<p>This function is used as the termination step for the recursive <code><a class="el" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c" title="Test that the ranges of a permuted tensor is congruent with itself.">is_range_set_congruent()</a></code> function, and to handle the case of a single tensor. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00162">162</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a id="af81ff970acbf1f37236b31c6d19f8e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81ff970acbf1f37236b31c6d19f8e27">&#9670;&nbsp;</a></span>is_range_set_congruent() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_range_set_congruent </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>tensor2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the ranges of a set of tensors are congruent. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The second tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be compared </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be compared </td></tr>
    <tr><td class="paramname">tensors</td><td>The remaining tensor to be compared in recursive steps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all tensors in the list are congruent with the first tensor in the set, otherwise <code>false</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00177">177</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_af81ff970acbf1f37236b31c6d19f8e27_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_af81ff970acbf1f37236b31c6d19f8e27_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_af81ff970acbf1f37236b31c6d19f8e27_cgraph" id="anamespace_tiled_array_1_1detail_af81ff970acbf1f37236b31c6d19f8e27_cgraph">
<area shape="rect" title="Test that the ranges of a set of tensors are congruent." alt="" coords="5,39,189,80"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#aa49fdad6dffe4694cd2f6568461a409c" title="Check for congruent range objects with a shifted tensor." alt="" coords="251,5,408,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c" title="Test that the ranges of a permuted tensor is congruent with itself." alt="" coords="237,71,421,112"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html#a1d098067185016b50f5f7670e9a29bc4" title="Tensor type conversion operator." alt="" coords="469,5,628,47"/>
</map>
</div>

</div>
</div>
<a id="aab69b5c6e7fe9114b25b22231b63aff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab69b5c6e7fe9114b25b22231b63aff4">&#9670;&nbsp;</a></span>is_tot_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_tot_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines what it means for a string index to be for a Tensor-of-Tensors</p>
<p><a class="el" href="namespace_tiled_array.html">TiledArray</a> defines an index as being for a tensor-of-tensors if:</p><ul>
<li>the index is valid</li>
<li>the index contains a semicolon</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The index whose tensor-of-tensor-ness is in question. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>idx</code> is a valid tensor-of-tensor index and false otherwise. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if is_valid_index throws while copying or splitting <code>idx</code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="annotation_8h_source.html#l00160">160</a> of file <a class="el" href="annotation_8h_source.html">annotation.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_aab69b5c6e7fe9114b25b22231b63aff4_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_aab69b5c6e7fe9114b25b22231b63aff4_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_aab69b5c6e7fe9114b25b22231b63aff4_cgraph" id="anamespace_tiled_array_1_1detail_aab69b5c6e7fe9114b25b22231b63aff4_cgraph">
<area shape="rect" title=" " alt="" coords="5,39,139,80"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a73854ab2c5a308c4c3f16544f6480b68" title=" " alt="" coords="187,39,320,80"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a7723231012d7f0f700b31406de463ae4" title=" " alt="" coords="368,5,529,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a8995a103b8540e3506a34377ea37f331" title=" " alt="" coords="382,71,515,112"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_aab69b5c6e7fe9114b25b22231b63aff4_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_aab69b5c6e7fe9114b25b22231b63aff4_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_aab69b5c6e7fe9114b25b22231b63aff4_icgraph" id="anamespace_tiled_array_1_1detail_aab69b5c6e7fe9114b25b22231b63aff4_icgraph">
<area shape="rect" title=" " alt="" coords="187,5,320,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#af1a4bb50000c2c62628719892888b8bb" title=" " alt="" coords="5,5,139,47"/>
</map>
</div>

</div>
</div>
<a id="a73854ab2c5a308c4c3f16544f6480b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73854ab2c5a308c4c3f16544f6480b68">&#9670;&nbsp;</a></span>is_valid_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_valid_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks that the provided index is a valid <a class="el" href="namespace_tiled_array.html">TiledArray</a> index</p>
<p><a class="el" href="namespace_tiled_array.html">TiledArray</a> defines a string as being a valid index if each character is one of the following:</p>
<ul>
<li>Roman letters A through Z (uppercase and lowercase are allowed)</li>
<li>Base 10 numbers 0 through 9</li>
<li>Whitespace</li>
<li>underscore (<code>_</code>), prime (<code>'</code>), comma (<code>,</code>), or semicolon (<code>;</code>)</li>
</ul>
<p>Additionally the string can not:</p>
<ul>
<li>be only whitespace</li>
<li>contain more than one semicolon</li>
<li>have anonymous index name (i.e. can't have "i,,k" because the middle index has no name).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The index whose validity is being questioned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the string corresponds to a valid index and false otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function only tests that the characters making up the index are valid. The index may still be invalid for a particular tensor. For example if <code>idx</code> is an index for a matrix, but the actual tensor is rank 3, then <code>idx</code> would be an invalid index for that tensor despite being a valid index. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to copy <code>idx</code>. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to split <code>idx</code> into tokens. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="annotation_8h_source.html#l00122">122</a> of file <a class="el" href="annotation_8h_source.html">annotation.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a73854ab2c5a308c4c3f16544f6480b68_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a73854ab2c5a308c4c3f16544f6480b68_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a73854ab2c5a308c4c3f16544f6480b68_cgraph" id="anamespace_tiled_array_1_1detail_a73854ab2c5a308c4c3f16544f6480b68_cgraph">
<area shape="rect" title=" " alt="" coords="5,39,139,80"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a7723231012d7f0f700b31406de463ae4" title=" " alt="" coords="187,5,348,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a8995a103b8540e3506a34377ea37f331" title=" " alt="" coords="201,71,334,112"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a73854ab2c5a308c4c3f16544f6480b68_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a73854ab2c5a308c4c3f16544f6480b68_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a73854ab2c5a308c4c3f16544f6480b68_icgraph" id="anamespace_tiled_array_1_1detail_a73854ab2c5a308c4c3f16544f6480b68_icgraph">
<area shape="rect" title=" " alt="" coords="368,35,501,76"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#aab69b5c6e7fe9114b25b22231b63aff4" title=" " alt="" coords="187,5,320,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#af1a4bb50000c2c62628719892888b8bb" title=" " alt="" coords="5,35,139,76"/>
</map>
</div>

</div>
</div>
<a id="ab46d9580d4d2230d0e34ee0ccfdafc72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46d9580d4d2230d0e34ee0ccfdafc72">&#9670;&nbsp;</a></span>make_shape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool sparse&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::detail::make_shape </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>trange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b2a3fd528183d1884b5f53d1d0d89fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2a3fd528183d1884b5f53d1d0d89fa">&#9670;&nbsp;</a></span>make_shape&lt; false &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="namespace_tiled_array_1_1detail.html#ab46d9580d4d2230d0e34ee0ccfdafc72">TiledArray::detail::make_shape</a>&lt; false &gt; </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2btas_8h_source.html#l00161">161</a> of file <a class="el" href="conversions_2btas_8h_source.html">btas.h</a>.</p>

</div>
</div>
<a id="a39f1aefd43dea7ce3158f142a57e5994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f1aefd43dea7ce3158f142a57e5994">&#9670;&nbsp;</a></span>make_shape&lt; true &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="namespace_tiled_array_1_1detail.html#ab46d9580d4d2230d0e34ee0ccfdafc72">TiledArray::detail::make_shape</a>&lt; true &gt; </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>trange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2btas_8h_source.html#l00153">153</a> of file <a class="el" href="conversions_2btas_8h_source.html">btas.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a39f1aefd43dea7ce3158f142a57e5994_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a39f1aefd43dea7ce3158f142a57e5994_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a39f1aefd43dea7ce3158f142a57e5994_cgraph" id="anamespace_tiled_array_1_1detail_a39f1aefd43dea7ce3158f142a57e5994_cgraph">
<area shape="rect" title=" " alt="" coords="5,27,173,69"/>
<area shape="rect" href="kronecker__delta_8h.html#a08a5e38335a5bd02f089294968dfc391" title=" " alt="" coords="281,5,331,32"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a1980b233eaa1fc559b62cc8affc2bd34" title="Access the tile range." alt="" coords="221,57,391,98"/>
</map>
</div>

</div>
</div>
<a id="a763c40422c3621a425739070cf164db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763c40422c3621a425739070cf164db1">&#9670;&nbsp;</a></span>make_ta_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;::blas::Layout Order, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_range.html">TiledArray::Range</a> TiledArray::detail::make_ta_range </td>
          <td>(</td>
          <td class="paramtype">const btas::RangeNd&lt; Order, Args... &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>makes <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer -indices.">TiledArray::Range</a> from a btas::RangeNd </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>a btas::RangeNd object </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>if <code>range</code> is non-row-major </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="external_2btas_8h_source.html#l00067">67</a> of file <a class="el" href="external_2btas_8h_source.html">btas.h</a>.</p>

</div>
</div>
<a id="a45190dfcad5ef2b9af5b4aa000c844b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45190dfcad5ef2b9af5b4aa000c844b0">&#9670;&nbsp;</a></span>make_ta_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_tiled_array_1_1_range.html">TiledArray::Range</a>&amp; TiledArray::detail::make_ta_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">TiledArray::Range</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="external_2btas_8h_source.html#l00058">58</a> of file <a class="el" href="external_2btas_8h_source.html">btas.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a45190dfcad5ef2b9af5b4aa000c844b0_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a45190dfcad5ef2b9af5b4aa000c844b0_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a45190dfcad5ef2b9af5b4aa000c844b0_icgraph" id="anamespace_tiled_array_1_1detail_a45190dfcad5ef2b9af5b4aa000c844b0_icgraph">
<area shape="rect" title=" " alt="" coords="509,137,643,178"/>
<area shape="rect" href="namespace_tiled_array.html#ace7fbc10ae58bc49609c93b31fa7d4e1" title="Copy a block of a btas::Tensor into a TiledArray::Tensor." alt="" coords="254,13,449,54"/>
<area shape="rect" href="struct_tiled_array_1_1_cast_3_01_tiled_array_1_1_tensor_3_01_t_00_01_allocator_01_4_00_01btas_1_4609707baf645f507ebd5df14a7b8d69.html#af778f0942560d12842d5d00ce970abc4" title=" " alt="" coords="248,78,455,149"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1linalg_1_1scalapack_1_1_block_cyclic_matrix.html#a79bdccd08fb030e045bf01fd764f5912" title=" " alt="" coords="241,173,461,229"/>
<area shape="rect" href="namespace_tiled_array.html#ad8cb3eac6d5a72fae3c98b4d78f5b77a" title="Copy a block of a btas::Tensor into a TiledArray::Tensor." alt="" coords="277,254,425,295"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#aead432075c6c7f2e9f7c329c96bc4d4a" title=" " alt="" coords="5,5,193,61"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#aae305e910ce674d71f550e104c354cb5" title="Task function for assigning a tensor to an Eigen submatrix." alt="" coords="24,247,175,303"/>
</map>
</div>

</div>
</div>
<a id="ada724a31400bb94f55097560394438de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada724a31400bb94f55097560394438de">&#9670;&nbsp;</a></span>make_tile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt;T&gt; TiledArray::detail::make_tile </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory function for tiles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A tensor object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tile that wraps a copy of t. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tile_8h_source.html#l00619">619</a> of file <a class="el" href="tile_8h_source.html">tile.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ada724a31400bb94f55097560394438de_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_ada724a31400bb94f55097560394438de_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ada724a31400bb94f55097560394438de_icgraph" id="anamespace_tiled_array_1_1detail_ada724a31400bb94f55097560394438de_icgraph">
<area shape="rect" title="Factory function for tiles." alt="" coords="839,1469,972,1510"/>
<area shape="rect" href="group___tile_interface.html#ga4f9977ff8130c6b95fc646e6a968f7a6" title="Add tile arguments." alt="" coords="645,305,765,332"/>
<area shape="rect" href="group___tile_interface.html#ga4eb0d0c051737f67276e03e895aefad9" title="Binary element&#45;wise transform producing a new tile." alt="" coords="636,684,773,711"/>
<area shape="rect" href="group___tile_interface.html#ga4d7a9a1250ba51b27addd91171a1c77f" title="Create a complex conjugated copy of a tile." alt="" coords="643,783,766,809"/>
<area shape="rect" href="namespace_tiled_array.html#ac602cf7316f1296d1f59f76975f5cdfb" title="fuses a vector of DistArray objects, each with the same TiledRange into a DistArray with 1 more dimen..." alt="" coords="619,1145,791,1186"/>
<area shape="rect" href="group___tile_interface.html#ga1f3a08fa940b7d1c314327430c604238" title="Contract 2 tensors over head/tail modes and scale the product." alt="" coords="635,1211,774,1237"/>
<area shape="rect" href="group___tile_interface.html#gaf465d9c7b7f7d31918a6150c9d51ca40" title="Multiplication tile arguments." alt="" coords="641,1451,768,1477"/>
<area shape="rect" href="group___tile_interface.html#ga6bd5665b8e247cd53460501c3f672751" title="Negate the tile argument." alt="" coords="645,1501,765,1528"/>
<area shape="rect" href="group___tile_interface.html#gaebe37fcda193946fcc4501b42796e9cc" title="Scalar the tile argument." alt="" coords="639,1647,770,1673"/>
<area shape="rect" href="group___tile_interface.html#gacca0c957b239734acfa9b111a65736df" title="Shift the range of arg." alt="" coords="643,1697,767,1724"/>
<area shape="rect" href="namespace_tiled_array.html#a40ec22d8c4caa8f1662a6c124430e802" title="extracts a subarray of a fused array created with fuse_vector_of_arrays and creates the array in loca..." alt="" coords="628,1749,781,1790"/>
<area shape="rect" href="group___tile_interface.html#ga58d10685bc8b980fed30a5e64db19caa" title="Subtract tile arguments." alt="" coords="643,1975,767,2001"/>
<area shape="rect" href="group___tile_interface.html#ga547cfd18b8ef1453c69372f3fc121ba8" title="Unary element&#45;wise transform producing a new tile." alt="" coords="638,2051,771,2077"/>
<area shape="rect" href="group___tile_interface.html#gac080bac89fc26e28adc8ce434f7098bd" title="Add and scale tile arguments." alt="" coords="331,5,451,32"/>
<area shape="rect" href="class_tiled_array_1_1tile__interface_1_1_add.html#abd9b9d12c93b9077f05d2f08f50338b5" title=" " alt="" coords="299,56,484,112"/>
<area shape="rect" href="class_tiled_array_1_1tile__interface_1_1_add_3_01_result_00_01_left_00_01_right_00_01typename_01b694a13ebb5f66ac82ef23c8194bf52e.html#a3372f4a5f40ddf697a3feb6b2d3a1ac4" title=" " alt="" coords="236,137,547,266"/>
<area shape="rect" href="class_tiled_array_1_1tile__interface_1_1_scal_add.html#a80794fddc1ee2c30e54deb5f6ae1c761" title=" " alt="" coords="293,291,489,347"/>
<area shape="rect" href="class_tiled_array_1_1tile__interface_1_1_scal_add_3_01_result_00_01_left_00_01_right_00_01_scalaec54c85276f56f16367eb84c8561e2c3.html#ade2707a89934a959d1bee9249c2ca165" title=" " alt="" coords="212,371,571,515"/>
<area shape="rect" href="namespace_tiled_array.html#a70044a879bcceefda052fe65023bb378" title="Tensor plus operator." alt="" coords="310,539,473,565"/>
<area shape="rect" href="group___tile_interface.html#ga691bf0934b03444773dd5568dcf342db" title="Binary element&#45;wise transform producing a new tile." alt="" coords="323,589,460,616"/>
<area shape="rect" href="group___tile_interface.html#gac18ac642dbdbed016061d5cc969ffa2a" title="Create a complex conjugated and scaled copy of a tile." alt="" coords="330,640,453,667"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_contract_reduce_3_01_result_00_01_left_00_01_right_00_01_tiled_a9a56f685ff213c256976617604736135.html#a1d62bd1335311d0dbe8238448ec6d588" title="Post processing step." alt="" coords="292,691,491,776"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_contract_reduce_3_01_result_00_01_left_00_01_right_00_01_tiled_ac747358d5737d2beb853a2e1d5509b1f.html#a45a9acd171ceb8dc827b91bd9274eccd" title="Post processing step." alt="" coords="292,800,491,885"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1_gemm_task.html#a6a21f83b747c071d088206e5b06cdb86" title=" " alt="" coords="286,910,497,951"/>
<area shape="rect" href="group___tile_interface.html#ga5cd5e3e8121313e9684e91cfa6230fd6" title=" " alt="" coords="322,976,461,1003"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_contract_reduce.html#a6b36209a30d269116db37eebbc5e3cce" title="Contract a pair of tiles and add to a target tile." alt="" coords="277,1027,506,1157"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_contract_reduce_3_01_result_00_01_left_00_01_right_00_01_tiled_a9a56f685ff213c256976617604736135.html#ab7c638ec1c59643f6f96221cfd4ed02f" title="Contract a pair of tiles and add to a target tile." alt="" coords="292,1181,491,1267"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_contract_reduce_3_01_result_00_01_left_00_01_right_00_01_tiled_ac747358d5737d2beb853a2e1d5509b1f.html#a93379e1944af3aa54cdfe9e068395182" title="Contract a pair of tiles and add to a target tile." alt="" coords="292,1291,491,1376"/>
<area shape="rect" href="group___tile_interface.html#ga27e2e80dcf97b3ad64e8797e2226a432" title="Multiplication and scale tile arguments." alt="" coords="328,1400,455,1427"/>
<area shape="rect" href="namespace_tiled_array.html#a2b7b0326fbc5daaf9df0298d58e7df49" title="Tensor multiplication operator." alt="" coords="312,1451,471,1477"/>
<area shape="rect" href="group___tile_interface.html#gab58f7f1369d90de51ae9033dd601a6d6" title="Negate and permute tile argument." alt="" coords="331,1501,451,1528"/>
<area shape="rect" href="namespace_tiled_array.html#ac90b5d6c5aae4293d2b9d3456477aeba" title="Create a negated copy of arg." alt="" coords="313,1552,469,1579"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_scal_shift.html#ae3f1a18c88fa41d76e8e17cd7c8d6e36" title=" " alt="" coords="325,1603,458,1645"/>
<area shape="rect" href="class_tiled_array_1_1tile__interface_1_1_scale.html#a6399e0a5c2048cfcbd4332b0d8bf2f42" title=" " alt="" coords="292,1669,491,1725"/>
<area shape="rect" href="class_tiled_array_1_1tile__interface_1_1_scale_3_01_result_00_01_arg_00_01_scalar_00_01typename_ee347b292fb673c512c87cb2d547dcbe.html#a6832704f169f2fe2f392d663a16eac21" title=" " alt="" coords="274,1749,509,1849"/>
<area shape="rect" href="namespace_tiled_array.html#a93accba5edcc96b461552d4a9483ec3d" title="Create a copy of left that is scaled by right." alt="" coords="312,1873,471,1900"/>
<area shape="rect" href="group___tile_interface.html#gae20e928921671713350adf7ee214a1eb" title="Scale and permute tile argument." alt="" coords="326,1924,457,1951"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_scal_shift.html#aecd03157400e3b514eb25a6ee3624ec1" title="Shift and permute operator." alt="" coords="5,1603,164,1645"/>
<area shape="rect" href="namespace_tiled_array.html#ac6846288ddd37fd160c0afcdf72ce03b" title="Tensor minus operator." alt="" coords="313,1975,469,2001"/>
<area shape="rect" href="group___tile_interface.html#gad477a9e151bd7d6bb29dacda947c83aa" title="Subtract and scale tile arguments." alt="" coords="329,2025,453,2052"/>
<area shape="rect" href="group___tile_interface.html#ga2723b061d47e32d4907b8ef580f33a4b" title="Unary element&#45;wise transform producing a new tile." alt="" coords="325,2076,458,2103"/>
</map>
</div>

</div>
</div>
<a id="ab52e422e441d6c6cd06db1812f784e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab52e422e441d6c6cd06db1812f784e1c">&#9670;&nbsp;</a></span>make_tran_it() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter , typename Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_unary_transform_iterator.html">UnaryTransformIterator</a>&lt;Iter, Op&gt; TiledArray::detail::make_tran_it </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unary Transform iterator factory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>The iterator type </td></tr>
    <tr><td class="paramname">Op</td><td>The binary transform type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>The iterator </td></tr>
    <tr><td class="paramname">op</td><td>The binary transform object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unary transform iterator </dd></dl>

<p class="definition">Definition at line <a class="el" href="transform__iterator_8h_source.html#l00437">437</a> of file <a class="el" href="transform__iterator_8h_source.html">transform_iterator.h</a>.</p>

</div>
</div>
<a id="a58f2092d8f52e938f74173f7ede0b07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f2092d8f52e938f74173f7ede0b07d">&#9670;&nbsp;</a></span>make_tran_it() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter1 , typename Iter2 , typename Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_binary_transform_iterator.html">BinaryTransformIterator</a>&lt;Iter1, Iter2, Op&gt; TiledArray::detail::make_tran_it </td>
          <td>(</td>
          <td class="paramtype">Iter1&#160;</td>
          <td class="paramname"><em>it1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter2&#160;</td>
          <td class="paramname"><em>it2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary Transform iterator factory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter1</td><td>First iterator type </td></tr>
    <tr><td class="paramname">Iter2</td><td>Second iterator type </td></tr>
    <tr><td class="paramname">Op</td><td>The binary transform type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it1</td><td>First iterator </td></tr>
    <tr><td class="paramname">it2</td><td>Second iterator </td></tr>
    <tr><td class="paramname">op</td><td>The binary transform object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A binary transform iterator </dd></dl>

<p class="definition">Definition at line <a class="el" href="transform__iterator_8h_source.html#l00424">424</a> of file <a class="el" href="transform__iterator_8h_source.html">transform_iterator.h</a>.</p>

</div>
</div>
<a id="af885da1706c23576a28eb38b7afab176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af885da1706c23576a28eb38b7afab176">&#9670;&nbsp;</a></span>norm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename std::enable_if&lt; is_numeric_v&lt; R &gt; &amp;&amp;!is_complex&lt; R &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE R TiledArray::detail::norm </td>
          <td>(</td>
          <td class="paramtype">const R&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper function for <code>std::norm</code> </p>
<p>This function disables the call to <code>std::conj</code> for real values to prevent the result from being converted into a complex value. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>A real scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The real scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>r</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00093">93</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_af885da1706c23576a28eb38b7afab176_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_af885da1706c23576a28eb38b7afab176_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_af885da1706c23576a28eb38b7afab176_icgraph" id="anamespace_tiled_array_1_1detail_af885da1706c23576a28eb38b7afab176_icgraph">
<area shape="rect" title="Wrapper function for std::norm" alt="" coords="504,39,637,80"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a47757d8cd5015280a09ee20f453c86c2" title="Square of vector 2&#45;norm." alt="" coords="228,5,453,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#acb4cc909b548c92259bba323ff9a1c08" title="Square of vector 2&#45;norm." alt="" coords="225,71,456,112"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a38c72b1c4a3214b9eb06349ff17f46e3" title="Vector 2&#45;norm." alt="" coords="5,71,177,112"/>
</map>
</div>

</div>
</div>
<a id="af182bb984874298c8351edad6f03517c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af182bb984874298c8351edad6f03517c">&#9670;&nbsp;</a></span>norm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE R TiledArray::detail::norm </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; R &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the norm of a complex number <code>z</code> </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\rm norm}(z) = zz^* = {\rm Re}(z)^2 + {\rm Im}(z)^2 \]" src="form_92.png"/>
</p>
 <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>The scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>The complex scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The complex conjugate of <code>z</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00106">106</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>

</div>
</div>
<a id="a3699581fa58aa15f3376c5e6f66f68b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3699581fa58aa15f3376c5e6f66f68b3">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>left_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>right_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inequality operator. </p>
<p>Compares the iterators for inequality. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The value type of the iterator </td></tr>
    <tr><td class="paramname">Container</td><td>The container that the iterator references </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left_it</td><td>The left-hand iterator to be compared </td></tr>
    <tr><td class="paramname">right_it</td><td>The right-hand iterator to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value or container are not equal for the <code>left_it</code> and <code>right_it</code> , otherwise <code>false</code> . </dd></dl>

<p class="definition">Definition at line <a class="el" href="range__iterator_8h_source.html#l00191">191</a> of file <a class="el" href="range__iterator_8h_source.html">range_iterator.h</a>.</p>

</div>
</div>
<a id="a804792a4a8294fbb2ca9ea04cb8c1da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a804792a4a8294fbb2ca9ea04cb8c1da8">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html">TileConstReference</a>&lt; Impl &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html">TileConstReference</a>&lt; Impl &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inequality operator for <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html" title="Tensor tile reference.">TileConstReference</a> objects </p>

<p class="definition">Definition at line <a class="el" href="array__impl_8h_source.html#l00188">188</a> of file <a class="el" href="array__impl_8h_source.html">array_impl.h</a>.</p>

</div>
</div>
<a id="ae8b423b1a3fcf6701ac05c9ce692d208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b423b1a3fcf6701ac05c9ce692d208">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html">TileReference</a>&lt; Impl &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html">TileReference</a>&lt; Impl &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inequality operator for <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html" title="Tensor tile reference.">TileReference</a> objects </p>

<p class="definition">Definition at line <a class="el" href="array__impl_8h_source.html#l00126">126</a> of file <a class="el" href="array__impl_8h_source.html">array_impl.h</a>.</p>

</div>
</div>
<a id="a47735f4cdfcb24330a02fe4d9e68b8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47735f4cdfcb24330a02fe4d9e68b8e7">&#9670;&nbsp;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Block &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt;Block&gt; TiledArray::detail::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise and operator of bitset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Block</td><td>The bitset block type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand bitset </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand bitset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The a intersection of the <code>left</code> and <code>right</code> bitsets </dd></dl>

<p class="definition">Definition at line <a class="el" href="bitset_8h_source.html#l00587">587</a> of file <a class="el" href="bitset_8h_source.html">bitset.h</a>.</p>

</div>
</div>
<a id="acc6a9baaee6dc713469802694a8f82d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6a9baaee6dc713469802694a8f82d6">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE auto TiledArray::detail::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1_complex_neg_tag.html">ComplexNegTag</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00244">244</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_acc6a9baaee6dc713469802694a8f82d6_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_acc6a9baaee6dc713469802694a8f82d6_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_acc6a9baaee6dc713469802694a8f82d6_cgraph" id="anamespace_tiled_array_1_1detail_acc6a9baaee6dc713469802694a8f82d6_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,139,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383" title="Wrapper function for std::conj" alt="" coords="187,5,320,47"/>
</map>
</div>

</div>
</div>
<a id="a69f8563d428af127b0abe38a93863ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f8563d428af127b0abe38a93863ead">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE auto TiledArray::detail::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; L &gt;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00232">232</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a69f8563d428af127b0abe38a93863ead_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a69f8563d428af127b0abe38a93863ead_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a69f8563d428af127b0abe38a93863ead_cgraph" id="anamespace_tiled_array_1_1detail_a69f8563d428af127b0abe38a93863ead_cgraph">
<area shape="rect" title=" " alt="" coords="5,43,139,84"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383" title="Wrapper function for std::conj" alt="" coords="201,5,335,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html#a941fc6f3a110343828055a79096748ec" title=" " alt="" coords="187,71,349,127"/>
</map>
</div>

</div>
</div>
<a id="a31df1c69fe31afa87b68fb74323ec6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31df1c69fe31afa87b68fb74323ec6a4">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE auto TiledArray::detail::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00238">238</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a31df1c69fe31afa87b68fb74323ec6a4_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a31df1c69fe31afa87b68fb74323ec6a4_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a31df1c69fe31afa87b68fb74323ec6a4_cgraph" id="anamespace_tiled_array_1_1detail_a31df1c69fe31afa87b68fb74323ec6a4_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,139,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383" title="Wrapper function for std::conj" alt="" coords="187,5,320,47"/>
</map>
</div>

</div>
</div>
<a id="a6e797cf6d3cd288a14452f32071b7a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e797cf6d3cd288a14452f32071b7a93">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE auto TiledArray::detail::operator* </td>
          <td>(</td>
          <td class="paramtype">const L&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1_complex_neg_tag.html">ComplexNegTag</a> &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00226">226</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a6e797cf6d3cd288a14452f32071b7a93_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a6e797cf6d3cd288a14452f32071b7a93_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a6e797cf6d3cd288a14452f32071b7a93_cgraph" id="anamespace_tiled_array_1_1detail_a6e797cf6d3cd288a14452f32071b7a93_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,139,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383" title="Wrapper function for std::conj" alt="" coords="187,5,320,47"/>
</map>
</div>

</div>
</div>
<a id="ad02d47cab0fc5866bf2eb5c13acf659b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02d47cab0fc5866bf2eb5c13acf659b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE auto TiledArray::detail::operator* </td>
          <td>(</td>
          <td class="paramtype">const L&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; R &gt;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00214">214</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ad02d47cab0fc5866bf2eb5c13acf659b_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_ad02d47cab0fc5866bf2eb5c13acf659b_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ad02d47cab0fc5866bf2eb5c13acf659b_cgraph" id="anamespace_tiled_array_1_1detail_ad02d47cab0fc5866bf2eb5c13acf659b_cgraph">
<area shape="rect" title=" " alt="" coords="5,43,139,84"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383" title="Wrapper function for std::conj" alt="" coords="201,5,335,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html#a941fc6f3a110343828055a79096748ec" title=" " alt="" coords="187,71,349,127"/>
</map>
</div>

</div>
</div>
<a id="a8ee93af26740ea0ee7c7f67db9a46601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee93af26740ea0ee7c7f67db9a46601">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE auto TiledArray::detail::operator* </td>
          <td>(</td>
          <td class="paramtype">const L&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00220">220</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a8ee93af26740ea0ee7c7f67db9a46601_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a8ee93af26740ea0ee7c7f67db9a46601_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a8ee93af26740ea0ee7c7f67db9a46601_cgraph" id="anamespace_tiled_array_1_1detail_a8ee93af26740ea0ee7c7f67db9a46601_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,139,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383" title="Wrapper function for std::conj" alt="" coords="187,5,320,47"/>
</map>
</div>

</div>
</div>
<a id="af085e2abd40acbf24fbc80033634097b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af085e2abd40acbf24fbc80033634097b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; TiledArray::detail::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_size_array.html">SizeArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>orig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="size__array_8h_source.html#l00432">432</a> of file <a class="el" href="size__array_8h_source.html">size_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_af085e2abd40acbf24fbc80033634097b_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_af085e2abd40acbf24fbc80033634097b_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_af085e2abd40acbf24fbc80033634097b_cgraph" id="anamespace_tiled_array_1_1detail_af085e2abd40acbf24fbc80033634097b_cgraph">
<area shape="rect" title=" " alt="" coords="5,39,139,80"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a2cd1e7c394cfe8c14fe1419e4320b97d" title="Create a permuted copy of an array." alt="" coords="187,5,320,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_size_array.html#acca3c890ec0aeacf730d251a54105ac4" title=" " alt="" coords="187,71,320,112"/>
</map>
</div>

</div>
</div>
<a id="ab4bd519fc858458a6bf061c1ef2ef5b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4bd519fc858458a6bf061c1ef2ef5b3">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE L&amp; TiledArray::detail::operator*= </td>
          <td>(</td>
          <td class="paramtype">L &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1_complex_neg_tag.html">ComplexNegTag</a> &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00263">263</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ab4bd519fc858458a6bf061c1ef2ef5b3_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_ab4bd519fc858458a6bf061c1ef2ef5b3_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ab4bd519fc858458a6bf061c1ef2ef5b3_cgraph" id="anamespace_tiled_array_1_1detail_ab4bd519fc858458a6bf061c1ef2ef5b3_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,139,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383" title="Wrapper function for std::conj" alt="" coords="187,5,320,47"/>
</map>
</div>

</div>
</div>
<a id="acea2c5a93d37330153912da87c7c3877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea2c5a93d37330153912da87c7c3877">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L , typename R , typename std::enable_if&lt;!std::is_void&lt; R &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE L&amp; TiledArray::detail::operator*= </td>
          <td>(</td>
          <td class="paramtype">L &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; R &gt;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00251">251</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_acea2c5a93d37330153912da87c7c3877_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_acea2c5a93d37330153912da87c7c3877_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_acea2c5a93d37330153912da87c7c3877_cgraph" id="anamespace_tiled_array_1_1detail_acea2c5a93d37330153912da87c7c3877_cgraph">
<area shape="rect" title=" " alt="" coords="5,43,139,84"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383" title="Wrapper function for std::conj" alt="" coords="201,5,335,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html#a941fc6f3a110343828055a79096748ec" title=" " alt="" coords="187,71,349,127"/>
</map>
</div>

</div>
</div>
<a id="aa443b57aebf3d340cc65deeeb00c2073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa443b57aebf3d340cc65deeeb00c2073">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE L&amp; TiledArray::detail::operator*= </td>
          <td>(</td>
          <td class="paramtype">L &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00257">257</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_aa443b57aebf3d340cc65deeeb00c2073_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_aa443b57aebf3d340cc65deeeb00c2073_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_aa443b57aebf3d340cc65deeeb00c2073_cgraph" id="anamespace_tiled_array_1_1detail_aa443b57aebf3d340cc65deeeb00c2073_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,139,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383" title="Wrapper function for std::conj" alt="" coords="187,5,320,47"/>
</map>
</div>

</div>
</div>
<a id="aaf888c0b992f597156737f71e2bc6d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf888c0b992f597156737f71e2bc6d32">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Block &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::detail::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;&#160;</td>
          <td class="paramname"><em>bitset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bitset_8h_source.html#l00617">617</a> of file <a class="el" href="bitset_8h_source.html">bitset.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_aaf888c0b992f597156737f71e2bc6d32_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_aaf888c0b992f597156737f71e2bc6d32_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_aaf888c0b992f597156737f71e2bc6d32_cgraph" id="anamespace_tiled_array_1_1detail_aaf888c0b992f597156737f71e2bc6d32_cgraph">
<area shape="rect" title=" " alt="" coords="5,39,139,80"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_bitset.html#a88d8120017304c4545b6dd93254fcdf0" title="Data pointer accessor." alt="" coords="197,5,331,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_bitset.html#a955081011bf555458d1c85d4db2b1fa4" title="Bitset block size." alt="" coords="187,71,341,112"/>
</map>
</div>

</div>
</div>
<a id="a7179e9c73eed3c5738bf4d0c5ebd068d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7179e9c73eed3c5738bf4d0c5ebd068d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::detail::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_size_array.html">SizeArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>size_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="size__array_8h_source.html#l00440">440</a> of file <a class="el" href="size__array_8h_source.html">size_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a7179e9c73eed3c5738bf4d0c5ebd068d_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a7179e9c73eed3c5738bf4d0c5ebd068d_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a7179e9c73eed3c5738bf4d0c5ebd068d_cgraph" id="anamespace_tiled_array_1_1detail_a7179e9c73eed3c5738bf4d0c5ebd068d_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,139,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a5cd635d089830705f84e08204967760d" title="Print the content of an array like object." alt="" coords="187,5,320,47"/>
</map>
</div>

</div>
</div>
<a id="aaff7f022aafbfb5bac3eaf2afc31cae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff7f022aafbfb5bac3eaf2afc31cae6">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::detail::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html">TileConstReference</a>&lt; Impl &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>redirect operator to std::ostream for <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html" title="Tensor tile reference.">TileConstReference</a> objects </p>

<p class="definition">Definition at line <a class="el" href="array__impl_8h_source.html#l00195">195</a> of file <a class="el" href="array__impl_8h_source.html">array_impl.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_aaff7f022aafbfb5bac3eaf2afc31cae6_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_aaff7f022aafbfb5bac3eaf2afc31cae6_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_aaff7f022aafbfb5bac3eaf2afc31cae6_cgraph" id="anamespace_tiled_array_1_1detail_aaff7f022aafbfb5bac3eaf2afc31cae6_cgraph">
<area shape="rect" title="redirect operator to std::ostream for TileConstReference objects" alt="" coords="5,13,139,54"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html#a4a03aa8339e239d655767e750b7d295e" title=" " alt="" coords="187,13,373,54"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html#a3555a80759ee33348071903b0873e646" title=" " alt="" coords="421,5,579,61"/>
</map>
</div>

</div>
</div>
<a id="a218cac85d033808e795a87a686ce4fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218cac85d033808e795a87a686ce4fb6">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::detail::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html">TileReference</a>&lt; Impl &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>redirect operator to std::ostream for <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html" title="Tensor tile reference.">TileReference</a> objects </p>

<p class="definition">Definition at line <a class="el" href="array__impl_8h_source.html#l00132">132</a> of file <a class="el" href="array__impl_8h_source.html">array_impl.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a218cac85d033808e795a87a686ce4fb6_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a218cac85d033808e795a87a686ce4fb6_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a218cac85d033808e795a87a686ce4fb6_cgraph" id="anamespace_tiled_array_1_1detail_a218cac85d033808e795a87a686ce4fb6_cgraph">
<area shape="rect" title="redirect operator to std::ostream for TileReference objects" alt="" coords="5,5,139,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tile_reference.html#a5849258d39efbcd976336a8e4f43568c" title=" " alt="" coords="187,5,336,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tile_reference.html#ac58f5674fda99ca7e17b5ec5485b5dbb" title=" " alt="" coords="384,5,551,47"/>
</map>
</div>

</div>
</div>
<a id="aa26bd55f3154ac62a00c6ff633db1d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26bd55f3154ac62a00c6ff633db1d40">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::detail::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_val_array.html">ValArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>val_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="val__array_8h_source.html#l00480">480</a> of file <a class="el" href="val__array_8h_source.html">val_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_aa26bd55f3154ac62a00c6ff633db1d40_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_aa26bd55f3154ac62a00c6ff633db1d40_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_aa26bd55f3154ac62a00c6ff633db1d40_cgraph" id="anamespace_tiled_array_1_1detail_aa26bd55f3154ac62a00c6ff633db1d40_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,139,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a5cd635d089830705f84e08204967760d" title="Print the content of an array like object." alt="" coords="187,5,320,47"/>
</map>
</div>

</div>
</div>
<a id="a48b1ec146fbd546954d72262124a5b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b1ec146fbd546954d72262124a5b74">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>left_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>right_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality operator. </p>
<p>Compares the iterators for equality. They must reference the same range object to be considered equal. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The value type of the iterator </td></tr>
    <tr><td class="paramname">Container</td><td>The container that the iterator references </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left_it</td><td>The left-hand iterator to be compared </td></tr>
    <tr><td class="paramname">right_it</td><td>The right-hand iterator to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value and container are equal for the <code>left_it</code> and <code>right_it</code> , otherwise <code>false</code> . </dd></dl>

<p class="definition">Definition at line <a class="el" href="range__iterator_8h_source.html#l00175">175</a> of file <a class="el" href="range__iterator_8h_source.html">range_iterator.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a48b1ec146fbd546954d72262124a5b74_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a48b1ec146fbd546954d72262124a5b74_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a48b1ec146fbd546954d72262124a5b74_cgraph" id="anamespace_tiled_array_1_1detail_a48b1ec146fbd546954d72262124a5b74_cgraph">
<area shape="rect" title="Equality operator." alt="" coords="5,5,139,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_range_iterator.html#aa4828622538be2e635deb0ddae8149c6" title=" " alt="" coords="187,5,375,47"/>
</map>
</div>

</div>
</div>
<a id="a42595fd971b6420e4b921afb9eef9cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42595fd971b6420e4b921afb9eef9cb8">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range , typename OpResult &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">TensorInterface</a>&lt; T, <a class="el" href="class_tiled_array_1_1_range.html">Range</a>, OpResult &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">TensorInterface</a>&lt; T, <a class="el" href="class_tiled_array_1_1_range.html">Range</a>, OpResult &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shallow comparison operator. </p>
<dl class="section return"><dt>Returns</dt><dd>true if <code>first</code> and <code>second</code> view the same data block through equivalent ranges </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor__interface_8h_source.html#l01143">1143</a> of file <a class="el" href="tensor__interface_8h_source.html">tensor_interface.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a42595fd971b6420e4b921afb9eef9cb8_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a42595fd971b6420e4b921afb9eef9cb8_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a42595fd971b6420e4b921afb9eef9cb8_cgraph" id="anamespace_tiled_array_1_1detail_a42595fd971b6420e4b921afb9eef9cb8_cgraph">
<area shape="rect" title="Shallow comparison operator." alt="" coords="5,39,139,80"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a373bdeff93541d750c0ede469ac4fca8" title="Data pointer accessor." alt="" coords="191,5,357,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ac6b44c5958b6e30ac2f674e8f9d7f906" title="Tensor range object accessor." alt="" coords="187,71,361,112"/>
</map>
</div>

</div>
</div>
<a id="aa52461acf45d3505ede569ee1aaa395c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52461acf45d3505ede569ee1aaa395c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html">TileConstReference</a>&lt; Impl &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html">TileConstReference</a>&lt; Impl &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>comparison operator for <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html" title="Tensor tile reference.">TileConstReference</a> objects </p>

<p class="definition">Definition at line <a class="el" href="array__impl_8h_source.html#l00181">181</a> of file <a class="el" href="array__impl_8h_source.html">array_impl.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_aa52461acf45d3505ede569ee1aaa395c_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_aa52461acf45d3505ede569ee1aaa395c_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_aa52461acf45d3505ede569ee1aaa395c_cgraph" id="anamespace_tiled_array_1_1detail_aa52461acf45d3505ede569ee1aaa395c_cgraph">
<area shape="rect" title="comparison operator for TileConstReference objects" alt="" coords="5,13,139,54"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html#a4a03aa8339e239d655767e750b7d295e" title=" " alt="" coords="187,13,373,54"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html#a3555a80759ee33348071903b0873e646" title=" " alt="" coords="421,5,579,61"/>
</map>
</div>

</div>
</div>
<a id="a2cdeb370801b331554b63c01f4ac402b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cdeb370801b331554b63c01f4ac402b">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html">TileReference</a>&lt; Impl &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html">TileReference</a>&lt; Impl &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>comparison operator for <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html" title="Tensor tile reference.">TileReference</a> objects </p>

<p class="definition">Definition at line <a class="el" href="array__impl_8h_source.html#l00120">120</a> of file <a class="el" href="array__impl_8h_source.html">array_impl.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a2cdeb370801b331554b63c01f4ac402b_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a2cdeb370801b331554b63c01f4ac402b_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a2cdeb370801b331554b63c01f4ac402b_cgraph" id="anamespace_tiled_array_1_1detail_a2cdeb370801b331554b63c01f4ac402b_cgraph">
<area shape="rect" title="comparison operator for TileReference objects" alt="" coords="5,5,139,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tile_reference.html#a5849258d39efbcd976336a8e4f43568c" title=" " alt="" coords="187,5,336,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tile_reference.html#ac58f5674fda99ca7e17b5ec5485b5dbb" title=" " alt="" coords="384,5,551,47"/>
</map>
</div>

</div>
</div>
<a id="a9c12507ffe191d9e79b32f6687ec46b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c12507ffe191d9e79b32f6687ec46b1">&#9670;&nbsp;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Block &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt;Block&gt; TiledArray::detail::operator^ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise xor operator of bitset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Block</td><td>The bitset block type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand bitset </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand bitset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The union of the <code>left</code> and <code>right</code> bitsets </dd></dl>

<p class="definition">Definition at line <a class="el" href="bitset_8h_source.html#l00611">611</a> of file <a class="el" href="bitset_8h_source.html">bitset.h</a>.</p>

</div>
</div>
<a id="a0d0266e20b12eefced1cde7a01d4cdcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0266e20b12eefced1cde7a01d4cdcd">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Block &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt;Block&gt; TiledArray::detail::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise or operator of bitset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Block</td><td>The bitset block type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand bitset </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand bitset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The union of the <code>left</code> and <code>right</code> bitsets </dd></dl>

<p class="definition">Definition at line <a class="el" href="bitset_8h_source.html#l00599">599</a> of file <a class="el" href="bitset_8h_source.html">bitset.h</a>.</p>

</div>
</div>
<a id="a3f41e1794be8e3f5515437c8301585a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f41e1794be8e3f5515437c8301585a9">&#9670;&nbsp;</a></span>permute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputOp , typename OutputOp , typename Result , typename Perm , typename Arg0 , typename... Args, typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::permute </td>
          <td>(</td>
          <td class="paramtype">InputOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>input_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>output_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Result &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Arg0 &amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a permuted tensor copy. </p>
<p>The expected signature of the input operations is: </p><div class="fragment"><div class="line">Result::value_type input_op(<span class="keyword">const</span> Arg0::value_type, <span class="keyword">const</span></div>
<div class="line">Args::value_type...) </div>
</div><!-- fragment --><p> The expected signature of the output operations is:</p><div class="fragment"><div class="line"> <span class="keywordtype">void</span> output_op(Result::value_type*, <span class="keyword">const</span></div>
<div class="line">Result::value_type) </div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputOp</td><td>The input operation type </td></tr>
    <tr><td class="paramname">OutputOp</td><td>The output operation type </td></tr>
    <tr><td class="paramname">Result</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">Arg0</td><td>The first tensor argument type </td></tr>
    <tr><td class="paramname">Args</td><td>The remaining tensor argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_op</td><td>The operation that is used to generate the output value from the input arguments </td></tr>
    <tr><td class="paramname">output_op</td><td>The operation that is used to set the value of the result tensor given the element pointer and the result value </td></tr>
    <tr><td class="paramname">args</td><td>The data pointers of the tensors to be permuted </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation that will be applied to the copy </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2permute_8h_source.html#l00117">117</a> of file <a class="el" href="tensor_2permute_8h_source.html">permute.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a3f41e1794be8e3f5515437c8301585a9_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a3f41e1794be8e3f5515437c8301585a9_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a3f41e1794be8e3f5515437c8301585a9_cgraph" id="anamespace_tiled_array_1_1detail_a3f41e1794be8e3f5515437c8301585a9_cgraph">
<area shape="rect" title="Construct a permuted tensor copy." alt="" coords="5,175,139,216"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a38c80429be52090559d58f18c011ce30" title="Compute the fused dimensions for permutation." alt="" coords="218,65,358,107"/>
<area shape="rect" href="namespace_tiled_array.html#a09ca17753fe59a1d02033b03b343db89" title=" " alt="" coords="223,131,353,158"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a0734d99af5ce0b09816a2934366c9071" title="Matrix transpose and initialization." alt="" coords="187,182,389,209"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a27697ba2d56b48030427ed8996104fda" title=" " alt="" coords="199,233,377,275"/>
<area shape="rect" href="namespace_tiled_array.html#aea673bd36f494b9b4c040ea0e09c00bd" title=" " alt="" coords="215,306,361,333"/>
<area shape="rect" href="class_tiled_array_1_1_permutation.html#aacb3f970f21779e9a6c2024790dc7270" title="Domain size accessor." alt="" coords="451,65,627,107"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#abb08079140fa4ea486e8d6e77baf7158" title=" " alt="" coords="437,168,640,209"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1_transpose_unwind.html#af2a30045172f690528b7854f863f3c23" title=" " alt="" coords="688,168,891,209"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1_transpose_unwind.html#a4f8998233c204a3e00403d3533a96137" title=" " alt="" coords="688,103,891,144"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a91290718834db1912be15860e26759ba" title=" " alt="" coords="948,231,1104,272"/>
<area shape="rect" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#a3b04e4e0fdbfa84f935a3baf0bd8aac6" title=" " alt="" coords="1163,231,1342,272"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a9a5d7ed52ec58b94cc8c9532624a45ad" title=" " alt="" coords="948,136,1104,177"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1_block.html#a5b8fd799fcafd39809f7f7a5dcc2493f" title=" " alt="" coords="939,71,1113,112"/>
<area shape="rect" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#a4d1f8bfb9c56806c000338fdd393c872" title=" " alt="" coords="1163,136,1342,177"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1_block.html#a8541624decd7fa535c52f85c9499a0e1" title=" " alt="" coords="1165,5,1340,47"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a6137a96c445b26d23187018efa876aa5" title=" " alt="" coords="1161,71,1344,112"/>
<area shape="rect" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#ad76cb4c4568102c1faaefb5fab603a3c" title=" " alt="" coords="1392,71,1571,112"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a814ebc5ab1105e95a4f1047cad8e598a" title=" " alt="" coords="449,233,628,275"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a91a501b77b43ce96e37799f22096012b" title=" " alt="" coords="711,233,867,275"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a911b5f4183473c9c9300c370b90374df" title="Returns the number of tiles in the tensor." alt="" coords="460,364,617,405"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="460,299,617,340"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a3f41e1794be8e3f5515437c8301585a9_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a3f41e1794be8e3f5515437c8301585a9_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a3f41e1794be8e3f5515437c8301585a9_icgraph" id="anamespace_tiled_array_1_1detail_a3f41e1794be8e3f5515437c8301585a9_icgraph">
<area shape="rect" title="Construct a permuted tensor copy." alt="" coords="283,115,416,156"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#af174120ffd75a14d13077eff16452d9b" title="In&#45;place tensor permutation operations with contiguous data." alt="" coords="46,5,194,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_contract_reduce.html#a3edb113a3e4524ffa21985587b0b7311" title="Post processing step." alt="" coords="5,71,235,200"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a2788b8e3e27331097aa656a0e6e36b20" title="Initialize tensor with permuted tensor arguments." alt="" coords="53,224,187,265"/>
</map>
</div>

</div>
</div>
<a id="a2cd1e7c394cfe8c14fe1419e4320b97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd1e7c394cfe8c14fe1419e4320b97d">&#9670;&nbsp;</a></span>permute_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Perm , typename Arg , typename Result , typename  = std::enable_if_t&lt;is_permutation_v&lt;Perm&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::permute_array </td>
          <td>(</td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Result &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a permuted copy of an array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Perm</td><td>The permutation type </td></tr>
    <tr><td class="paramname">Arg</td><td>The input array type </td></tr>
    <tr><td class="paramname">Result</td><td>The output array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>The input array to be permuted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The output array that will hold the permuted array </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="permutation_8h_source.html#l00066">66</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a2cd1e7c394cfe8c14fe1419e4320b97d_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a2cd1e7c394cfe8c14fe1419e4320b97d_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a2cd1e7c394cfe8c14fe1419e4320b97d_icgraph" id="anamespace_tiled_array_1_1detail_a2cd1e7c394cfe8c14fe1419e4320b97d_icgraph">
<area shape="rect" title="Create a permuted copy of an array." alt="" coords="223,64,356,105"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#af085e2abd40acbf24fbc80033634097b" title=" " alt="" coords="23,5,157,47"/>
<area shape="rect" href="namespace_tiled_array.html#a586be997af3bd421583c8fd36c4e95f2" title="Permute a std::array." alt="" coords="11,71,169,98"/>
<area shape="rect" href="namespace_tiled_array.html#ae84ce21d711a462da4a1b44a811a5a94" title="In&#45;place permute a std::array." alt="" coords="5,122,175,149"/>
</map>
</div>

</div>
</div>
<a id="a3f0780ab65ca5778bd4ee8f2783a082a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0780ab65ca5778bd4ee8f2783a082a">&#9670;&nbsp;</a></span>prepend_dim_to_trange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TA::TiledRange</a> TiledArray::detail::prepend_dim_to_trange </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>array_trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>prepends an extra dimension to a TRange </p>
<p>The extra dimension will be the leading dimension, and will be blocked by <code>block_size</code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array_rank</td><td>extent of the leading dimension of the result </td></tr>
    <tr><td class="paramname">array_trange</td><td>the base trange </td></tr>
    <tr><td class="paramname">block_size</td><td>blocking range for the new dimension, the dimension being fused </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array.">TiledRange</a> of fused Array object </dd></dl>
<p>make the new <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> for new dimension</p>
<p>make the new range for N+1 Array</p>

<p class="definition">Definition at line <a class="el" href="vector__of__arrays_8h_source.html#l00024">24</a> of file <a class="el" href="vector__of__arrays_8h_source.html">vector_of_arrays.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a3f0780ab65ca5778bd4ee8f2783a082a_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a3f0780ab65ca5778bd4ee8f2783a082a_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a3f0780ab65ca5778bd4ee8f2783a082a_cgraph" id="anamespace_tiled_array_1_1detail_a3f0780ab65ca5778bd4ee8f2783a082a_cgraph">
<area shape="rect" title="prepends an extra dimension to a TRange" alt="" coords="5,5,189,47"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a9ab6d42af2997036d41180dfd5439544" title="Tile dimension boundary array accessor." alt="" coords="237,5,407,47"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a3f0780ab65ca5778bd4ee8f2783a082a_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a3f0780ab65ca5778bd4ee8f2783a082a_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a3f0780ab65ca5778bd4ee8f2783a082a_icgraph" id="anamespace_tiled_array_1_1detail_a3f0780ab65ca5778bd4ee8f2783a082a_icgraph">
<area shape="rect" title="prepends an extra dimension to a TRange" alt="" coords="225,5,409,47"/>
<area shape="rect" href="namespace_tiled_array.html#ac602cf7316f1296d1f59f76975f5cdfb" title="fuses a vector of DistArray objects, each with the same TiledRange into a DistArray with 1 more dimen..." alt="" coords="5,5,177,47"/>
</map>
</div>

</div>
</div>
<a id="a2c0a678c425372465314f925b87612ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0a678c425372465314f925b87612ce">&#9670;&nbsp;</a></span>print_array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::print_array </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the content of an array like object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The array container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>A standard output stream </td></tr>
    <tr><td class="paramname">a</td><td>The array-like container to be printed </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="utility_8h_source.html#l00063">63</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a2c0a678c425372465314f925b87612ce_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a2c0a678c425372465314f925b87612ce_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a2c0a678c425372465314f925b87612ce_cgraph" id="anamespace_tiled_array_1_1detail_a2c0a678c425372465314f925b87612ce_cgraph">
<area shape="rect" title="Print the content of an array like object." alt="" coords="5,5,139,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a5cd635d089830705f84e08204967760d" title="Print the content of an array like object." alt="" coords="187,5,320,47"/>
</map>
</div>

</div>
</div>
<a id="a5cd635d089830705f84e08204967760d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd635d089830705f84e08204967760d">&#9670;&nbsp;</a></span>print_array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::print_array </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the content of an array like object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The array container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>A standard output stream </td></tr>
    <tr><td class="paramname">a</td><td>The array-like container to be printed </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements in the array. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="utility_8h_source.html#l00048">48</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a5cd635d089830705f84e08204967760d_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a5cd635d089830705f84e08204967760d_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a5cd635d089830705f84e08204967760d_icgraph" id="anamespace_tiled_array_1_1detail_a5cd635d089830705f84e08204967760d_icgraph">
<area shape="rect" title="Print the content of an array like object." alt="" coords="531,147,664,188"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_blk_tsr_engine_base.html#a800a904556b489c3d7490375bbaf38b4" title="Expression identification tag." alt="" coords="265,37,483,79"/>
<area shape="rect" href="namespaceboost_1_1container.html#a91057ebcbd3efeccc821d3e10aab7bc6" title="Vector output stream operator." alt="" coords="268,103,480,130"/>
<area shape="rect" href="namespace_tiled_array.html#a00568c34aef7e5f9b2802cbdd4382ea5" title="Range output operator." alt="" coords="287,154,461,181"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a7179e9c73eed3c5738bf4d0c5ebd068d" title=" " alt="" coords="307,205,441,247"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a2c0a678c425372465314f925b87612ce" title="Print the content of an array like object." alt="" coords="307,271,441,312"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_blk_tsr_engine.html#a050b99490cc3d01856e7672a1be6bbb0" title="Expression identification tag." alt="" coords="19,5,204,47"/>
<area shape="rect" href="class_tiled_array_1_1expressions_1_1_scal_blk_tsr_engine.html#ae587b2ae06ce1914be291f5700fe996b" title="Expression identification tag." alt="" coords="5,71,217,112"/>
</map>
</div>

</div>
</div>
<a id="a7723231012d7f0f700b31406de463ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7723231012d7f0f700b31406de463ae4">&#9670;&nbsp;</a></span>remove_whitespace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::detail::remove_whitespace </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function removes all whitespace characters from a string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string we are removing whitespace from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>s</code>, but without whitespace. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="annotation_8h_source.html#l00052">52</a> of file <a class="el" href="annotation_8h_source.html">annotation.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a7723231012d7f0f700b31406de463ae4_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a7723231012d7f0f700b31406de463ae4_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a7723231012d7f0f700b31406de463ae4_icgraph" id="anamespace_tiled_array_1_1detail_a7723231012d7f0f700b31406de463ae4_icgraph">
<area shape="rect" title=" " alt="" coords="549,85,711,127"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a73854ab2c5a308c4c3f16544f6480b68" title=" " alt="" coords="368,56,501,97"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#af1a4bb50000c2c62628719892888b8bb" title=" " alt="" coords="5,64,139,105"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#aab69b5c6e7fe9114b25b22231b63aff4" title=" " alt="" coords="187,5,320,47"/>
</map>
</div>

</div>
</div>
<a id="af1a4bb50000c2c62628719892888b8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a4bb50000c2c62628719892888b8bb">&#9670;&nbsp;</a></span>split_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::detail::split_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Splits and sanitizes a string labeling a tensor's modes.</p>
<p>This function encapsulates <a class="el" href="namespace_tiled_array.html">TiledArray</a>'s string index parsing. It is a free function to facilitate usage outside the BipartiteIndexList class. This function will take a string and separate it into the individual mode labels. The API is designed so that <code>split_index</code> can be used with tensors-of-tensors as well as normal, non-nested tensors. By convention, tokenized indices of normal tensors are returned as "outer" indices. The resulting indices will be stripped of all whitespace to facilitate string comparisons.</p>
<dl class="section note"><dt>Note</dt><dd>This function will ensure that <code>idx</code> is a valid string label. This entails requiring that <code>is_valid_index(idx)</code> is true. It does not take into the rank and/or partitioning of the tensor being labeled, i.e., it is the caller's responsibility to make sure the index makes sense for the tensor being labeled.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The string label that should be tokenized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An std::pair such that the first element is a vector containing the tokenized outer indices and the second element of the std::pair is a std::vector with the tokenized inner indices. Inner indices will be an empty std::vector if <code>idx</code> is not a tensor-of-tensor index. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>if <code>idx</code> is not a valid string labeling. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to copy <code>idx</code> or to create the returns. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="annotation_8h_source.html#l00191">191</a> of file <a class="el" href="annotation_8h_source.html">annotation.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_af1a4bb50000c2c62628719892888b8bb_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_af1a4bb50000c2c62628719892888b8bb_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_af1a4bb50000c2c62628719892888b8bb_cgraph" id="anamespace_tiled_array_1_1detail_af1a4bb50000c2c62628719892888b8bb_cgraph">
<area shape="rect" title=" " alt="" coords="5,31,139,72"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#aab69b5c6e7fe9114b25b22231b63aff4" title=" " alt="" coords="187,60,320,101"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a73854ab2c5a308c4c3f16544f6480b68" title=" " alt="" coords="368,35,501,76"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a7723231012d7f0f700b31406de463ae4" title=" " alt="" coords="549,5,711,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a8995a103b8540e3506a34377ea37f331" title=" " alt="" coords="563,92,697,133"/>
</map>
</div>

</div>
</div>
<a id="a0313bd43006c929b4caf02174eb069a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0313bd43006c929b4caf02174eb069a1">&#9670;&nbsp;</a></span>subshape_from_fused_tile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dense_shape.html">TA::DenseShape</a> TiledArray::detail::subshape_from_fused_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TA::TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>split_trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dense_policy.html#a8577445584fe74ab5616e266be3ce3fd">TA::DensePolicy::shape_type</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>tile_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>split_ntiles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>tile_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extracts the shape of a subarray of a fused array created with fuse_vector_of_arrays </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fused_array</td><td>a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> created with fuse_vector_of_arrays </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index of the subarray whose Shape will be extracted (i.e. the index of the corresponding tile of the leading dimension) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">split_trange</td><td><a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array.">TiledRange</a> of the target subarray objct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Shape of the <code>i</code> -th subarray </dd></dl>

<p class="definition">Definition at line <a class="el" href="vector__of__arrays_8h_source.html#l00212">212</a> of file <a class="el" href="vector__of__arrays_8h_source.html">vector_of_arrays.h</a>.</p>

</div>
</div>
<a id="af29fcee5d56ed2b3110413f3d8d31d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29fcee5d56ed2b3110413f3d8d31d2f">&#9670;&nbsp;</a></span>subshape_from_fused_tile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_sparse_shape.html">TA::SparseShape</a>&lt;float&gt; TiledArray::detail::subshape_from_fused_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TA::TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>split_trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_sparse_policy.html#a27268892fb7382991d0d11f78f7c717e">TA::SparsePolicy::shape_type</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>tile_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>split_ntiles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>tile_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extracts the shape of a slice of a fused array created with fuse_vector_of_arrays </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">split_trange</td><td>the <a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array.">TiledRange</a> object of each "slice" array that was fused via fuse_vector_of_arrays </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>the shape of a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> created with fuse_vector_of_arrays </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tile_idx</td><td>the tile index of the leading mode that will be sliced off </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">split_ntiles</td><td>the number of tiles in each "slice" array that was fused via fuse_vector_of_arrays </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tile_size</td><td>the size of the tile of the leading dimension of the fused array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Shape of the <code>i</code> -th subarray </dd></dl>

<p class="definition">Definition at line <a class="el" href="vector__of__arrays_8h_source.html#l00180">180</a> of file <a class="el" href="vector__of__arrays_8h_source.html">vector_of_arrays.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_af29fcee5d56ed2b3110413f3d8d31d2f_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_af29fcee5d56ed2b3110413f3d8d31d2f_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_af29fcee5d56ed2b3110413f3d8d31d2f_cgraph" id="anamespace_tiled_array_1_1detail_af29fcee5d56ed2b3110413f3d8d31d2f_cgraph">
<area shape="rect" title="extracts the shape of a slice of a fused array created with fuse_vector_of_arrays" alt="" coords="5,71,207,112"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a9270d658412efce71cde14a4e9488664" title="Data direct access." alt="" coords="270,5,409,47"/>
<area shape="rect" href="class_tiled_array_1_1_tiled_range.html#a1980b233eaa1fc559b62cc8affc2bd34" title="Access the tile range." alt="" coords="255,71,424,112"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a63700b9c4ebc8c67f46325f77ed4cd2a" title="Range volume accessor." alt="" coords="267,136,412,177"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_af29fcee5d56ed2b3110413f3d8d31d2f_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_af29fcee5d56ed2b3110413f3d8d31d2f_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_af29fcee5d56ed2b3110413f3d8d31d2f_icgraph" id="anamespace_tiled_array_1_1detail_af29fcee5d56ed2b3110413f3d8d31d2f_icgraph">
<area shape="rect" title="extracts the shape of a slice of a fused array created with fuse_vector_of_arrays" alt="" coords="207,5,408,47"/>
<area shape="rect" href="namespace_tiled_array.html#a40ec22d8c4caa8f1662a6c124430e802" title="extracts a subarray of a fused array created with fuse_vector_of_arrays and creates the array in loca..." alt="" coords="5,5,159,47"/>
</map>
</div>

</div>
</div>
<a id="a1d6fcb450ef829c3ad4e8e1db5be514a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6fcb450ef829c3ad4e8e1db5be514a">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; B &gt; &amp;&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; B &gt; &amp;&#160;</td>
          <td class="paramname"><em>b1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bitset_8h_source.html#l00565">565</a> of file <a class="el" href="bitset_8h_source.html">bitset.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a1d6fcb450ef829c3ad4e8e1db5be514a_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a1d6fcb450ef829c3ad4e8e1db5be514a_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a1d6fcb450ef829c3ad4e8e1db5be514a_cgraph" id="anamespace_tiled_array_1_1detail_a1d6fcb450ef829c3ad4e8e1db5be514a_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,139,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_bitset.html#a2209fb744965af00ca19f67a95dd5ea5" title=" " alt="" coords="187,5,320,47"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a1d6fcb450ef829c3ad4e8e1db5be514a_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a1d6fcb450ef829c3ad4e8e1db5be514a_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a1d6fcb450ef829c3ad4e8e1db5be514a_icgraph" id="anamespace_tiled_array_1_1detail_a1d6fcb450ef829c3ad4e8e1db5be514a_icgraph">
<area shape="rect" title=" " alt="" coords="417,136,551,177"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_bitset.html#a2209fb744965af00ca19f67a95dd5ea5" title=" " alt="" coords="216,5,349,47"/>
<area shape="rect" href="class_tiled_array_1_1_block_range.html#aa8e883ff57e15866ee27e8e07dc60b90" title=" " alt="" coords="196,71,369,112"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a3c483d946734a44bcac9febd0cd2a48d" title="Swap this array with other." alt="" coords="204,136,361,177"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#ab7f33f8afac53cb621c12cac5e1d256a" title="Swap tensor data." alt="" coords="199,201,366,243"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a321129ac697a19c43ab91b307d3f9301" title="Swap tensor views." alt="" coords="197,267,369,308"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_val_array.html#afdff76007156bea6e89eadd6468f5a7c" title=" " alt="" coords="216,332,349,373"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_bitset.html#a74e819d5ddaaf4e60dd9b106181d1d60" title="Assignment operator." alt="" coords="5,5,148,47"/>
</map>
</div>

</div>
</div>
<a id="a2788b8e3e27331097aa656a0e6e36b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2788b8e3e27331097aa656a0e6e36b20">&#9670;&nbsp;</a></span>tensor_init() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op , typename TR , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::tensor_init </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TR &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize tensor with permuted tensor arguments. </p>
<p>Initialize tensor of tensors with permuted tensor arguments.</p>
<p>This function initializes the <code>i</code> -th element of <code>result</code> with the result of <code>op(tensor1[i], tensors[i]...)</code> </p><dl class="section pre"><dt>Precondition</dt><dd>The memory of <code>result</code> has been allocated but not initialized. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The element initialization operation type </td></tr>
    <tr><td class="paramname">TR</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation that will be applied to tensor2 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The argument tensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function initializes the <code>i</code> -th element of <code>result</code> with the result of <code>op(tensor1[i], tensors[i]...)</code> </p><dl class="section pre"><dt>Precondition</dt><dd>The memory of <code>result</code> has been allocated but not initialized. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The element initialization operation type </td></tr>
    <tr><td class="paramname">Perm</td><td>A permutation type </td></tr>
    <tr><td class="paramname">TR</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kernels_8h_source.html#l00488">488</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a2788b8e3e27331097aa656a0e6e36b20_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a2788b8e3e27331097aa656a0e6e36b20_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a2788b8e3e27331097aa656a0e6e36b20_cgraph" id="anamespace_tiled_array_1_1detail_a2788b8e3e27331097aa656a0e6e36b20_cgraph">
<area shape="rect" title="Initialize tensor with permuted tensor arguments." alt="" coords="5,100,139,141"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a2b25c9db0387e3327718de2cbc9112c6" title="Test for empty tensors in an empty list." alt="" coords="212,5,345,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c" title="Test that the ranges of a permuted tensor is congruent with itself." alt="" coords="187,71,371,112"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a3f41e1794be8e3f5515437c8301585a9" title="Construct a permuted tensor copy." alt="" coords="212,217,345,259"/>
<area shape="rect" href="class_tiled_array_1_1_permutation.html#aacb3f970f21779e9a6c2024790dc7270" title="Domain size accessor." alt="" coords="683,163,859,204"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a38c80429be52090559d58f18c011ce30" title="Compute the fused dimensions for permutation." alt="" coords="450,188,590,229"/>
<area shape="rect" href="namespace_tiled_array.html#a09ca17753fe59a1d02033b03b343db89" title=" " alt="" coords="455,371,585,398"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a0734d99af5ce0b09816a2934366c9071" title="Matrix transpose and initialization." alt="" coords="419,254,621,281"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a27697ba2d56b48030427ed8996104fda" title=" " alt="" coords="431,305,609,347"/>
<area shape="rect" href="namespace_tiled_array.html#aea673bd36f494b9b4c040ea0e09c00bd" title=" " alt="" coords="447,86,593,113"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#abb08079140fa4ea486e8d6e77baf7158" title=" " alt="" coords="669,243,872,284"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1_transpose_unwind.html#af2a30045172f690528b7854f863f3c23" title=" " alt="" coords="920,243,1123,284"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1_transpose_unwind.html#a4f8998233c204a3e00403d3533a96137" title=" " alt="" coords="920,177,1123,219"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a91290718834db1912be15860e26759ba" title=" " alt="" coords="1180,337,1336,379"/>
<area shape="rect" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#a3b04e4e0fdbfa84f935a3baf0bd8aac6" title=" " alt="" coords="1395,337,1574,379"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a9a5d7ed52ec58b94cc8c9532624a45ad" title=" " alt="" coords="1180,127,1336,168"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1_block.html#a5b8fd799fcafd39809f7f7a5dcc2493f" title=" " alt="" coords="1171,192,1345,233"/>
<area shape="rect" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#a4d1f8bfb9c56806c000338fdd393c872" title=" " alt="" coords="1395,127,1574,168"/>
<area shape="rect" href="class_tiled_array_1_1math_1_1_block.html#a8541624decd7fa535c52f85c9499a0e1" title=" " alt="" coords="1397,257,1572,299"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a6137a96c445b26d23187018efa876aa5" title=" " alt="" coords="1393,192,1576,233"/>
<area shape="rect" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#ad76cb4c4568102c1faaefb5fab603a3c" title=" " alt="" coords="1624,192,1803,233"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a814ebc5ab1105e95a4f1047cad8e598a" title=" " alt="" coords="681,308,860,349"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a91a501b77b43ce96e37799f22096012b" title=" " alt="" coords="943,308,1099,349"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a911b5f4183473c9c9300c370b90374df" title="Returns the number of tiles in the tensor." alt="" coords="692,24,849,65"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="692,89,849,131"/>
</map>
</div>

</div>
</div>
<a id="ac5132fe4d73d49d24d2dcd60f06849f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5132fe4d73d49d24d2dcd60f06849f9">&#9670;&nbsp;</a></span>tensor_init() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op , typename TR , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value &amp;&amp;is_contiguous_tensor&lt; TR &gt;::value &amp;&amp;!is_contiguous_tensor&lt; T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::tensor_init </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TR &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize tensor with one or more non-contiguous tensor arguments. </p>
<p>This function initializes the <code>i</code> -th element of <code>result</code> with the result of <code>op(tensor1[i], tensors[i]...)</code> </p><dl class="section pre"><dt>Precondition</dt><dd>The memory of <code>tensor1</code> has been allocated but not initialized. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The element initialization operation type </td></tr>
    <tr><td class="paramname">T1</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The argument tensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function initializes the <code>i</code> -th element of <code>result</code> with the result of <code>op(tensor1[i],tensors[i]...)</code> </p><dl class="section pre"><dt>Precondition</dt><dd>The memory of <code>tensor1</code> has been allocated but not initialized. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The element initialization operation type </td></tr>
    <tr><td class="paramname">T1</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kernels_8h_source.html#l00567">567</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ac5132fe4d73d49d24d2dcd60f06849f9_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_ac5132fe4d73d49d24d2dcd60f06849f9_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ac5132fe4d73d49d24d2dcd60f06849f9_cgraph" id="anamespace_tiled_array_1_1detail_ac5132fe4d73d49d24d2dcd60f06849f9_cgraph">
<area shape="rect" title="Initialize tensor with one or more non&#45;contiguous tensor arguments." alt="" coords="5,129,139,171"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a2b25c9db0387e3327718de2cbc9112c6" title="Test for empty tensors in an empty list." alt="" coords="212,5,345,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a91ec4c7e7bd4d19b11f0674903ce630a" title="Get the inner size of two tensors." alt="" coords="212,71,345,112"/>
<area shape="rect" href="namespace_tiled_array.html#aea673bd36f494b9b4c040ea0e09c00bd" title=" " alt="" coords="651,91,796,118"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c" title="Test that the ranges of a permuted tensor is congruent with itself." alt="" coords="187,188,371,229"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a27697ba2d56b48030427ed8996104fda" title=" " alt="" coords="189,253,368,295"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a85557b284f443993530894acbb158b58" title="Get the inner size." alt="" coords="436,71,580,112"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a911b5f4183473c9c9300c370b90374df" title="Returns the number of tiles in the tensor." alt="" coords="860,59,1017,100"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="860,124,1017,165"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a814ebc5ab1105e95a4f1047cad8e598a" title=" " alt="" coords="419,253,597,295"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a91290718834db1912be15860e26759ba" title=" " alt="" coords="645,215,801,256"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a91a501b77b43ce96e37799f22096012b" title=" " alt="" coords="645,280,801,321"/>
<area shape="rect" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#a3b04e4e0fdbfa84f935a3baf0bd8aac6" title=" " alt="" coords="849,215,1028,256"/>
</map>
</div>

</div>
</div>
<a id="a2fa32053a2cef8c73b71763a0e01cd95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa32053a2cef8c73b71763a0e01cd95">&#9670;&nbsp;</a></span>tensor_init() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op , typename TR , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, Ts... &gt;::value &amp;&amp;is_contiguous_tensor&lt; TR, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::tensor_init </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TR &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize tensor with contiguous tensor arguments. </p>
<p>Initialize tensor of tensors with contiguous tensor arguments.</p>
<p>This function initializes the <code>i</code> -th element of <code>result</code> with the result of <code>op(tensors[i]...)</code> </p><dl class="section pre"><dt>Precondition</dt><dd>The memory of <code>tensor1</code> has been allocated but not initialized. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The element initialization operation type </td></tr>
    <tr><td class="paramname">TR</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kernels_8h_source.html#l00421">421</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a2fa32053a2cef8c73b71763a0e01cd95_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a2fa32053a2cef8c73b71763a0e01cd95_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a2fa32053a2cef8c73b71763a0e01cd95_cgraph" id="anamespace_tiled_array_1_1detail_a2fa32053a2cef8c73b71763a0e01cd95_cgraph">
<area shape="rect" title="Initialize tensor with contiguous tensor arguments." alt="" coords="5,104,139,145"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a2b25c9db0387e3327718de2cbc9112c6" title="Test for empty tensors in an empty list." alt="" coords="212,5,345,47"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c" title="Test that the ranges of a permuted tensor is congruent with itself." alt="" coords="187,71,371,112"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a27697ba2d56b48030427ed8996104fda" title=" " alt="" coords="189,136,368,177"/>
<area shape="rect" href="namespace_tiled_array.html#aea673bd36f494b9b4c040ea0e09c00bd" title=" " alt="" coords="206,205,351,231"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a814ebc5ab1105e95a4f1047cad8e598a" title=" " alt="" coords="419,132,597,173"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a91290718834db1912be15860e26759ba" title=" " alt="" coords="645,99,801,140"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a91a501b77b43ce96e37799f22096012b" title=" " alt="" coords="645,164,801,205"/>
<area shape="rect" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#a3b04e4e0fdbfa84f935a3baf0bd8aac6" title=" " alt="" coords="849,99,1028,140"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a911b5f4183473c9c9300c370b90374df" title="Returns the number of tiles in the tensor." alt="" coords="429,197,587,239"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="429,263,587,304"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a2fa32053a2cef8c73b71763a0e01cd95_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a2fa32053a2cef8c73b71763a0e01cd95_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a2fa32053a2cef8c73b71763a0e01cd95_icgraph" id="anamespace_tiled_array_1_1detail_a2fa32053a2cef8c73b71763a0e01cd95_icgraph">
<area shape="rect" title="Initialize tensor with contiguous tensor arguments." alt="" coords="681,169,815,211"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ae11a9e70ba98eccc31ef6b8a265cc369" title="Use a binary, element wise operation to construct a new tensor." alt="" coords="447,71,626,112"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aebc5c8b00cc397f5ba32ea426d1ddcc3" title=" " alt="" coords="440,136,633,177"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#ad06d56e445f36d572109abbafc1a32e5" title="Construct a tensor with a fill value." alt="" coords="449,201,624,243"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ae5f80c1e7c2e5855313fad6ad10375b3" title="Use a unary, element wise operation to construct a new tensor." alt="" coords="449,267,624,308"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a0ef9fb1d4cd22af3bb02002209eb31f0" title="Add this and other to construct a new tensors." alt="" coords="225,5,387,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#af0e2f37b46d3c3c0fcc3ab77d8594b6f" title="Multiply this by right to create a new tensor." alt="" coords="222,71,390,112"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a8361c0f82bfdfcf468247cf566c87a89" title="Subtract this and right to construct a new tensor." alt="" coords="223,136,389,177"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a0f3da596fb623188a555eee31e968225" title="Subtract a constant from a copy of this tensor." alt="" coords="5,5,172,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a31362893bb066fe8568529f881028611" title="Add a constant to a copy of this tensor." alt="" coords="225,201,387,243"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a115f6c8f776a9d58a238dfc810758b34" title="Create a negated copy of this tensor." alt="" coords="225,267,387,308"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a4738cdadac53a8979ffb09d1409e0a1e" title="Construct a scaled copy of this tensor." alt="" coords="220,332,392,373"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#abe962a9632cf8da0e5bbcf7c12420acd" title="Create a complex conjugated copy of this tensor." alt="" coords="6,332,171,373"/>
</map>
</div>

</div>
</div>
<a id="a82f0f7c8a549579e118a89827e98726b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f0f7c8a549579e118a89827e98726b">&#9670;&nbsp;</a></span>tensor_op() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TR , typename Op , typename T1 , typename... Ts, typename std::enable_if&lt;(is_tensor&lt; T1, Ts... &gt;::value||is_tensor_of_tensor&lt; TR, T1, Ts... &gt;::value) &amp;&amp;is_contiguous_tensor&lt; T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TR TiledArray::detail::tensor_op </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> permutation operations with contiguous data. </p>
<p>This function transforms argument tensors applying a callable directly (i.e., tensor-wise as <code>result=op(perm,tensor1,tensors...)</code> ), or by lowering to the elements (i.e., element-wise as <code>result</code>[i]=op(perm,tensor1[i],tensors[i]...) ) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TR</td><td>The tensor result type </td></tr>
    <tr><td class="paramname">Op</td><td>A callable used to produce TR when called with the argument tensors, or produce TR's elements when called with the argument tensor's elements </td></tr>
    <tr><td class="paramname">T1</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The operation that is used to compute the result value from the input arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation applied to the argument tensors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The remaining argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kernels_8h_source.html#l00098">98</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>

</div>
</div>
<a id="ab9d3ac1bd3e7b1b004f489db1b4ce8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d3ac1bd3e7b1b004f489db1b4ce8be">&#9670;&nbsp;</a></span>tensor_op() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TR , typename Op , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value||is_tensor_of_tensor&lt; TR, T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TR TiledArray::detail::tensor_op </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> operations with contiguous data. </p>
<p>This function transforms argument tensors applying a callable directly (i.e., tensor-wise as <code>result=op(tensor1,tensors...)</code> ), or by lowering to the elements (i.e., element-wise as <code>result</code>[i]=op(tensor1[i],tensors[i]...) ) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TR</td><td>The tensor result type </td></tr>
    <tr><td class="paramname">Op</td><td>A callable used to produce TR when called with the argument tensors, or produce TR's elements when called with the argument tensor's elements </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramname">tensors</td><td>The remaining argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kernels_8h_source.html#l00066">66</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>

</div>
</div>
<a id="ab957a79bba9735ad3e405dbb8dd53796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab957a79bba9735ad3e405dbb8dd53796">&#9670;&nbsp;</a></span>tensor_reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReduceOp , typename JoinOp , typename Scalar , typename T1 , typename... Ts, typename std::enable_if_t&lt; is_tensor&lt; T1, Ts... &gt;::value &amp;&amp;is_contiguous_tensor&lt; T1, Ts... &gt;::value &amp;&amp;!is_reduce_op_v&lt; std::decay_t&lt; ReduceOp &gt;, std::decay_t&lt; Scalar &gt;, std::decay_t&lt; T1 &gt;, std::decay_t&lt; Ts &gt;... &gt;&gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar TiledArray::detail::tensor_reduce </td>
          <td>(</td>
          <td class="paramtype">ReduceOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>reduce_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JoinOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>join_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduction operation for contiguous tensors. </p>
<p>Reduction operation for non-contiguous tensors of tensors.</p>
<p>Reduction operation for non-contiguous tensors.</p>
<p>Reduction operation for contiguous tensors of tensors.</p>
<p>Reduction operation for tensors.</p>
<p>Perform an element-wise reduction of the tensors by executing <code>join_op(result, reduce_op(result, &amp;tensor1[i], &amp;tensors[i]...))</code> for each <code>i</code> in the index range of <code>tensor1</code> . <code>result</code> is initialized to <code>identity</code> . If HAVE_INTEL_TBB is defined, the reduction will be executed in an undefined order, otherwise will execute in the order of increasing <code>i</code> . </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReduceOp</td><td>The element-wise reduction operation type </td></tr>
    <tr><td class="paramname">JoinOp</td><td>The result operation type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_op</td><td>The element-wise reduction operation </td></tr>
    <tr><td class="paramname">identity</td><td>The initial value for the reduction and the result </td></tr>
    <tr><td class="paramname">tensor1</td><td>The first tensor to be reduced </td></tr>
    <tr><td class="paramname">tensors</td><td>The other tensors to be reduced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reduced value of the tensor(s)</dd></dl>
<p>Perform tensor-wise reduction of the tensors by executing <code>reduce_op(result, &amp;tensor1, &amp;tensors...)</code>. <code>result</code> is initialized to <code>identity</code> . </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReduceOp</td><td>The tensor-wise reduction operation type </td></tr>
    <tr><td class="paramname">JoinOp</td><td>The result operation type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_op</td><td>The element-wise reduction operation </td></tr>
    <tr><td class="paramname">identity</td><td>The initial value for the reduction and the result </td></tr>
    <tr><td class="paramname">tensor1</td><td>The first tensor to be reduced </td></tr>
    <tr><td class="paramname">tensors</td><td>The other tensors to be reduced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reduced value of the tensor(s)</dd></dl>
<p>Perform reduction of the tensor-of-tensors' elements by executing <code>join_op(result, reduce_op(tensor1[i], tensors[i]...))</code> for each <code>i</code> in the index range of <code>tensor1</code> . <code>result</code> is initialized to <code>identity</code> . This will execute serially, in the order of increasing <code>i</code> (each element's reduction can however be executed in parallel, depending on the element type). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReduceOp</td><td>The tensor-wise reduction operation type </td></tr>
    <tr><td class="paramname">JoinOp</td><td>The result operation type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_op</td><td>The element-wise reduction operation </td></tr>
    <tr><td class="paramname">join_op</td><td>The result join operation </td></tr>
    <tr><td class="paramname">identity</td><td>The initial value for the reduction and the result </td></tr>
    <tr><td class="paramname">tensor1</td><td>The first tensor to be reduced </td></tr>
    <tr><td class="paramname">tensors</td><td>The other tensors to be reduced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reduced value of the tensor(s)</dd></dl>
<p>Perform an element-wise reduction of the tensors by executing <code>join_op(result, reduce_op(tensor1[i], tensors[i]...))</code> for each <code>i</code> in the index range of <code>tensor1</code> . <code>result</code> is initialized to <code>identity</code> . This will execute serially, in the order of increasing <code>i</code> (each element-wise reduction can however be executed in parallel, depending on the element type). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReduceOp</td><td>The element-wise reduction operation type </td></tr>
    <tr><td class="paramname">JoinOp</td><td>The result operation type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_op</td><td>The element-wise reduction operation </td></tr>
    <tr><td class="paramname">join_op</td><td>The result join operation </td></tr>
    <tr><td class="paramname">identity</td><td>The initial value for the reduction and the result </td></tr>
    <tr><td class="paramname">tensor1</td><td>The first tensor to be reduced </td></tr>
    <tr><td class="paramname">tensors</td><td>The other tensors to be reduced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reduced value of the tensor(s) </dd></dl>

<p class="definition">Definition at line <a class="el" href="kernels_8h_source.html#l00665">665</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ab957a79bba9735ad3e405dbb8dd53796_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_ab957a79bba9735ad3e405dbb8dd53796_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ab957a79bba9735ad3e405dbb8dd53796_cgraph" id="anamespace_tiled_array_1_1detail_ab957a79bba9735ad3e405dbb8dd53796_cgraph">
<area shape="rect" title="Reduction operation for contiguous tensors." alt="" coords="5,123,139,164"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a2b25c9db0387e3327718de2cbc9112c6" title="Test for empty tensors in an empty list." alt="" coords="223,5,356,47"/>
<area shape="rect" href="namespace_tiled_array_1_1symmetry.html#ab88cc83a558d388cedeec00d2457827d" title="identity for group of objects of type T" alt="" coords="450,85,613,127"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c" title="Test that the ranges of a permuted tensor is congruent with itself." alt="" coords="197,123,381,164"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#a31eade2ac2d813846fc814cdc9238a10" title=" " alt="" coords="187,189,392,215"/>
<area shape="rect" href="namespace_tiled_array.html#aea673bd36f494b9b4c040ea0e09c00bd" title=" " alt="" coords="217,246,362,273"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#ad9f624a1f3753b2b2f03c88c80eec453" title=" " alt="" coords="440,173,623,215"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#aadfeae00d061d08d80824c75f5c1855c" title=" " alt="" coords="671,140,853,181"/>
<area shape="rect" href="namespace_tiled_array_1_1math.html#ad4c48eda75480eb3d3d267635eed78bb" title=" " alt="" coords="671,205,853,247"/>
<area shape="rect" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#a4efdedd3c89d0f2be14659b59a6acfb7" title=" " alt="" coords="901,140,1080,181"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a911b5f4183473c9c9300c370b90374df" title="Returns the number of tiles in the tensor." alt="" coords="453,239,610,280"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="453,304,610,345"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ab957a79bba9735ad3e405dbb8dd53796_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_ab957a79bba9735ad3e405dbb8dd53796_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ab957a79bba9735ad3e405dbb8dd53796_icgraph" id="anamespace_tiled_array_1_1detail_ab957a79bba9735ad3e405dbb8dd53796_icgraph">
<area shape="rect" title="Reduction operation for contiguous tensors." alt="" coords="735,316,868,357"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aad1e3e351ce4d80310c368f77375198c" title="Unary reduction operation." alt="" coords="504,283,687,324"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#ac7e2825494e7578e27becf11d2a6b794" title="Unary reduction operation." alt="" coords="507,348,683,389"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aadf392a65c7edfe026984dc11b0d47d8" title="Absolute maximum element." alt="" coords="242,5,439,47"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a19eafabec70f0ff8c67d5a48a41db533" title="Absolute minimum element." alt="" coords="244,71,437,112"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a2f3626dbf2d39bbc8abcd9c9c4c31b46" title="Vector dot product." alt="" coords="261,136,420,177"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a8690764d8a2dddcae1c41ffd903f9741" title=" " alt="" coords="255,202,426,258"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#af3a337e3cd4f50cb9bbcc4abc3e54bc1" title="Maximum element." alt="" coords="257,283,424,324"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#af06857f977bbfd0e4ea9fca89ed7bc2e" title="Minimum element." alt="" coords="259,348,422,389"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#af055ceb310d932e5ca4041972e86edd5" title="Product of elements." alt="" coords="247,413,434,455"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#acb4cc909b548c92259bba323ff9a1c08" title="Square of vector 2&#45;norm." alt="" coords="225,479,456,520"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a95349207699d2a263ed9eb7953f7fba8" title="Sum of elements." alt="" coords="257,544,424,585"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a38c72b1c4a3214b9eb06349ff17f46e3" title="Vector 2&#45;norm." alt="" coords="5,479,177,520"/>
</map>
</div>

</div>
</div>
<a id="a8995a103b8540e3506a34377ea37f331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8995a103b8540e3506a34377ea37f331">&#9670;&nbsp;</a></span>tokenize_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::detail::tokenize_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Splits a string into tokens based on a character delimiter</p>
<p>This function assumes that the input string can be considered a series of delimiter separated tokens. It will split the string into tokens and return an std::vector of the tokens. This function does no additional string processing (such as removing spaces).</p>
<p>It's worth noting several edge cases:</p>
<ul>
<li>If <code>s</code> is an empty string the result vector will contain a single empty string.</li>
<li>If <code>s</code> starts/ends with a delimiter the result vector will start/end with an empty string</li>
<li>Adjacent delimiters are tokenized as delimiting the empty string</li>
</ul>
<p>Downstream error checking relies on this edge case behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string we are splitting into tokens. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delim</td><td>The character used to delimit tokens </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the tokens </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to allocate the vector which will hold the return. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to allocate the tokens in the return. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="annotation_8h_source.html#l00081">81</a> of file <a class="el" href="annotation_8h_source.html">annotation.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a8995a103b8540e3506a34377ea37f331_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a8995a103b8540e3506a34377ea37f331_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a8995a103b8540e3506a34377ea37f331_icgraph" id="anamespace_tiled_array_1_1detail_a8995a103b8540e3506a34377ea37f331_icgraph">
<area shape="rect" title=" " alt="" coords="549,85,683,127"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a73854ab2c5a308c4c3f16544f6480b68" title=" " alt="" coords="368,56,501,97"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#af1a4bb50000c2c62628719892888b8bb" title=" " alt="" coords="5,64,139,105"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#aab69b5c6e7fe9114b25b22231b63aff4" title=" " alt="" coords="187,5,320,47"/>
</map>
</div>

</div>
</div>
<a id="a8c268a352be16fc597e6ad2c7d6a7560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c268a352be16fc597e6ad2c7d6a7560">&#9670;&nbsp;</a></span>write_diag_tiles_to_array_rng()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array , typename RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator.html">is_iterator</a>&lt;RandomAccessIterator&gt;::value, void&gt; TiledArray::detail::write_diag_tiles_to_array_rng </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>diagonals_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes tiles of a nonconstant diagonal array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Array</td><td>a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> type </td></tr>
    <tr><td class="paramname">RandomAccessIterator</td><td>an iterator over the range of diagonal elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>an Array object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diagonals_begin</td><td>the begin iterator of the range of the diagonals </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="diagonal__array_8h_source.html#l00194">194</a> of file <a class="el" href="diagonal__array_8h_source.html">diagonal_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a8c268a352be16fc597e6ad2c7d6a7560_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a8c268a352be16fc597e6ad2c7d6a7560_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a8c268a352be16fc597e6ad2c7d6a7560_cgraph" id="anamespace_tiled_array_1_1detail_a8c268a352be16fc597e6ad2c7d6a7560_cgraph">
<area shape="rect" title="Writes tiles of a nonconstant diagonal array." alt="" coords="5,144,159,200"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#ae2c7d290f2fb4704eecc33b0894de068" title="Computes a range of the diagonal elements (if any) in a rank&#45;d Range." alt="" coords="219,122,352,163"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a491195742ae543d2e53d2234bbd0b631" title="Rank accessor." alt="" coords="419,5,593,32"/>
<area shape="rect" href="namespace_tiled_array.html#ae6e2da9f3855369c97e61e9105cce50a" title=" " alt="" coords="443,188,569,215"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a740c01f878f645a3ab53274c912e0b72" title="Initialize (local) tiles with a user provided functor." alt="" coords="207,439,364,481"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ac1fe1f599524763265207c84e909dd15" title="Range lower bound data accessor." alt="" coords="433,57,579,98"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a7ee2666c973a1cc4a17845f6a410dbe9" title="Range upper bound data accessor." alt="" coords="433,122,579,163"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a2208a1aeda0c14164e2689ee284aace2" title=" " alt="" coords="648,97,823,124"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="657,181,814,222"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a8587157f8ad46d5da4f786b79110d0ab" title="End iterator factory function." alt="" coords="412,239,600,265"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a2ade24f4de11bf1d530e7873dfd19599" title="Find local or remote tile by index." alt="" coords="427,290,585,331"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a2c5ad33baf5e6d3778e685929ca78504" title="Query for a zero tile." alt="" coords="884,355,1039,397"/>
<area shape="rect" href="namespace_tiled_array.html#aa44cdecfe02b2ca9f8134aed6c94f39c" title=" " alt="" coords="429,407,583,449"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a918e59bf6434157aa2ee5bc55ef7346e" title="Accessor for the (shared_ptr to) implementation object." alt="" coords="427,473,585,514"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a5453d5add8c76bda66060c5bbffafd29" title="Tensor process map accessor." alt="" coords="433,538,579,579"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a32ab8231e6a7ef385ac938d1f98c649e" title=" " alt="" coords="414,604,598,631"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#ab9ccdd9c8bdae8959099fa3bf1568b31" title="Accessor for the (weak_ptr to) implementation object." alt="" coords="427,655,585,697"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#aad3dc345429ff7e85c8f0d970d3038bd" title="World accessor." alt="" coords="433,721,579,762"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_array_impl.html#a7d58f40964ccb5a9be544414f987e258" title="Tile future accessor." alt="" coords="669,290,802,331"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_distributed_storage.html#a1f2ed572953ea119f4cfb8505fca50b6" title="Get local or remote element." alt="" coords="871,225,1052,266"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#acc3da081fcb2fd124122dc750d182a96" title="Tiles range accessor." alt="" coords="871,290,1052,331"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a1a16c42818cf3c0174187604ed457e79" title="Tiled range accessor." alt="" coords="886,475,1037,517"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_array_impl.html#a3205617f6c181fc8857407704007622c" title="Set tile." alt="" coords="669,541,802,582"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_distributed_storage.html#aa74a42e37342f0c2a80f623ac077266e" title="Set element i with value." alt="" coords="871,541,1051,582"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_array_impl.html#a35765a0668e9e787ef688eb76f28a94e" title=" " alt="" coords="874,607,1049,663"/>
</map>
</div>

</div>
</div>
<a id="a808571423d2d6d551e9844f0b38369a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808571423d2d6d551e9844f0b38369a8">&#9670;&nbsp;</a></span>write_diag_tiles_to_array_val()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::write_diag_tiles_to_array_val </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes tiles of a constant diagonal array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Array</td><td>a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">DistArray</a> type </td></tr>
    <tr><td class="paramname">T</td><td>a numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>an Array object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>the value of the diagonal elements of A </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="diagonal__array_8h_source.html#l00161">161</a> of file <a class="el" href="diagonal__array_8h_source.html">diagonal_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a808571423d2d6d551e9844f0b38369a8_cgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a808571423d2d6d551e9844f0b38369a8_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a808571423d2d6d551e9844f0b38369a8_cgraph" id="anamespace_tiled_array_1_1detail_a808571423d2d6d551e9844f0b38369a8_cgraph">
<area shape="rect" title="Writes tiles of a constant diagonal array." alt="" coords="5,144,159,200"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#ae2c7d290f2fb4704eecc33b0894de068" title="Computes a range of the diagonal elements (if any) in a rank&#45;d Range." alt="" coords="219,122,352,163"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a491195742ae543d2e53d2234bbd0b631" title="Rank accessor." alt="" coords="419,5,593,32"/>
<area shape="rect" href="namespace_tiled_array.html#ae6e2da9f3855369c97e61e9105cce50a" title=" " alt="" coords="443,188,569,215"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a740c01f878f645a3ab53274c912e0b72" title="Initialize (local) tiles with a user provided functor." alt="" coords="207,439,364,481"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#ac1fe1f599524763265207c84e909dd15" title="Range lower bound data accessor." alt="" coords="433,57,579,98"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a7ee2666c973a1cc4a17845f6a410dbe9" title="Range upper bound data accessor." alt="" coords="433,122,579,163"/>
<area shape="rect" href="class_tiled_array_1_1_range.html#a2208a1aeda0c14164e2689ee284aace2" title=" " alt="" coords="648,97,823,124"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor." alt="" coords="657,181,814,222"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a8587157f8ad46d5da4f786b79110d0ab" title="End iterator factory function." alt="" coords="412,239,600,265"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a2ade24f4de11bf1d530e7873dfd19599" title="Find local or remote tile by index." alt="" coords="427,290,585,331"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a2c5ad33baf5e6d3778e685929ca78504" title="Query for a zero tile." alt="" coords="884,355,1039,397"/>
<area shape="rect" href="namespace_tiled_array.html#aa44cdecfe02b2ca9f8134aed6c94f39c" title=" " alt="" coords="429,407,583,449"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a918e59bf6434157aa2ee5bc55ef7346e" title="Accessor for the (shared_ptr to) implementation object." alt="" coords="427,473,585,514"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a5453d5add8c76bda66060c5bbffafd29" title="Tensor process map accessor." alt="" coords="433,538,579,579"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#a32ab8231e6a7ef385ac938d1f98c649e" title=" " alt="" coords="414,604,598,631"/>
<area shape="rect" href="class_tiled_array_1_1_dist_array.html#ab9ccdd9c8bdae8959099fa3bf1568b31" title="Accessor for the (weak_ptr to) implementation object." alt="" coords="427,655,585,697"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#aad3dc345429ff7e85c8f0d970d3038bd" title="World accessor." alt="" coords="433,721,579,762"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_array_impl.html#a7d58f40964ccb5a9be544414f987e258" title="Tile future accessor." alt="" coords="669,290,802,331"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_distributed_storage.html#a1f2ed572953ea119f4cfb8505fca50b6" title="Get local or remote element." alt="" coords="871,225,1052,266"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#acc3da081fcb2fd124122dc750d182a96" title="Tiles range accessor." alt="" coords="871,290,1052,331"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_tensor_impl.html#a1a16c42818cf3c0174187604ed457e79" title="Tiled range accessor." alt="" coords="886,475,1037,517"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_array_impl.html#a3205617f6c181fc8857407704007622c" title="Set tile." alt="" coords="669,541,802,582"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_distributed_storage.html#aa74a42e37342f0c2a80f623ac077266e" title="Set element i with value." alt="" coords="871,541,1051,582"/>
<area shape="rect" href="class_tiled_array_1_1detail_1_1_array_impl.html#a35765a0668e9e787ef688eb76f28a94e" title=" " alt="" coords="874,607,1049,663"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a808571423d2d6d551e9844f0b38369a8_icgraph.png" border="0" usemap="#anamespace_tiled_array_1_1detail_a808571423d2d6d551e9844f0b38369a8_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a808571423d2d6d551e9844f0b38369a8_icgraph" id="anamespace_tiled_array_1_1detail_a808571423d2d6d551e9844f0b38369a8_icgraph">
<area shape="rect" title="Writes tiles of a constant diagonal array." alt="" coords="205,5,359,61"/>
<area shape="rect" href="namespace_tiled_array.html#a8d2668989011ee62fa6314733cfc4a32" title="Creates a constant diagonal DistArray." alt="" coords="5,13,157,54"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a738e87dbca1a453733cb85b6c9d9fc24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a738e87dbca1a453733cb85b6c9d9fc24">&#9670;&nbsp;</a></span>has_conversion_operator_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class From , class To &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::has_conversion_operator_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    has_conversion_operator&lt;From, To&gt;::value</div>
</div><!-- fragment --><p><code>has_conversion_operator_v&lt;From, To&gt;</code> is an alias for <code>has_conversion_operator&lt;From, To&gt;::value</code> </p>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00496">496</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a70c761f7fc2da5f75088312b2ac6b420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c761f7fc2da5f75088312b2ac6b420">&#9670;&nbsp;</a></span>is_array_tile_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_array_tile_v = <a class="el" href="struct_tiled_array_1_1detail_1_1is__array__tile.html">is_array_tile</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>is_array_tile_v&lt;T&gt;</code> is an alias for <code>is_array_tile&lt;T&gt;::value</code> </p>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00678">678</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a456ed5bf7a518ffadf8cfe088b327fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456ed5bf7a518ffadf8cfe088b327fdc">&#9670;&nbsp;</a></span>is_boost_gettable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_boost_gettable_v = <a class="el" href="struct_tiled_array_1_1detail_1_1is__boost__gettable.html">is_boost_gettable</a>&lt;I, T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00851">851</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="ab0fc4bbe2156233325dde23dc13042f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0fc4bbe2156233325dde23dc13042f8">&#9670;&nbsp;</a></span>is_btas_tensor_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_btas_tensor_v = <a class="el" href="struct_tiled_array_1_1detail_1_1is__btas__tensor.html">is_btas_tensor</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="external_2btas_8h_source.html#l00827">827</a> of file <a class="el" href="external_2btas_8h_source.html">btas.h</a>.</p>

</div>
</div>
<a id="a0eeab9da39bfd45539541d0ba245d5cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eeab9da39bfd45539541d0ba245d5cf">&#9670;&nbsp;</a></span>is_complete_type_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_complete_type_v = <a class="el" href="struct_tiled_array_1_1detail_1_1is__complete__type.html">is_complete_type</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>a type <code>is_complete_type_v&lt;T&gt;</code> is an alias for <code>is_complete_type&lt;T&gt;::value</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00412">412</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="aa32d54448887aacc8b40faaff4ba3af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32d54448887aacc8b40faaff4ba3af8">&#9670;&nbsp;</a></span>is_complex_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_complex_v = <a class="el" href="struct_tiled_array_1_1detail_1_1is__complex.html">is_complex</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>is_complex_v&lt;T&gt;</code> is an alias for <code>is_complex&lt;T&gt;::value</code> </p>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00632">632</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a777fdd832b3e46e8d73323db6b3b32d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777fdd832b3e46e8d73323db6b3b32d3">&#9670;&nbsp;</a></span>is_contiguous_tensor_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_contiguous_tensor_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    is_contiguous_tensor&lt;Ts...&gt;::value</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>a parameter pack <code>is_contiguous_tensor_v&lt;Ts...&gt;</code> is an alias for <code>is_contiguous_tensor&lt;Ts...&gt;::value</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2type__traits_8h_source.html#l00211">211</a> of file <a class="el" href="tensor_2type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a6e024e5b73dac0ce527c0799b758fc22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e024e5b73dac0ce527c0799b758fc22">&#9670;&nbsp;</a></span>is_convertible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class From , class To &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_convertible_v = <a class="el" href="struct_tiled_array_1_1detail_1_1is__convertible.html">is_convertible</a>&lt;From, To&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>is_convertible_v&lt;From, To&gt;</code> is an alias for <code><a class="el" href="struct_tiled_array_1_1detail_1_1is__convertible.html">is_convertible</a>&lt;From</code>, To&gt;::value </p>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00537">537</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="ad87f63a46517a49b9362c388cbe57dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87f63a46517a49b9362c388cbe57dc3">&#9670;&nbsp;</a></span>is_explicitly_convertible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class From , class To &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_explicitly_convertible_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    is_explicitly_convertible&lt;From, To&gt;::value</div>
</div><!-- fragment --><p><code>is_explicitly_convertible_v&lt;From, To&gt;</code> is an alias for <code>is_explicitly_convertible&lt;From, To&gt;::value</code> </p>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00508">508</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a873d66153e5b72fbc331401fca1317d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873d66153e5b72fbc331401fca1317d7">&#9670;&nbsp;</a></span>is_gettable_pair_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_gettable_pair_v = <a class="el" href="struct_tiled_array_1_1detail_1_1is__gettable__pair.html">is_gettable_pair</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>is_gettable_pair_v&lt;T&gt;</code> is an alias for <code>is_gettable_pair&lt;T&gt;::value</code> </p>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00888">888</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="ab0fd750917972e009569639cc5263e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0fd750917972e009569639cc5263e9d">&#9670;&nbsp;</a></span>is_gettable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_gettable_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    is_std_gettable_v&lt;I, T&gt; || is_boost_gettable_v&lt;I, T&gt;</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00854">854</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="aa28ffa77b69964713adc5cf642fa23c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa28ffa77b69964713adc5cf642fa23c3">&#9670;&nbsp;</a></span>is_implicitly_convertible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class From , class To &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_implicitly_convertible_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    is_implicitly_convertible&lt;From, To&gt;::value</div>
</div><!-- fragment --><p><code>is_implicitly_convertible_v&lt;From, To&gt;</code> is an alias for <code>is_implicitly_convertible&lt;From, To&gt;::value</code> </p>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00521">521</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a3ae0a0fc086bf1faa014545962ad1781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae0a0fc086bf1faa014545962ad1781">&#9670;&nbsp;</a></span>is_integral_list_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_integral_list_v = <a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__list.html">is_integral_list</a>&lt;Ts...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>is_integral_list_v&lt;T&gt;</code> is an alias for <code>is_integral_list&lt;T&gt;::value</code> </p>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00812">812</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a5f60d0f0032505a78e85a7cfad30b0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f60d0f0032505a78e85a7cfad30b0d4">&#9670;&nbsp;</a></span>is_integral_pair_list_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_integral_pair_list_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    is_integral_pair_list&lt;Ts...&gt;::value</div>
</div><!-- fragment --><p><code>is_integral_pair_list_v&lt;T&gt;</code> is an alias for <code>is_integral_pair_list&lt;T&gt;::value</code> </p>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00939">939</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a185876cbe702ca84ba0549ccb1bc23a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185876cbe702ca84ba0549ccb1bc23a4">&#9670;&nbsp;</a></span>is_integral_pair_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_integral_pair_v = <a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__pair.html">is_integral_pair</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>is_integral_pair_v&lt;T&gt;</code> is an alias for <code>is_integral_pair&lt;T&gt;::value</code> </p>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00909">909</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="ad9bbbecc0133c913cf854acaafa37c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9bbbecc0133c913cf854acaafa37c3a">&#9670;&nbsp;</a></span>is_integral_tuple_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_integral_tuple_v = <a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__tuple.html">is_integral_tuple</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>is_integral_tuple_v&lt;T&gt;</code> is an alias for <code>is_integral_tuple&lt;T&gt;::value</code> </p>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00952">952</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a00d4bf07d4d516136a2aefa7deb770d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d4bf07d4d516136a2aefa7deb770d6">&#9670;&nbsp;</a></span>is_non_array_lazy_tile_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_non_array_lazy_tile_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    is_non_array_lazy_tile&lt;T&gt;::value</div>
</div><!-- fragment --><p><code>is_non_array_lazy_tile_v&lt;T&gt;</code> is an alias for <code>is_non_array_lazy_tile&lt;T&gt;::value</code> </p>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00696">696</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="ae9a8587fd56f077ba909b14bca4609d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a8587fd56f077ba909b14bca4609d9">&#9670;&nbsp;</a></span>is_numeric_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_numeric_v = <a class="el" href="struct_tiled_array_1_1detail_1_1is__numeric.html">is_numeric</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>is_numeric_v&lt;T&gt;</code> is an alias for <code>is_numeric&lt;T&gt;::value</code> </p>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00645">645</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a6619b110eb049fc229952dd9333028c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6619b110eb049fc229952dd9333028c2">&#9670;&nbsp;</a></span>is_pair_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_pair_v = <a class="el" href="struct_tiled_array_1_1detail_1_1is__pair.html">is_pair</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>is_pair_v&lt;T&gt;</code> is an alias for <code>is_pair&lt;T&gt;::value</code> </p>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l01203">1203</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a562496bd6662c46c3f33528f6560aa2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562496bd6662c46c3f33528f6560aa2a">&#9670;&nbsp;</a></span>is_reduce_op_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReduceOp , typename Result , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_reduce_op_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    is_reduce_op_&lt;void, ReduceOp, Result, Args...&gt;::value</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="tensor_2type__traits_8h_source.html#l00254">254</a> of file <a class="el" href="tensor_2type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a6e22c293cfc55984e9ed1df68a77d275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e22c293cfc55984e9ed1df68a77d275">&#9670;&nbsp;</a></span>is_scalar_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_scalar_v = <a class="el" href="struct_tiled_array_1_1detail_1_1is__scalar.html">is_scalar</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>is_scalar_v&lt;T&gt;</code> is an alias for <code>is_scalar_v&lt;T&gt;</code> </p>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00659">659</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a8c85c1749c56d6a8156eee0d6756d825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c85c1749c56d6a8156eee0d6756d825">&#9670;&nbsp;</a></span>is_shifted_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_shifted_v = <a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted.html">is_shifted</a>&lt;Ts...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>a parameter pack <code>is_shifted_v&lt;Ts...&gt;</code> is an alias for <code>is_shifted&lt;Ts...&gt;::value</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2type__traits_8h_source.html#l00240">240</a> of file <a class="el" href="tensor_2type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="ae65d6a1933a7fe06fc26e9e9268f19e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae65d6a1933a7fe06fc26e9e9268f19e1">&#9670;&nbsp;</a></span>is_std_gettable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_std_gettable_v = <a class="el" href="struct_tiled_array_1_1detail_1_1is__std__gettable.html">is_std_gettable</a>&lt;I, T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00840">840</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a652d029d8bd7e5758b370f2ca46982d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652d029d8bd7e5758b370f2ca46982d7">&#9670;&nbsp;</a></span>is_strictly_ordered_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_strictly_ordered_v = <a class="el" href="struct_tiled_array_1_1detail_1_1is__strictly__ordered.html">is_strictly_ordered</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>is_strictly_ordered_v&lt;T&gt;</code> is an alias for <code>is_strictly_ordered&lt;T&gt;::value</code> </p>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00786">786</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a61b2fe8adc99e9f280d17d7944b15bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b2fe8adc99e9f280d17d7944b15bdf">&#9670;&nbsp;</a></span>is_ta_tensor_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_ta_tensor_v = <a class="el" href="struct_tiled_array_1_1detail_1_1is__ta__tensor.html">is_ta_tensor</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_2type__traits_8h_source.html#l00164">164</a> of file <a class="el" href="tensor_2type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="ac758e2af2b4381cceea4816706e2d088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac758e2af2b4381cceea4816706e2d088">&#9670;&nbsp;</a></span>is_tensor_of_tensor_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_tensor_of_tensor_v = <a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor.html">is_tensor_of_tensor</a>&lt;Ts...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>a parameter pack <code>is_tensor_of_tensor_v&lt;Ts...&gt;</code> is an alias for <code>is_tensor_of_tensor&lt;Ts...&gt;::value</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2type__traits_8h_source.html#l00155">155</a> of file <a class="el" href="tensor_2type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="ab8e51e98990f8ec0f01aa129358ccfdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e51e98990f8ec0f01aa129358ccfdf">&#9670;&nbsp;</a></span>is_tensor_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_tensor_v = <a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor.html">is_tensor</a>&lt;Ts...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>a parameter pack <code>is_tensor_v&lt;Ts...&gt;</code> is an alias for <code>is_tensor&lt;Ts...&gt;::value</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2type__traits_8h_source.html#l00135">135</a> of file <a class="el" href="tensor_2type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a44fb59e16578e42b5c80d5002250218a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fb59e16578e42b5c80d5002250218a">&#9670;&nbsp;</a></span>is_tuple_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_tuple_v = <a class="el" href="struct_tiled_array_1_1detail_1_1is__tuple.html">is_tuple</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>is_tuple_v&lt;T&gt;</code> is an alias for <code>is_tuple&lt;T&gt;::value</code> </p>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00826">826</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a0329ff8ebbd09a1c3ab85f2a43e4d486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0329ff8ebbd09a1c3ab85f2a43e4d486">&#9670;&nbsp;</a></span>is_type_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const bool TiledArray::detail::is_type_v = <a class="el" href="struct_tiled_array_1_1detail_1_1is__type.html">is_type</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>a type <code>is_type_v&lt;T&gt;</code> is an alias for <code>is_type&lt;T&gt;::value</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00393">393</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a90b5d0dceea692165fc0b10fba571020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b5d0dceea692165fc0b10fba571020">&#9670;&nbsp;</a></span>trace_is_defined_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto TiledArray::detail::trace_is_defined_v = <a class="el" href="struct_tiled_array_1_1detail_1_1_trace_is_defined.html">TraceIsDefined</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper variable for determining if the trace operation is defined for a tile of type <code>T</code> </p>
<p>This global variable is provided as a convenience for checking the value of <code><a class="el" href="struct_tiled_array_1_1detail_1_1_trace_is_defined.html">TraceIsDefined</a>&lt;T&gt;::value</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the tile we are trying to take the trace of. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="trace_8h_source.html#l00057">57</a> of file <a class="el" href="trace_8h_source.html">trace.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespace_tiled_array_1_1math_1_1blas_html_a8f5d668dcf6615ea14cf699ab5fdd898"><div class="ttname"><a href="namespace_tiled_array_1_1math_1_1blas.html#a8f5d668dcf6615ea14cf699ab5fdd898">TiledArray::math::blas::Op</a></div><div class="ttdeci">::blas::Op Op</div><div class="ttdef"><b>Definition:</b> <a href="blas_8h_source.html#l00046">blas.h:46</a></div></div>

<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
    Generated at Sat Apr 24 2021 05:44:23 for <a href="https://https://github.com/ValeevGroup/tiledarray/">TiledArray</a>
    1.0.0 by &#160;<a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.20
</small></address>
</body>
<script type="text/javascript" src="doxy-boot.js"></script>
</html>
