<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.20"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>TiledArray: TiledArray::Tensor&lt; T, A &gt; Class Template Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
        <script type="text/javascript" src="jquery.smartmenus.js"></script>
        <!-- SmartMenus jQuery Bootstrap Addon -->
        <script type="text/javascript" src="jquery.smartmenus.bootstrap.js"></script>
        <!-- SmartMenus jQuery plugin -->
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">TiledArray 1.0.0</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="userguide.html"><span>User&#160;Guide</span></a></li>
      <li><a href="usergroup0.html"><span>Programmer&#160;Guides</span></a></li>
      <li class="current"><a href="usergroup1.html"><span>Source&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li class="current"><a href="annotated.html"><span>Class&#160;List</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_tiled_array.html">TiledArray</a></li><li class="navelem"><a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="class_tiled_array_1_1_tensor-members.html">List of all members</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">TiledArray::Tensor&lt; T, A &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Documentation</h2>
<div class="textblock"><h3>template&lt;typename T, typename A&gt;<br />
class TiledArray::Tensor&lt; T, A &gt;</h3>

<p>An N-dimensional tensor object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the value type of this tensor </td></tr>
    <tr><td class="paramname">A</td><td>The allocator type for the data </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00050">50</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5608ebaf867dc02438adf9475a5ed719"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a></td></tr>
<tr class="memdesc:a5608ebaf867dc02438adf9475a5ed719"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class type.  <a href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">More...</a><br /></td></tr>
<tr class="separator:a5608ebaf867dc02438adf9475a5ed719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6953592a083f07bc6132a571a9d767"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_range.html">Range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a></td></tr>
<tr class="memdesc:a9a6953592a083f07bc6132a571a9d767"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> range type.  <a href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">More...</a><br /></td></tr>
<tr class="separator:a9a6953592a083f07bc6132a571a9d767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9074d502998bbd5010bdf269aa67c350"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_range.html#a7eef119570cf35f5c554a379edab856a">range_type::index1_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a9074d502998bbd5010bdf269aa67c350">index1_type</a></td></tr>
<tr class="memdesc:a9074d502998bbd5010bdf269aa67c350"><td class="mdescLeft">&#160;</td><td class="mdescRight">1-index type  <a href="class_tiled_array_1_1_tensor.html#a9074d502998bbd5010bdf269aa67c350">More...</a><br /></td></tr>
<tr class="separator:a9074d502998bbd5010bdf269aa67c350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad041efe131da1739c84d97e7808f0044"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_range.html#a383765e8eefd94a2af57b5b5344e354e">range_type::ordinal_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ad041efe131da1739c84d97e7808f0044">ordinal_type</a></td></tr>
<tr class="memdesc:ad041efe131da1739c84d97e7808f0044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordinal type.  <a href="class_tiled_array_1_1_tensor.html#ad041efe131da1739c84d97e7808f0044">More...</a><br /></td></tr>
<tr class="separator:ad041efe131da1739c84d97e7808f0044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034d7cd975f2ed9cbe79adeccb687229"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_range.html#a383765e8eefd94a2af57b5b5344e354e">range_type::ordinal_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a034d7cd975f2ed9cbe79adeccb687229">size_type</a></td></tr>
<tr class="memdesc:a034d7cd975f2ed9cbe79adeccb687229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type (to meet the container concept)  <a href="class_tiled_array_1_1_tensor.html#a034d7cd975f2ed9cbe79adeccb687229">More...</a><br /></td></tr>
<tr class="separator:a034d7cd975f2ed9cbe79adeccb687229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99586ecbed993b0a7dc33ca231131d15"><td class="memItemLeft" align="right" valign="top">typedef A&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a99586ecbed993b0a7dc33ca231131d15">allocator_type</a></td></tr>
<tr class="memdesc:a99586ecbed993b0a7dc33ca231131d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type.  <a href="class_tiled_array_1_1_tensor.html#a99586ecbed993b0a7dc33ca231131d15">More...</a><br /></td></tr>
<tr class="separator:a99586ecbed993b0a7dc33ca231131d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64c1efaee17c30ac1559f18e1eb0e88"><td class="memItemLeft" align="right" valign="top">typedef allocator_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ab64c1efaee17c30ac1559f18e1eb0e88">value_type</a></td></tr>
<tr class="memdesc:ab64c1efaee17c30ac1559f18e1eb0e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array element type.  <a href="class_tiled_array_1_1_tensor.html#ab64c1efaee17c30ac1559f18e1eb0e88">More...</a><br /></td></tr>
<tr class="separator:ab64c1efaee17c30ac1559f18e1eb0e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8dc24eca41c8655a8871e838183e24b"><td class="memItemLeft" align="right" valign="top">typedef allocator_type::reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ac8dc24eca41c8655a8871e838183e24b">reference</a></td></tr>
<tr class="memdesc:ac8dc24eca41c8655a8871e838183e24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element reference type.  <a href="class_tiled_array_1_1_tensor.html#ac8dc24eca41c8655a8871e838183e24b">More...</a><br /></td></tr>
<tr class="separator:ac8dc24eca41c8655a8871e838183e24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b80372c9a8886e30106219eca40b66c"><td class="memItemLeft" align="right" valign="top">typedef allocator_type::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a8b80372c9a8886e30106219eca40b66c">const_reference</a></td></tr>
<tr class="memdesc:a8b80372c9a8886e30106219eca40b66c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element reference type.  <a href="class_tiled_array_1_1_tensor.html#a8b80372c9a8886e30106219eca40b66c">More...</a><br /></td></tr>
<tr class="separator:a8b80372c9a8886e30106219eca40b66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0c51fc37253afe287423fe5971da8c"><td class="memItemLeft" align="right" valign="top">typedef allocator_type::pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ace0c51fc37253afe287423fe5971da8c">pointer</a></td></tr>
<tr class="memdesc:ace0c51fc37253afe287423fe5971da8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element pointer type.  <a href="class_tiled_array_1_1_tensor.html#ace0c51fc37253afe287423fe5971da8c">More...</a><br /></td></tr>
<tr class="separator:ace0c51fc37253afe287423fe5971da8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b3ca56e0bf2b27a8632d1598c1d526"><td class="memItemLeft" align="right" valign="top">typedef allocator_type::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a13b3ca56e0bf2b27a8632d1598c1d526">const_pointer</a></td></tr>
<tr class="memdesc:a13b3ca56e0bf2b27a8632d1598c1d526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element const pointer type.  <a href="class_tiled_array_1_1_tensor.html#a13b3ca56e0bf2b27a8632d1598c1d526">More...</a><br /></td></tr>
<tr class="separator:a13b3ca56e0bf2b27a8632d1598c1d526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104deacaf44eb9d0fa97b32c59d53cc5"><td class="memItemLeft" align="right" valign="top">typedef allocator_type::difference_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a104deacaf44eb9d0fa97b32c59d53cc5">difference_type</a></td></tr>
<tr class="memdesc:a104deacaf44eb9d0fa97b32c59d53cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Difference type.  <a href="class_tiled_array_1_1_tensor.html#a104deacaf44eb9d0fa97b32c59d53cc5">More...</a><br /></td></tr>
<tr class="separator:a104deacaf44eb9d0fa97b32c59d53cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3a6bcdbeae5dec3343d6ae28df8284"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_tensor.html#ace0c51fc37253afe287423fe5971da8c">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a7c3a6bcdbeae5dec3343d6ae28df8284">iterator</a></td></tr>
<tr class="memdesc:a7c3a6bcdbeae5dec3343d6ae28df8284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element iterator type.  <a href="class_tiled_array_1_1_tensor.html#a7c3a6bcdbeae5dec3343d6ae28df8284">More...</a><br /></td></tr>
<tr class="separator:a7c3a6bcdbeae5dec3343d6ae28df8284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643a4203b62aa1e370d6995aad071f40"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_tensor.html#a13b3ca56e0bf2b27a8632d1598c1d526">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a643a4203b62aa1e370d6995aad071f40">const_iterator</a></td></tr>
<tr class="memdesc:a643a4203b62aa1e370d6995aad071f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element const iterator type.  <a href="class_tiled_array_1_1_tensor.html#a643a4203b62aa1e370d6995aad071f40">More...</a><br /></td></tr>
<tr class="separator:a643a4203b62aa1e370d6995aad071f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2e1a62ce018f90f552510d29fd9ed2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type.html">TiledArray::detail::numeric_type</a>&lt; T &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a></td></tr>
<tr class="memdesc:abc2e1a62ce018f90f552510d29fd9ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">the numeric type that supports T  <a href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">More...</a><br /></td></tr>
<tr class="separator:abc2e1a62ce018f90f552510d29fd9ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3ff935ffdd12ded18a1041a0a18faf"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type.html">TiledArray::detail::scalar_type</a>&lt; T &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a9a3ff935ffdd12ded18a1041a0a18faf">scalar_type</a></td></tr>
<tr class="memdesc:a9a3ff935ffdd12ded18a1041a0a18faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">the scalar type that supports T  <a href="class_tiled_array_1_1_tensor.html#a9a3ff935ffdd12ded18a1041a0a18faf">More...</a><br /></td></tr>
<tr class="separator:a9a3ff935ffdd12ded18a1041a0a18faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a52053224a88d9d8478805d7c5f89ec59"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a52053224a88d9d8478805d7c5f89ec59">Tensor</a> ()</td></tr>
<tr class="separator:a52053224a88d9d8478805d7c5f89ec59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414d8ebf6c834c5500ca5b5408708f58"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a414d8ebf6c834c5500ca5b5408708f58">Tensor</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;other)</td></tr>
<tr class="separator:a414d8ebf6c834c5500ca5b5408708f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437e6fa337043142c4be807cd46bf5d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a437e6fa337043142c4be807cd46bf5d1">Tensor</a> (<a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&amp;other)</td></tr>
<tr class="separator:a437e6fa337043142c4be807cd46bf5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709fe578d55e8ee8c1e187d6f1a1ad4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a709fe578d55e8ee8c1e187d6f1a1ad4e">~Tensor</a> ()</td></tr>
<tr class="separator:a709fe578d55e8ee8c1e187d6f1a1ad4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb641cc67d36bf3e87b59eaf10a2dff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a5bb641cc67d36bf3e87b59eaf10a2dff">operator=</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;other)</td></tr>
<tr class="separator:a5bb641cc67d36bf3e87b59eaf10a2dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375a995714597079b944907eb89245bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a375a995714597079b944907eb89245bc">operator=</a> (<a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&amp;other)</td></tr>
<tr class="separator:a375a995714597079b944907eb89245bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff000b8850b2992ff765eb3f8f116632"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#aff000b8850b2992ff765eb3f8f116632">Tensor</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a> &amp;<a class="el" href="class_tiled_array_1_1_tensor.html#ac6cab4cebeee61ec14aaf83ecc4b9952">range</a>)</td></tr>
<tr class="memdesc:aff000b8850b2992ff765eb3f8f116632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct tensor.  <a href="class_tiled_array_1_1_tensor.html#aff000b8850b2992ff765eb3f8f116632">More...</a><br /></td></tr>
<tr class="separator:aff000b8850b2992ff765eb3f8f116632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06d56e445f36d572109abbafc1a32e5"><td class="memTemplParams" colspan="2">template&lt;typename Value , typename std::enable_if&lt; std::is_same&lt; Value, value_type &gt;::value &amp;&amp;detail::is_tensor&lt; Value &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ad06d56e445f36d572109abbafc1a32e5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ad06d56e445f36d572109abbafc1a32e5">Tensor</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a> &amp;<a class="el" href="class_tiled_array_1_1_tensor.html#ac6cab4cebeee61ec14aaf83ecc4b9952">range</a>, const Value &amp;value)</td></tr>
<tr class="memdesc:ad06d56e445f36d572109abbafc1a32e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a tensor with a fill value.  <a href="class_tiled_array_1_1_tensor.html#ad06d56e445f36d572109abbafc1a32e5">More...</a><br /></td></tr>
<tr class="separator:ad06d56e445f36d572109abbafc1a32e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06d56e445f36d572109abbafc1a32e5"><td class="memTemplParams" colspan="2">template&lt;typename Value , typename std::enable_if&lt; detail::is_numeric_v&lt; Value &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ad06d56e445f36d572109abbafc1a32e5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ad06d56e445f36d572109abbafc1a32e5">Tensor</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a> &amp;<a class="el" href="class_tiled_array_1_1_tensor.html#ac6cab4cebeee61ec14aaf83ecc4b9952">range</a>, const Value &amp;value)</td></tr>
<tr class="memdesc:ad06d56e445f36d572109abbafc1a32e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a tensor with a fill value.  <a href="class_tiled_array_1_1_tensor.html#ad06d56e445f36d572109abbafc1a32e5">More...</a><br /></td></tr>
<tr class="separator:ad06d56e445f36d572109abbafc1a32e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a04249ef7d49a620988dec54b296f1a"><td class="memTemplParams" colspan="2">template&lt;typename InIter , typename std::enable_if&lt; TiledArray::detail::is_input_iterator&lt; InIter &gt;::value &amp;&amp;!std::is_pointer&lt; InIter &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a7a04249ef7d49a620988dec54b296f1a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a7a04249ef7d49a620988dec54b296f1a">Tensor</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a> &amp;<a class="el" href="class_tiled_array_1_1_tensor.html#ac6cab4cebeee61ec14aaf83ecc4b9952">range</a>, InIter it)</td></tr>
<tr class="memdesc:a7a04249ef7d49a620988dec54b296f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an evaluated tensor.  <a href="class_tiled_array_1_1_tensor.html#a7a04249ef7d49a620988dec54b296f1a">More...</a><br /></td></tr>
<tr class="separator:a7a04249ef7d49a620988dec54b296f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46913eeb18eceebf619a6d73698704a"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ad46913eeb18eceebf619a6d73698704a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ad46913eeb18eceebf619a6d73698704a">Tensor</a> (const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;<a class="el" href="class_tiled_array_1_1_tensor.html#ac6cab4cebeee61ec14aaf83ecc4b9952">range</a>, const U *u)</td></tr>
<tr class="separator:ad46913eeb18eceebf619a6d73698704a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb452aab64792336398f4b52f4f67df7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#aeb452aab64792336398f4b52f4f67df7">Tensor</a> (const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;<a class="el" href="class_tiled_array_1_1_tensor.html#ac6cab4cebeee61ec14aaf83ecc4b9952">range</a>, std::initializer_list&lt; T &gt; il)</td></tr>
<tr class="separator:aeb452aab64792336398f4b52f4f67df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8514a8061acfd51b3551dd42fd54c0a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename std::enable_if&lt; is_tensor&lt; T1 &gt;::value &amp;&amp;!std::is_same&lt; T1, Tensor_ &gt;::value &amp;&amp;!detail::has_conversion_operator_v&lt; T1, Tensor_ &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aa8514a8061acfd51b3551dd42fd54c0a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#aa8514a8061acfd51b3551dd42fd54c0a">Tensor</a> (const T1 &amp;other)</td></tr>
<tr class="memdesc:aa8514a8061acfd51b3551dd42fd54c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a copy of a tensor interface object.  <a href="class_tiled_array_1_1_tensor.html#aa8514a8061acfd51b3551dd42fd54c0a">More...</a><br /></td></tr>
<tr class="separator:aa8514a8061acfd51b3551dd42fd54c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97bb481eb9dc1357f2c8816fc456e3bf"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename Perm , typename std::enable_if&lt; is_tensor&lt; T1 &gt;::value &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a97bb481eb9dc1357f2c8816fc456e3bf"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a97bb481eb9dc1357f2c8816fc456e3bf">Tensor</a> (const T1 &amp;other, const Perm &amp;perm)</td></tr>
<tr class="memdesc:a97bb481eb9dc1357f2c8816fc456e3bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a permuted tensor copy.  <a href="class_tiled_array_1_1_tensor.html#a97bb481eb9dc1357f2c8816fc456e3bf">More...</a><br /></td></tr>
<tr class="separator:a97bb481eb9dc1357f2c8816fc456e3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af833692ef1ebff1764c2cabbebd1e2f9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename Op , typename std::enable_if_t&lt; is_tensor&lt; T1 &gt;::value &amp;&amp;!detail::is_permutation_v&lt; std::decay_t&lt; Op &gt;&gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af833692ef1ebff1764c2cabbebd1e2f9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#af833692ef1ebff1764c2cabbebd1e2f9">Tensor</a> (const T1 &amp;other, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:af833692ef1ebff1764c2cabbebd1e2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and modify the data from <code>other</code>.  <a href="class_tiled_array_1_1_tensor.html#af833692ef1ebff1764c2cabbebd1e2f9">More...</a><br /></td></tr>
<tr class="separator:af833692ef1ebff1764c2cabbebd1e2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecb683b594553acfcf27fc321723c28"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename Op , typename Perm , typename std::enable_if_t&lt; is_tensor&lt; T1 &gt;::value &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aeecb683b594553acfcf27fc321723c28"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#aeecb683b594553acfcf27fc321723c28">Tensor</a> (const T1 &amp;other, Op &amp;&amp;op, const Perm &amp;perm)</td></tr>
<tr class="memdesc:aeecb683b594553acfcf27fc321723c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy, modify, and permute the data from <code>other</code>.  <a href="class_tiled_array_1_1_tensor.html#aeecb683b594553acfcf27fc321723c28">More...</a><br /></td></tr>
<tr class="separator:aeecb683b594553acfcf27fc321723c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4212439f4e33716dabdf6ecafb626991"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename Op , typename std::enable_if&lt; is_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a4212439f4e33716dabdf6ecafb626991"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a4212439f4e33716dabdf6ecafb626991">Tensor</a> (const T1 &amp;left, const T2 &amp;right, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:a4212439f4e33716dabdf6ecafb626991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and modify the data from <code>left</code>, and <code>right</code>.  <a href="class_tiled_array_1_1_tensor.html#a4212439f4e33716dabdf6ecafb626991">More...</a><br /></td></tr>
<tr class="separator:a4212439f4e33716dabdf6ecafb626991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e0066dc1184e3a5d6d6c7b5b46738a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename Op , typename Perm , typename std::enable_if&lt; is_tensor&lt; T1, T2 &gt;::value &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ae9e0066dc1184e3a5d6d6c7b5b46738a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ae9e0066dc1184e3a5d6d6c7b5b46738a">Tensor</a> (const T1 &amp;left, const T2 &amp;right, Op &amp;&amp;op, const Perm &amp;perm)</td></tr>
<tr class="memdesc:ae9e0066dc1184e3a5d6d6c7b5b46738a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy, modify, and permute the data from <code>left</code>, and <code>right</code>.  <a href="class_tiled_array_1_1_tensor.html#ae9e0066dc1184e3a5d6d6c7b5b46738a">More...</a><br /></td></tr>
<tr class="separator:ae9e0066dc1184e3a5d6d6c7b5b46738a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b98a790ddf50ce4097387d49119017c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a7b98a790ddf50ce4097387d49119017c">clone</a> () const</td></tr>
<tr class="separator:a7b98a790ddf50ce4097387d49119017c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864d3eed3caa265526a36b1e042aaeb9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename std::enable_if&lt; is_tensor&lt; T1 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a864d3eed3caa265526a36b1e042aaeb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a864d3eed3caa265526a36b1e042aaeb9">operator=</a> (const T1 &amp;other)</td></tr>
<tr class="separator:a864d3eed3caa265526a36b1e042aaeb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cab4cebeee61ec14aaf83ecc4b9952"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ac6cab4cebeee61ec14aaf83ecc4b9952">range</a> () const</td></tr>
<tr class="memdesc:ac6cab4cebeee61ec14aaf83ecc4b9952"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> range object accessor.  <a href="class_tiled_array_1_1_tensor.html#ac6cab4cebeee61ec14aaf83ecc4b9952">More...</a><br /></td></tr>
<tr class="separator:ac6cab4cebeee61ec14aaf83ecc4b9952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a674f9d2eae6d11a1e1885a0648bb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a68a674f9d2eae6d11a1e1885a0648bb4">range</a> ()</td></tr>
<tr class="memdesc:a68a674f9d2eae6d11a1e1885a0648bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> range object mutable accessor.  <a href="class_tiled_array_1_1_tensor.html#a68a674f9d2eae6d11a1e1885a0648bb4">More...</a><br /></td></tr>
<tr class="separator:a68a674f9d2eae6d11a1e1885a0648bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27ca10b5f528a0625e1eacd76106880"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#ad041efe131da1739c84d97e7808f0044">ordinal_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ab27ca10b5f528a0625e1eacd76106880">size</a> () const</td></tr>
<tr class="memdesc:ab27ca10b5f528a0625e1eacd76106880"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> dimension size accessor.  <a href="class_tiled_array_1_1_tensor.html#ab27ca10b5f528a0625e1eacd76106880">More...</a><br /></td></tr>
<tr class="separator:ab27ca10b5f528a0625e1eacd76106880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16630328ba56e7a3a07d54b7874e351"><td class="memTemplParams" colspan="2">template&lt;typename Ordinal , std::enable_if_t&lt; std::is_integral&lt; Ordinal &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa16630328ba56e7a3a07d54b7874e351"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a8b80372c9a8886e30106219eca40b66c">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#aa16630328ba56e7a3a07d54b7874e351">operator[]</a> (const Ordinal ord) const</td></tr>
<tr class="memdesc:aa16630328ba56e7a3a07d54b7874e351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const element accessor.  <a href="class_tiled_array_1_1_tensor.html#aa16630328ba56e7a3a07d54b7874e351">More...</a><br /></td></tr>
<tr class="separator:aa16630328ba56e7a3a07d54b7874e351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80576d30a4df7373e9c8d2cb4dc31c02"><td class="memTemplParams" colspan="2">template&lt;typename Ordinal , std::enable_if_t&lt; std::is_integral&lt; Ordinal &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a80576d30a4df7373e9c8d2cb4dc31c02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#ac8dc24eca41c8655a8871e838183e24b">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a80576d30a4df7373e9c8d2cb4dc31c02">operator[]</a> (const Ordinal ord)</td></tr>
<tr class="memdesc:a80576d30a4df7373e9c8d2cb4dc31c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element accessor.  <a href="class_tiled_array_1_1_tensor.html#a80576d30a4df7373e9c8d2cb4dc31c02">More...</a><br /></td></tr>
<tr class="separator:a80576d30a4df7373e9c8d2cb4dc31c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee102f98ee1f3dbbff088326c4cb451d"><td class="memTemplParams" colspan="2">template&lt;typename Index , std::enable_if_t&lt; detail::is_integral_range_v&lt; Index &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aee102f98ee1f3dbbff088326c4cb451d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a8b80372c9a8886e30106219eca40b66c">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#aee102f98ee1f3dbbff088326c4cb451d">operator[]</a> (const Index &amp;i) const</td></tr>
<tr class="memdesc:aee102f98ee1f3dbbff088326c4cb451d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const element accessor.  <a href="class_tiled_array_1_1_tensor.html#aee102f98ee1f3dbbff088326c4cb451d">More...</a><br /></td></tr>
<tr class="separator:aee102f98ee1f3dbbff088326c4cb451d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369f15590536ef934aadcf7ca3e81c39"><td class="memTemplParams" colspan="2">template&lt;typename Index , std::enable_if_t&lt; detail::is_integral_range_v&lt; Index &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a369f15590536ef934aadcf7ca3e81c39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#ac8dc24eca41c8655a8871e838183e24b">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a369f15590536ef934aadcf7ca3e81c39">operator[]</a> (const Index &amp;i)</td></tr>
<tr class="memdesc:a369f15590536ef934aadcf7ca3e81c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element accessor.  <a href="class_tiled_array_1_1_tensor.html#a369f15590536ef934aadcf7ca3e81c39">More...</a><br /></td></tr>
<tr class="separator:a369f15590536ef934aadcf7ca3e81c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2b8aab181d58b58375240cb45caa24"><td class="memTemplParams" colspan="2">template&lt;typename Integer , std::enable_if_t&lt; std::is_integral_v&lt; Integer &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6b2b8aab181d58b58375240cb45caa24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a8b80372c9a8886e30106219eca40b66c">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a6b2b8aab181d58b58375240cb45caa24">operator[]</a> (const std::initializer_list&lt; Integer &gt; &amp;i) const</td></tr>
<tr class="memdesc:a6b2b8aab181d58b58375240cb45caa24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const element accessor.  <a href="class_tiled_array_1_1_tensor.html#a6b2b8aab181d58b58375240cb45caa24">More...</a><br /></td></tr>
<tr class="separator:a6b2b8aab181d58b58375240cb45caa24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94a39ec1c61317a773d2c36b6f7c609"><td class="memTemplParams" colspan="2">template&lt;typename Integer , std::enable_if_t&lt; std::is_integral_v&lt; Integer &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab94a39ec1c61317a773d2c36b6f7c609"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#ac8dc24eca41c8655a8871e838183e24b">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ab94a39ec1c61317a773d2c36b6f7c609">operator[]</a> (const std::initializer_list&lt; Integer &gt; &amp;i)</td></tr>
<tr class="memdesc:ab94a39ec1c61317a773d2c36b6f7c609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element accessor.  <a href="class_tiled_array_1_1_tensor.html#ab94a39ec1c61317a773d2c36b6f7c609">More...</a><br /></td></tr>
<tr class="separator:ab94a39ec1c61317a773d2c36b6f7c609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be3cd4f960dda017f9832f0d1a12f15"><td class="memTemplParams" colspan="2">template&lt;typename Index , std::enable_if_t&lt; detail::is_integral_range_v&lt; Index &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9be3cd4f960dda017f9832f0d1a12f15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a8b80372c9a8886e30106219eca40b66c">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a9be3cd4f960dda017f9832f0d1a12f15">operator()</a> (const Index &amp;i) const</td></tr>
<tr class="memdesc:a9be3cd4f960dda017f9832f0d1a12f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const element accessor.  <a href="class_tiled_array_1_1_tensor.html#a9be3cd4f960dda017f9832f0d1a12f15">More...</a><br /></td></tr>
<tr class="separator:a9be3cd4f960dda017f9832f0d1a12f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5a17c369d356dc4001df631308341e"><td class="memTemplParams" colspan="2">template&lt;typename Index , std::enable_if_t&lt; detail::is_integral_range_v&lt; Index &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0a5a17c369d356dc4001df631308341e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#ac8dc24eca41c8655a8871e838183e24b">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a0a5a17c369d356dc4001df631308341e">operator()</a> (const Index &amp;i)</td></tr>
<tr class="memdesc:a0a5a17c369d356dc4001df631308341e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element accessor.  <a href="class_tiled_array_1_1_tensor.html#a0a5a17c369d356dc4001df631308341e">More...</a><br /></td></tr>
<tr class="separator:a0a5a17c369d356dc4001df631308341e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a5986f523b7cb219da0b0b7d41e776"><td class="memTemplParams" colspan="2">template&lt;typename Integer , std::enable_if_t&lt; std::is_integral_v&lt; Integer &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad5a5986f523b7cb219da0b0b7d41e776"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a8b80372c9a8886e30106219eca40b66c">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ad5a5986f523b7cb219da0b0b7d41e776">operator()</a> (const std::initializer_list&lt; Integer &gt; &amp;i) const</td></tr>
<tr class="memdesc:ad5a5986f523b7cb219da0b0b7d41e776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const element accessor.  <a href="class_tiled_array_1_1_tensor.html#ad5a5986f523b7cb219da0b0b7d41e776">More...</a><br /></td></tr>
<tr class="separator:ad5a5986f523b7cb219da0b0b7d41e776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ce6b66356074415d13c6e1a28282fb"><td class="memTemplParams" colspan="2">template&lt;typename Integer , std::enable_if_t&lt; std::is_integral_v&lt; Integer &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a55ce6b66356074415d13c6e1a28282fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#ac8dc24eca41c8655a8871e838183e24b">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a55ce6b66356074415d13c6e1a28282fb">operator()</a> (const std::initializer_list&lt; Integer &gt; &amp;i)</td></tr>
<tr class="memdesc:a55ce6b66356074415d13c6e1a28282fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element accessor.  <a href="class_tiled_array_1_1_tensor.html#a55ce6b66356074415d13c6e1a28282fb">More...</a><br /></td></tr>
<tr class="separator:a55ce6b66356074415d13c6e1a28282fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40b96a1c4b7750244b8505b39ecc53f"><td class="memTemplParams" colspan="2">template&lt;typename... Index, std::enable_if_t&lt; detail::is_integral_list&lt; Index... &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af40b96a1c4b7750244b8505b39ecc53f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a8b80372c9a8886e30106219eca40b66c">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#af40b96a1c4b7750244b8505b39ecc53f">operator()</a> (const Index &amp;... i) const</td></tr>
<tr class="memdesc:af40b96a1c4b7750244b8505b39ecc53f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const element accessor.  <a href="class_tiled_array_1_1_tensor.html#af40b96a1c4b7750244b8505b39ecc53f">More...</a><br /></td></tr>
<tr class="separator:af40b96a1c4b7750244b8505b39ecc53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee30f450ec40eb4d5df2f054b384ed85"><td class="memTemplParams" colspan="2">template&lt;typename... Index, std::enable_if_t&lt; detail::is_integral_list&lt; Index... &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aee30f450ec40eb4d5df2f054b384ed85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#ac8dc24eca41c8655a8871e838183e24b">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#aee30f450ec40eb4d5df2f054b384ed85">operator()</a> (const Index &amp;... i)</td></tr>
<tr class="memdesc:aee30f450ec40eb4d5df2f054b384ed85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element accessor.  <a href="class_tiled_array_1_1_tensor.html#aee30f450ec40eb4d5df2f054b384ed85">More...</a><br /></td></tr>
<tr class="separator:aee30f450ec40eb4d5df2f054b384ed85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1674e15d020be9f9087d935589a849"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a643a4203b62aa1e370d6995aad071f40">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#aca1674e15d020be9f9087d935589a849">begin</a> () const</td></tr>
<tr class="memdesc:aca1674e15d020be9f9087d935589a849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator factory.  <a href="class_tiled_array_1_1_tensor.html#aca1674e15d020be9f9087d935589a849">More...</a><br /></td></tr>
<tr class="separator:aca1674e15d020be9f9087d935589a849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb2732327b1e80aae0f82e590824642"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a7c3a6bcdbeae5dec3343d6ae28df8284">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a6cb2732327b1e80aae0f82e590824642">begin</a> ()</td></tr>
<tr class="memdesc:a6cb2732327b1e80aae0f82e590824642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator factory.  <a href="class_tiled_array_1_1_tensor.html#a6cb2732327b1e80aae0f82e590824642">More...</a><br /></td></tr>
<tr class="separator:a6cb2732327b1e80aae0f82e590824642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694f5a6f30c4f98cca111e2de3d7be90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a643a4203b62aa1e370d6995aad071f40">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a694f5a6f30c4f98cca111e2de3d7be90">end</a> () const</td></tr>
<tr class="memdesc:a694f5a6f30c4f98cca111e2de3d7be90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator factory.  <a href="class_tiled_array_1_1_tensor.html#a694f5a6f30c4f98cca111e2de3d7be90">More...</a><br /></td></tr>
<tr class="separator:a694f5a6f30c4f98cca111e2de3d7be90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388e96f2343d855abff091534612abbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a7c3a6bcdbeae5dec3343d6ae28df8284">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a388e96f2343d855abff091534612abbd">end</a> ()</td></tr>
<tr class="memdesc:a388e96f2343d855abff091534612abbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator factory.  <a href="class_tiled_array_1_1_tensor.html#a388e96f2343d855abff091534612abbd">More...</a><br /></td></tr>
<tr class="separator:a388e96f2343d855abff091534612abbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9270d658412efce71cde14a4e9488664"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a13b3ca56e0bf2b27a8632d1598c1d526">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a9270d658412efce71cde14a4e9488664">data</a> () const</td></tr>
<tr class="memdesc:a9270d658412efce71cde14a4e9488664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data direct access.  <a href="class_tiled_array_1_1_tensor.html#a9270d658412efce71cde14a4e9488664">More...</a><br /></td></tr>
<tr class="separator:a9270d658412efce71cde14a4e9488664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372ad5542cb41792eb72a6e1da63b6b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#ace0c51fc37253afe287423fe5971da8c">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a372ad5542cb41792eb72a6e1da63b6b0">data</a> ()</td></tr>
<tr class="memdesc:a372ad5542cb41792eb72a6e1da63b6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data direct access.  <a href="class_tiled_array_1_1_tensor.html#a372ad5542cb41792eb72a6e1da63b6b0">More...</a><br /></td></tr>
<tr class="separator:a372ad5542cb41792eb72a6e1da63b6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ac278b525693192e0c84e330016890"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a42ac278b525693192e0c84e330016890">empty</a> () const</td></tr>
<tr class="memdesc:a42ac278b525693192e0c84e330016890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the tensor is empty.  <a href="class_tiled_array_1_1_tensor.html#a42ac278b525693192e0c84e330016890">More...</a><br /></td></tr>
<tr class="separator:a42ac278b525693192e0c84e330016890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18da463545a06f07288ea5c8439c63a8"><td class="memTemplParams" colspan="2">template&lt;typename Archive , typename std::enable_if&lt; madness::archive::is_output_archive&lt; Archive &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a18da463545a06f07288ea5c8439c63a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a18da463545a06f07288ea5c8439c63a8">serialize</a> (Archive &amp;ar)</td></tr>
<tr class="memdesc:a18da463545a06f07288ea5c8439c63a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output serialization function.  <a href="class_tiled_array_1_1_tensor.html#a18da463545a06f07288ea5c8439c63a8">More...</a><br /></td></tr>
<tr class="separator:a18da463545a06f07288ea5c8439c63a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18da463545a06f07288ea5c8439c63a8"><td class="memTemplParams" colspan="2">template&lt;typename Archive , typename std::enable_if&lt; madness::archive::is_input_archive&lt; Archive &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a18da463545a06f07288ea5c8439c63a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a18da463545a06f07288ea5c8439c63a8">serialize</a> (Archive &amp;ar)</td></tr>
<tr class="memdesc:a18da463545a06f07288ea5c8439c63a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input serialization function.  <a href="class_tiled_array_1_1_tensor.html#a18da463545a06f07288ea5c8439c63a8">More...</a><br /></td></tr>
<tr class="separator:a18da463545a06f07288ea5c8439c63a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f33f8afac53cb621c12cac5e1d256a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ab7f33f8afac53cb621c12cac5e1d256a">swap</a> (<a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;other)</td></tr>
<tr class="memdesc:ab7f33f8afac53cb621c12cac5e1d256a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap tensor data.  <a href="class_tiled_array_1_1_tensor.html#ab7f33f8afac53cb621c12cac5e1d256a">More...</a><br /></td></tr>
<tr class="separator:ab7f33f8afac53cb621c12cac5e1d256a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414d53dd49a11ae4a6e67907a5daa521"><td class="memTemplParams" colspan="2">template&lt;typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:a414d53dd49a11ae4a6e67907a5daa521"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a414d53dd49a11ae4a6e67907a5daa521">permute</a> (const Perm &amp;perm) const</td></tr>
<tr class="memdesc:a414d53dd49a11ae4a6e67907a5daa521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a permuted copy of this tensor.  <a href="class_tiled_array_1_1_tensor.html#a414d53dd49a11ae4a6e67907a5daa521">More...</a><br /></td></tr>
<tr class="separator:a414d53dd49a11ae4a6e67907a5daa521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99244c08d85b7a5a2836418e0cdece1c"><td class="memTemplParams" colspan="2">template&lt;typename Index , std::enable_if_t&lt; detail::is_integral_range_v&lt; Index &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a99244c08d85b7a5a2836418e0cdece1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a99244c08d85b7a5a2836418e0cdece1c">shift_to</a> (const Index &amp;bound_shift)</td></tr>
<tr class="memdesc:a99244c08d85b7a5a2836418e0cdece1c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> the lower and upper bound of this tensor.  <a href="class_tiled_array_1_1_tensor.html#a99244c08d85b7a5a2836418e0cdece1c">More...</a><br /></td></tr>
<tr class="separator:a99244c08d85b7a5a2836418e0cdece1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9da26ffb207aa005eb6b9bb797a5fa"><td class="memTemplParams" colspan="2">template&lt;typename Integer , std::enable_if_t&lt; std::is_integral_v&lt; Integer &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5c9da26ffb207aa005eb6b9bb797a5fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a5c9da26ffb207aa005eb6b9bb797a5fa">shift_to</a> (const std::initializer_list&lt; Integer &gt; &amp;bound_shift)</td></tr>
<tr class="memdesc:a5c9da26ffb207aa005eb6b9bb797a5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> the lower and upper bound of this tensor.  <a href="class_tiled_array_1_1_tensor.html#a5c9da26ffb207aa005eb6b9bb797a5fa">More...</a><br /></td></tr>
<tr class="separator:a5c9da26ffb207aa005eb6b9bb797a5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041163e241c9d1ecd99598984fae784a"><td class="memTemplParams" colspan="2">template&lt;typename Index , std::enable_if_t&lt; detail::is_integral_range_v&lt; Index &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a041163e241c9d1ecd99598984fae784a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a041163e241c9d1ecd99598984fae784a">shift</a> (const Index &amp;bound_shift) const</td></tr>
<tr class="memdesc:a041163e241c9d1ecd99598984fae784a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> the lower and upper bound of this range.  <a href="class_tiled_array_1_1_tensor.html#a041163e241c9d1ecd99598984fae784a">More...</a><br /></td></tr>
<tr class="separator:a041163e241c9d1ecd99598984fae784a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab080220cf616d0710a89d30d36abbe3a"><td class="memTemplParams" colspan="2">template&lt;typename Integer , std::enable_if_t&lt; std::is_integral_v&lt; Integer &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab080220cf616d0710a89d30d36abbe3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ab080220cf616d0710a89d30d36abbe3a">shift</a> (const std::initializer_list&lt; Integer &gt; &amp;bound_shift) const</td></tr>
<tr class="memdesc:ab080220cf616d0710a89d30d36abbe3a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> the lower and upper bound of this range.  <a href="class_tiled_array_1_1_tensor.html#ab080220cf616d0710a89d30d36abbe3a">More...</a><br /></td></tr>
<tr class="separator:ab080220cf616d0710a89d30d36abbe3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622a65abf1a4fee5b1239c248006802e"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Op , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a622a65abf1a4fee5b1239c248006802e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a622a65abf1a4fee5b1239c248006802e">binary</a> (const Right &amp;right, Op &amp;&amp;op) const</td></tr>
<tr class="memdesc:a622a65abf1a4fee5b1239c248006802e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a binary, element wise operation to construct a new tensor.  <a href="class_tiled_array_1_1_tensor.html#a622a65abf1a4fee5b1239c248006802e">More...</a><br /></td></tr>
<tr class="separator:a622a65abf1a4fee5b1239c248006802e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ef14e0a09d55fee40c40fbf5ac58b2"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Op , typename Perm , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a83ef14e0a09d55fee40c40fbf5ac58b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a83ef14e0a09d55fee40c40fbf5ac58b2">binary</a> (const Right &amp;right, Op &amp;&amp;op, const Perm &amp;perm) const</td></tr>
<tr class="memdesc:a83ef14e0a09d55fee40c40fbf5ac58b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a binary, element wise operation to construct a new, permuted tensor.  <a href="class_tiled_array_1_1_tensor.html#a83ef14e0a09d55fee40c40fbf5ac58b2">More...</a><br /></td></tr>
<tr class="separator:a83ef14e0a09d55fee40c40fbf5ac58b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272585651b1233bb8f90d23c88a12c61"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Op , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a272585651b1233bb8f90d23c88a12c61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a272585651b1233bb8f90d23c88a12c61">inplace_binary</a> (const Right &amp;right, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:a272585651b1233bb8f90d23c88a12c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a binary, element wise operation to modify this tensor.  <a href="class_tiled_array_1_1_tensor.html#a272585651b1233bb8f90d23c88a12c61">More...</a><br /></td></tr>
<tr class="separator:a272585651b1233bb8f90d23c88a12c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436d7001abd661cec40f412138d6defd"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:a436d7001abd661cec40f412138d6defd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a436d7001abd661cec40f412138d6defd">unary</a> (Op &amp;&amp;op) const</td></tr>
<tr class="memdesc:a436d7001abd661cec40f412138d6defd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a unary, element wise operation to construct a new tensor.  <a href="class_tiled_array_1_1_tensor.html#a436d7001abd661cec40f412138d6defd">More...</a><br /></td></tr>
<tr class="separator:a436d7001abd661cec40f412138d6defd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f907f15ed5a44df959cfccc950368ac"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:a1f907f15ed5a44df959cfccc950368ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a1f907f15ed5a44df959cfccc950368ac">unary</a> (Op &amp;&amp;op, const Perm &amp;perm) const</td></tr>
<tr class="memdesc:a1f907f15ed5a44df959cfccc950368ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a unary, element wise operation to construct a new, permuted tensor.  <a href="class_tiled_array_1_1_tensor.html#a1f907f15ed5a44df959cfccc950368ac">More...</a><br /></td></tr>
<tr class="separator:a1f907f15ed5a44df959cfccc950368ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23df0d855cd33e6e977bd39e780ca9a"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:af23df0d855cd33e6e977bd39e780ca9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#af23df0d855cd33e6e977bd39e780ca9a">inplace_unary</a> (Op &amp;&amp;op)</td></tr>
<tr class="memdesc:af23df0d855cd33e6e977bd39e780ca9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a unary, element wise operation to modify this tensor.  <a href="class_tiled_array_1_1_tensor.html#af23df0d855cd33e6e977bd39e780ca9a">More...</a><br /></td></tr>
<tr class="separator:af23df0d855cd33e6e977bd39e780ca9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199903e3d39e1eaa85f6f3a582bde77e"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a199903e3d39e1eaa85f6f3a582bde77e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a199903e3d39e1eaa85f6f3a582bde77e">scale</a> (const Scalar factor) const</td></tr>
<tr class="memdesc:a199903e3d39e1eaa85f6f3a582bde77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a scaled copy of this tensor.  <a href="class_tiled_array_1_1_tensor.html#a199903e3d39e1eaa85f6f3a582bde77e">More...</a><br /></td></tr>
<tr class="separator:a199903e3d39e1eaa85f6f3a582bde77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728823702c51b94983044531bf8130c3"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Perm , typename  = std::enable_if_t&lt;detail::is_numeric_v&lt;Scalar&gt; &amp;&amp;                                        detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:a728823702c51b94983044531bf8130c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a728823702c51b94983044531bf8130c3">scale</a> (const Scalar factor, const Perm &amp;perm) const</td></tr>
<tr class="memdesc:a728823702c51b94983044531bf8130c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a scaled and permuted copy of this tensor.  <a href="class_tiled_array_1_1_tensor.html#a728823702c51b94983044531bf8130c3">More...</a><br /></td></tr>
<tr class="separator:a728823702c51b94983044531bf8130c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ee5e211e0a606f194bde6699b9d373"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a19ee5e211e0a606f194bde6699b9d373"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a19ee5e211e0a606f194bde6699b9d373">scale_to</a> (const Scalar factor)</td></tr>
<tr class="memdesc:a19ee5e211e0a606f194bde6699b9d373"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile.">Scale</a> this tensor.  <a href="class_tiled_array_1_1_tensor.html#a19ee5e211e0a606f194bde6699b9d373">More...</a><br /></td></tr>
<tr class="separator:a19ee5e211e0a606f194bde6699b9d373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259865850e25a60be57add9ffc139ee9"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a259865850e25a60be57add9ffc139ee9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a259865850e25a60be57add9ffc139ee9">add</a> (const Right &amp;right) const</td></tr>
<tr class="memdesc:a259865850e25a60be57add9ffc139ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> this and <code>other</code> to construct a new tensors.  <a href="class_tiled_array_1_1_tensor.html#a259865850e25a60be57add9ffc139ee9">More...</a><br /></td></tr>
<tr class="separator:a259865850e25a60be57add9ffc139ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2f0e1b76bf74c9c06c4fddfdda4529"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Perm , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:abc2f0e1b76bf74c9c06c4fddfdda4529"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2f0e1b76bf74c9c06c4fddfdda4529">add</a> (const Right &amp;right, const Perm &amp;perm) const</td></tr>
<tr class="memdesc:abc2f0e1b76bf74c9c06c4fddfdda4529"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> this and <code>other</code> to construct a new, permuted tensor.  <a href="class_tiled_array_1_1_tensor.html#abc2f0e1b76bf74c9c06c4fddfdda4529">More...</a><br /></td></tr>
<tr class="separator:abc2f0e1b76bf74c9c06c4fddfdda4529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70de9d453ba8286336bfbaeee552ed1"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:af70de9d453ba8286336bfbaeee552ed1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#af70de9d453ba8286336bfbaeee552ed1">add</a> (const Right &amp;right, const Scalar factor) const</td></tr>
<tr class="memdesc:af70de9d453ba8286336bfbaeee552ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile.">Scale</a> and add this and <code>other</code> to construct a new tensor.  <a href="class_tiled_array_1_1_tensor.html#af70de9d453ba8286336bfbaeee552ed1">More...</a><br /></td></tr>
<tr class="separator:af70de9d453ba8286336bfbaeee552ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18711b9ba7d59183efc69f0948a4d245"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Scalar , typename Perm , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a18711b9ba7d59183efc69f0948a4d245"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a18711b9ba7d59183efc69f0948a4d245">add</a> (const Right &amp;right, const Scalar factor, const Perm &amp;perm) const</td></tr>
<tr class="memdesc:a18711b9ba7d59183efc69f0948a4d245"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile.">Scale</a> and add this and <code>other</code> to construct a new, permuted tensor.  <a href="class_tiled_array_1_1_tensor.html#a18711b9ba7d59183efc69f0948a4d245">More...</a><br /></td></tr>
<tr class="separator:a18711b9ba7d59183efc69f0948a4d245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa248d8fc5421a3403e9eee7e47fc4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a5aa248d8fc5421a3403e9eee7e47fc4a">add</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> value) const</td></tr>
<tr class="memdesc:a5aa248d8fc5421a3403e9eee7e47fc4a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> a constant to a copy of this tensor.  <a href="class_tiled_array_1_1_tensor.html#a5aa248d8fc5421a3403e9eee7e47fc4a">More...</a><br /></td></tr>
<tr class="separator:a5aa248d8fc5421a3403e9eee7e47fc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f220a7b61e87f4f334e3df7e11f35f7"><td class="memTemplParams" colspan="2">template&lt;typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:a6f220a7b61e87f4f334e3df7e11f35f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a6f220a7b61e87f4f334e3df7e11f35f7">add</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> value, const Perm &amp;perm) const</td></tr>
<tr class="memdesc:a6f220a7b61e87f4f334e3df7e11f35f7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> a constant to a permuted copy of this tensor.  <a href="class_tiled_array_1_1_tensor.html#a6f220a7b61e87f4f334e3df7e11f35f7">More...</a><br /></td></tr>
<tr class="separator:a6f220a7b61e87f4f334e3df7e11f35f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dfff2aa620117307ba085091693a768"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a3dfff2aa620117307ba085091693a768"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a3dfff2aa620117307ba085091693a768">add_to</a> (const Right &amp;right)</td></tr>
<tr class="memdesc:a3dfff2aa620117307ba085091693a768"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> <code>other</code> to this tensor.  <a href="class_tiled_array_1_1_tensor.html#a3dfff2aa620117307ba085091693a768">More...</a><br /></td></tr>
<tr class="separator:a3dfff2aa620117307ba085091693a768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c2a4263360a58dbaba16cb434e2794"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a91c2a4263360a58dbaba16cb434e2794"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a91c2a4263360a58dbaba16cb434e2794">add_to</a> (const Right &amp;right, const Scalar factor)</td></tr>
<tr class="memdesc:a91c2a4263360a58dbaba16cb434e2794"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> <code>other</code> to this tensor, and scale the result.  <a href="class_tiled_array_1_1_tensor.html#a91c2a4263360a58dbaba16cb434e2794">More...</a><br /></td></tr>
<tr class="separator:a91c2a4263360a58dbaba16cb434e2794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad959a4848795f8352fd9dfd25631948a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ad959a4848795f8352fd9dfd25631948a">add_to</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> value)</td></tr>
<tr class="memdesc:ad959a4848795f8352fd9dfd25631948a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> a constant to this tensor.  <a href="class_tiled_array_1_1_tensor.html#ad959a4848795f8352fd9dfd25631948a">More...</a><br /></td></tr>
<tr class="separator:ad959a4848795f8352fd9dfd25631948a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78564b48b7777a611ab711489b54849e"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a78564b48b7777a611ab711489b54849e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a78564b48b7777a611ab711489b54849e">subt</a> (const Right &amp;right) const</td></tr>
<tr class="memdesc:a78564b48b7777a611ab711489b54849e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract <code>right</code> from this and return the result.  <a href="class_tiled_array_1_1_tensor.html#a78564b48b7777a611ab711489b54849e">More...</a><br /></td></tr>
<tr class="separator:a78564b48b7777a611ab711489b54849e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc6d00597df4d0f48d92b46ec37679e"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Perm , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a4bc6d00597df4d0f48d92b46ec37679e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a4bc6d00597df4d0f48d92b46ec37679e">subt</a> (const Right &amp;right, const Perm &amp;perm) const</td></tr>
<tr class="memdesc:a4bc6d00597df4d0f48d92b46ec37679e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract <code>right</code> from this and return the result permuted by <code>perm</code>.  <a href="class_tiled_array_1_1_tensor.html#a4bc6d00597df4d0f48d92b46ec37679e">More...</a><br /></td></tr>
<tr class="separator:a4bc6d00597df4d0f48d92b46ec37679e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e08d5ee93b4007248ae0ae45159471"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:af5e08d5ee93b4007248ae0ae45159471"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#af5e08d5ee93b4007248ae0ae45159471">subt</a> (const Right &amp;right, const Scalar factor) const</td></tr>
<tr class="separator:af5e08d5ee93b4007248ae0ae45159471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0152022f08ae620245967e5b25bf18d9"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Scalar , typename Perm , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a0152022f08ae620245967e5b25bf18d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a0152022f08ae620245967e5b25bf18d9">subt</a> (const Right &amp;right, const Scalar factor, const Perm &amp;perm) const</td></tr>
<tr class="separator:a0152022f08ae620245967e5b25bf18d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafd98999ba0678b42e4a8f1312a4252"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#adafd98999ba0678b42e4a8f1312a4252">subt</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> value) const</td></tr>
<tr class="memdesc:adafd98999ba0678b42e4a8f1312a4252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a constant from a copy of this tensor.  <a href="class_tiled_array_1_1_tensor.html#adafd98999ba0678b42e4a8f1312a4252">More...</a><br /></td></tr>
<tr class="separator:adafd98999ba0678b42e4a8f1312a4252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b8e9ed97e9644d14924722d8bdd49d"><td class="memTemplParams" colspan="2">template&lt;typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:ab4b8e9ed97e9644d14924722d8bdd49d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ab4b8e9ed97e9644d14924722d8bdd49d">subt</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> value, const Perm &amp;perm) const</td></tr>
<tr class="memdesc:ab4b8e9ed97e9644d14924722d8bdd49d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a constant from a permuted copy of this tensor.  <a href="class_tiled_array_1_1_tensor.html#ab4b8e9ed97e9644d14924722d8bdd49d">More...</a><br /></td></tr>
<tr class="separator:ab4b8e9ed97e9644d14924722d8bdd49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6732b912c2ce09fcf078d814f0ca8cb9"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a6732b912c2ce09fcf078d814f0ca8cb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a6732b912c2ce09fcf078d814f0ca8cb9">subt_to</a> (const Right &amp;right)</td></tr>
<tr class="memdesc:a6732b912c2ce09fcf078d814f0ca8cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract <code>right</code> from this tensor.  <a href="class_tiled_array_1_1_tensor.html#a6732b912c2ce09fcf078d814f0ca8cb9">More...</a><br /></td></tr>
<tr class="separator:a6732b912c2ce09fcf078d814f0ca8cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a421cd397418787307aac0d453a3d7"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:af9a421cd397418787307aac0d453a3d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#af9a421cd397418787307aac0d453a3d7">subt_to</a> (const Right &amp;right, const Scalar factor)</td></tr>
<tr class="memdesc:af9a421cd397418787307aac0d453a3d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract <code>right</code> from and scale this tensor.  <a href="class_tiled_array_1_1_tensor.html#af9a421cd397418787307aac0d453a3d7">More...</a><br /></td></tr>
<tr class="separator:af9a421cd397418787307aac0d453a3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e44d414e05fe2fe09648ad9856ade68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a8e44d414e05fe2fe09648ad9856ade68">subt_to</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> value)</td></tr>
<tr class="memdesc:a8e44d414e05fe2fe09648ad9856ade68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a constant from this tensor.  <a href="class_tiled_array_1_1_tensor.html#a8e44d414e05fe2fe09648ad9856ade68">More...</a><br /></td></tr>
<tr class="separator:a8e44d414e05fe2fe09648ad9856ade68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c8926e73667ca0d495d17084d1ddf0"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:af6c8926e73667ca0d495d17084d1ddf0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#af6c8926e73667ca0d495d17084d1ddf0">mult</a> (const Right &amp;right) const</td></tr>
<tr class="memdesc:af6c8926e73667ca0d495d17084d1ddf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply this by <code>right</code> to create a new tensor.  <a href="class_tiled_array_1_1_tensor.html#af6c8926e73667ca0d495d17084d1ddf0">More...</a><br /></td></tr>
<tr class="separator:af6c8926e73667ca0d495d17084d1ddf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfd1dabf6aaf4a91a5224d0f671e572"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Perm , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:afbfd1dabf6aaf4a91a5224d0f671e572"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#afbfd1dabf6aaf4a91a5224d0f671e572">mult</a> (const Right &amp;right, const Perm &amp;perm) const</td></tr>
<tr class="memdesc:afbfd1dabf6aaf4a91a5224d0f671e572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply this by <code>right</code> to create a new, permuted tensor.  <a href="class_tiled_array_1_1_tensor.html#afbfd1dabf6aaf4a91a5224d0f671e572">More...</a><br /></td></tr>
<tr class="separator:afbfd1dabf6aaf4a91a5224d0f671e572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aec85b9b6e42edf0f8dbe76dcf3cdb9"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a5aec85b9b6e42edf0f8dbe76dcf3cdb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a5aec85b9b6e42edf0f8dbe76dcf3cdb9">mult</a> (const Right &amp;right, const Scalar factor) const</td></tr>
<tr class="memdesc:a5aec85b9b6e42edf0f8dbe76dcf3cdb9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile.">Scale</a> and multiply this by <code>right</code> to create a new tensor.  <a href="class_tiled_array_1_1_tensor.html#a5aec85b9b6e42edf0f8dbe76dcf3cdb9">More...</a><br /></td></tr>
<tr class="separator:a5aec85b9b6e42edf0f8dbe76dcf3cdb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddf077ade58420b77b72284ca05cd1d"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Scalar , typename Perm , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a2ddf077ade58420b77b72284ca05cd1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a2ddf077ade58420b77b72284ca05cd1d">mult</a> (const Right &amp;right, const Scalar factor, const Perm &amp;perm) const</td></tr>
<tr class="memdesc:a2ddf077ade58420b77b72284ca05cd1d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile.">Scale</a> and multiply this by <code>right</code> to create a new, permuted tensor.  <a href="class_tiled_array_1_1_tensor.html#a2ddf077ade58420b77b72284ca05cd1d">More...</a><br /></td></tr>
<tr class="separator:a2ddf077ade58420b77b72284ca05cd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdd5ac100129cb2858243e3d6e301d1"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aebdd5ac100129cb2858243e3d6e301d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#aebdd5ac100129cb2858243e3d6e301d1">mult_to</a> (const Right &amp;right)</td></tr>
<tr class="memdesc:aebdd5ac100129cb2858243e3d6e301d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply this tensor by <code>right</code>.  <a href="class_tiled_array_1_1_tensor.html#aebdd5ac100129cb2858243e3d6e301d1">More...</a><br /></td></tr>
<tr class="separator:aebdd5ac100129cb2858243e3d6e301d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18aa389491689d55c015492e5b2f139e"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a18aa389491689d55c015492e5b2f139e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a18aa389491689d55c015492e5b2f139e">mult_to</a> (const Right &amp;right, const Scalar factor)</td></tr>
<tr class="memdesc:a18aa389491689d55c015492e5b2f139e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile.">Scale</a> and multiply this tensor by <code>right</code>.  <a href="class_tiled_array_1_1_tensor.html#a18aa389491689d55c015492e5b2f139e">More...</a><br /></td></tr>
<tr class="separator:a18aa389491689d55c015492e5b2f139e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90085facd751fa8fd4eff4aa4b1d73ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a90085facd751fa8fd4eff4aa4b1d73ef">neg</a> () const</td></tr>
<tr class="memdesc:a90085facd751fa8fd4eff4aa4b1d73ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a negated copy of this tensor.  <a href="class_tiled_array_1_1_tensor.html#a90085facd751fa8fd4eff4aa4b1d73ef">More...</a><br /></td></tr>
<tr class="separator:a90085facd751fa8fd4eff4aa4b1d73ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09dec24fc584b7fbd1ec62df6e6e4941"><td class="memTemplParams" colspan="2">template&lt;typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:a09dec24fc584b7fbd1ec62df6e6e4941"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a09dec24fc584b7fbd1ec62df6e6e4941">neg</a> (const Perm &amp;perm) const</td></tr>
<tr class="memdesc:a09dec24fc584b7fbd1ec62df6e6e4941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a negated and permuted copy of this tensor.  <a href="class_tiled_array_1_1_tensor.html#a09dec24fc584b7fbd1ec62df6e6e4941">More...</a><br /></td></tr>
<tr class="separator:a09dec24fc584b7fbd1ec62df6e6e4941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f298b826efdc604b419d2da13d4a862"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a0f298b826efdc604b419d2da13d4a862">neg_to</a> ()</td></tr>
<tr class="memdesc:a0f298b826efdc604b419d2da13d4a862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate elements of this tensor.  <a href="class_tiled_array_1_1_tensor.html#a0f298b826efdc604b419d2da13d4a862">More...</a><br /></td></tr>
<tr class="separator:a0f298b826efdc604b419d2da13d4a862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bda38f32136cd4fea2d438e13ca7ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a78bda38f32136cd4fea2d438e13ca7ab">conj</a> () const</td></tr>
<tr class="memdesc:a78bda38f32136cd4fea2d438e13ca7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated copy of this tensor.  <a href="class_tiled_array_1_1_tensor.html#a78bda38f32136cd4fea2d438e13ca7ab">More...</a><br /></td></tr>
<tr class="separator:a78bda38f32136cd4fea2d438e13ca7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac603273ec73a837ae049660cb7b3c539"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ac603273ec73a837ae049660cb7b3c539"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ac603273ec73a837ae049660cb7b3c539">conj</a> (const Scalar factor) const</td></tr>
<tr class="memdesc:ac603273ec73a837ae049660cb7b3c539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated and scaled copy of this tensor.  <a href="class_tiled_array_1_1_tensor.html#ac603273ec73a837ae049660cb7b3c539">More...</a><br /></td></tr>
<tr class="separator:ac603273ec73a837ae049660cb7b3c539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf795bd542f5f1c19779354487a20f9"><td class="memTemplParams" colspan="2">template&lt;typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </td></tr>
<tr class="memitem:a9cf795bd542f5f1c19779354487a20f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a9cf795bd542f5f1c19779354487a20f9">conj</a> (const Perm &amp;perm) const</td></tr>
<tr class="memdesc:a9cf795bd542f5f1c19779354487a20f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated and permuted copy of this tensor.  <a href="class_tiled_array_1_1_tensor.html#a9cf795bd542f5f1c19779354487a20f9">More...</a><br /></td></tr>
<tr class="separator:a9cf795bd542f5f1c19779354487a20f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9838508c8bafa4402d54e9714cd671b7"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Perm , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a9838508c8bafa4402d54e9714cd671b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a9838508c8bafa4402d54e9714cd671b7">conj</a> (const Scalar factor, const Perm &amp;perm) const</td></tr>
<tr class="memdesc:a9838508c8bafa4402d54e9714cd671b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated, scaled, and permuted copy of this tensor.  <a href="class_tiled_array_1_1_tensor.html#a9838508c8bafa4402d54e9714cd671b7">More...</a><br /></td></tr>
<tr class="separator:a9838508c8bafa4402d54e9714cd671b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ada2b7db72107f273a04394bdccac5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#af3ada2b7db72107f273a04394bdccac5">conj_to</a> ()</td></tr>
<tr class="memdesc:af3ada2b7db72107f273a04394bdccac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex conjugate this tensor.  <a href="class_tiled_array_1_1_tensor.html#af3ada2b7db72107f273a04394bdccac5">More...</a><br /></td></tr>
<tr class="separator:af3ada2b7db72107f273a04394bdccac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184678a6a02973c2a2de3ee08354855e"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a184678a6a02973c2a2de3ee08354855e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a184678a6a02973c2a2de3ee08354855e">conj_to</a> (const Scalar factor)</td></tr>
<tr class="memdesc:a184678a6a02973c2a2de3ee08354855e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex conjugate and scale this tensor.  <a href="class_tiled_array_1_1_tensor.html#a184678a6a02973c2a2de3ee08354855e">More...</a><br /></td></tr>
<tr class="separator:a184678a6a02973c2a2de3ee08354855e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91166d3998a0f1ea70bd76ea3a4fcab"><td class="memTemplParams" colspan="2">template&lt;typename U , typename AU , typename V &gt; </td></tr>
<tr class="memitem:ae91166d3998a0f1ea70bd76ea3a4fcab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ae91166d3998a0f1ea70bd76ea3a4fcab">gemm</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; U, AU &gt; &amp;other, const V factor, const <a class="el" href="class_tiled_array_1_1math_1_1_gemm_helper.html">math::GemmHelper</a> &amp;gemm_helper) const</td></tr>
<tr class="memdesc:ae91166d3998a0f1ea70bd76ea3a4fcab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract this tensor with <code>other</code>.  <a href="class_tiled_array_1_1_tensor.html#ae91166d3998a0f1ea70bd76ea3a4fcab">More...</a><br /></td></tr>
<tr class="separator:ae91166d3998a0f1ea70bd76ea3a4fcab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12cb6d7375f20c89f8a42327efe2fa5"><td class="memTemplParams" colspan="2">template&lt;typename U , typename AU , typename V , typename AV , typename W &gt; </td></tr>
<tr class="memitem:af12cb6d7375f20c89f8a42327efe2fa5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#af12cb6d7375f20c89f8a42327efe2fa5">gemm</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; U, AU &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; V, AV &gt; &amp;right, const W factor, const <a class="el" href="class_tiled_array_1_1math_1_1_gemm_helper.html">math::GemmHelper</a> &amp;gemm_helper)</td></tr>
<tr class="memdesc:af12cb6d7375f20c89f8a42327efe2fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract two tensors and accumulate the scaled result to this tensor.  <a href="class_tiled_array_1_1_tensor.html#af12cb6d7375f20c89f8a42327efe2fa5">More...</a><br /></td></tr>
<tr class="separator:af12cb6d7375f20c89f8a42327efe2fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48166eac5917c1bd91ad06edf149355a"><td class="memTemplParams" colspan="2">template&lt;typename U , typename AU , typename V , typename AV , typename ElementMultiplyAddOp , typename  = std::enable_if_t&lt;std::is_invocable_r_v&lt;                void, std::remove_reference_t&lt;ElementMultiplyAddOp&gt;,                value_type&amp;, const U&amp;, const V&amp;&gt;&gt;&gt; </td></tr>
<tr class="memitem:a48166eac5917c1bd91ad06edf149355a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a48166eac5917c1bd91ad06edf149355a">gemm</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; U, AU &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; V, AV &gt; &amp;right, const <a class="el" href="class_tiled_array_1_1math_1_1_gemm_helper.html">math::GemmHelper</a> &amp;gemm_helper, ElementMultiplyAddOp &amp;&amp;elem_muladd_op)</td></tr>
<tr class="separator:a48166eac5917c1bd91ad06edf149355a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9f9ab3a09d88f89ac402fcf656e056"><td class="memTemplParams" colspan="2">template&lt;typename TileType  = Tensor_, typename  = detail::enable_if_trace_is_defined_t&lt;TileType&gt;&gt; </td></tr>
<tr class="memitem:a7e9f9ab3a09d88f89ac402fcf656e056"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a7e9f9ab3a09d88f89ac402fcf656e056">trace</a> () const</td></tr>
<tr class="memdesc:a7e9f9ab3a09d88f89ac402fcf656e056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalized tensor trace.  <a href="class_tiled_array_1_1_tensor.html#a7e9f9ab3a09d88f89ac402fcf656e056">More...</a><br /></td></tr>
<tr class="separator:a7e9f9ab3a09d88f89ac402fcf656e056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e2825494e7578e27becf11d2a6b794"><td class="memTemplParams" colspan="2">template&lt;typename ReduceOp , typename JoinOp , typename Scalar &gt; </td></tr>
<tr class="memitem:ac7e2825494e7578e27becf11d2a6b794"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ac7e2825494e7578e27becf11d2a6b794">reduce</a> (ReduceOp &amp;&amp;reduce_op, JoinOp &amp;&amp;join_op, Scalar identity) const</td></tr>
<tr class="memdesc:ac7e2825494e7578e27becf11d2a6b794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary reduction operation.  <a href="class_tiled_array_1_1_tensor.html#ac7e2825494e7578e27becf11d2a6b794">More...</a><br /></td></tr>
<tr class="separator:ac7e2825494e7578e27becf11d2a6b794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130321a40b1c94254c839758689e6eba"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename ReduceOp , typename JoinOp , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a130321a40b1c94254c839758689e6eba"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a130321a40b1c94254c839758689e6eba">reduce</a> (const Right &amp;other, ReduceOp &amp;&amp;reduce_op, JoinOp &amp;&amp;join_op, Scalar identity) const</td></tr>
<tr class="memdesc:a130321a40b1c94254c839758689e6eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary reduction operation.  <a href="class_tiled_array_1_1_tensor.html#a130321a40b1c94254c839758689e6eba">More...</a><br /></td></tr>
<tr class="separator:a130321a40b1c94254c839758689e6eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31122a03a46628005e60ed0ad1494f14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a31122a03a46628005e60ed0ad1494f14">sum</a> () const</td></tr>
<tr class="memdesc:a31122a03a46628005e60ed0ad1494f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of elements.  <a href="class_tiled_array_1_1_tensor.html#a31122a03a46628005e60ed0ad1494f14">More...</a><br /></td></tr>
<tr class="separator:a31122a03a46628005e60ed0ad1494f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f4315e4e0cdef9beb147ce929c5db7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#af5f4315e4e0cdef9beb147ce929c5db7">product</a> () const</td></tr>
<tr class="memdesc:af5f4315e4e0cdef9beb147ce929c5db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Product of elements.  <a href="class_tiled_array_1_1_tensor.html#af5f4315e4e0cdef9beb147ce929c5db7">More...</a><br /></td></tr>
<tr class="separator:af5f4315e4e0cdef9beb147ce929c5db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47757d8cd5015280a09ee20f453c86c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a9a3ff935ffdd12ded18a1041a0a18faf">scalar_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a47757d8cd5015280a09ee20f453c86c2">squared_norm</a> () const</td></tr>
<tr class="memdesc:a47757d8cd5015280a09ee20f453c86c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square of vector 2-norm.  <a href="class_tiled_array_1_1_tensor.html#a47757d8cd5015280a09ee20f453c86c2">More...</a><br /></td></tr>
<tr class="separator:a47757d8cd5015280a09ee20f453c86c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724f7712da193d3b71d6f5d2f00ae4b3"><td class="memTemplParams" colspan="2">template&lt;typename ResultType  = scalar_type&gt; </td></tr>
<tr class="memitem:a724f7712da193d3b71d6f5d2f00ae4b3"><td class="memTemplItemLeft" align="right" valign="top">ResultType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a724f7712da193d3b71d6f5d2f00ae4b3">norm</a> () const</td></tr>
<tr class="memdesc:a724f7712da193d3b71d6f5d2f00ae4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector 2-norm.  <a href="class_tiled_array_1_1_tensor.html#a724f7712da193d3b71d6f5d2f00ae4b3">More...</a><br /></td></tr>
<tr class="separator:a724f7712da193d3b71d6f5d2f00ae4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a22a994aafd87df8d012ddce92bad3a"><td class="memTemplParams" colspan="2">template&lt;typename Numeric  = numeric_type&gt; </td></tr>
<tr class="memitem:a8a22a994aafd87df8d012ddce92bad3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a8a22a994aafd87df8d012ddce92bad3a">min</a> (typename std::enable_if&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1is__strictly__ordered.html">detail::is_strictly_ordered</a>&lt; Numeric &gt;::value &gt;::type *=nullptr) const</td></tr>
<tr class="memdesc:a8a22a994aafd87df8d012ddce92bad3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum element.  <a href="class_tiled_array_1_1_tensor.html#a8a22a994aafd87df8d012ddce92bad3a">More...</a><br /></td></tr>
<tr class="separator:a8a22a994aafd87df8d012ddce92bad3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f492a7c588bc82c2fafc45519bdb6b"><td class="memTemplParams" colspan="2">template&lt;typename Numeric  = numeric_type&gt; </td></tr>
<tr class="memitem:a92f492a7c588bc82c2fafc45519bdb6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a92f492a7c588bc82c2fafc45519bdb6b">max</a> (typename std::enable_if&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1is__strictly__ordered.html">detail::is_strictly_ordered</a>&lt; Numeric &gt;::value &gt;::type *=nullptr) const</td></tr>
<tr class="memdesc:a92f492a7c588bc82c2fafc45519bdb6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum element.  <a href="class_tiled_array_1_1_tensor.html#a92f492a7c588bc82c2fafc45519bdb6b">More...</a><br /></td></tr>
<tr class="separator:a92f492a7c588bc82c2fafc45519bdb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6914ca99f535592a4477df637511b58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a9a3ff935ffdd12ded18a1041a0a18faf">scalar_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ae6914ca99f535592a4477df637511b58">abs_min</a> () const</td></tr>
<tr class="memdesc:ae6914ca99f535592a4477df637511b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute minimum element.  <a href="class_tiled_array_1_1_tensor.html#ae6914ca99f535592a4477df637511b58">More...</a><br /></td></tr>
<tr class="separator:ae6914ca99f535592a4477df637511b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7a6a051f5d87261a8b71a078d68624"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a9a3ff935ffdd12ded18a1041a0a18faf">scalar_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a5f7a6a051f5d87261a8b71a078d68624">abs_max</a> () const</td></tr>
<tr class="memdesc:a5f7a6a051f5d87261a8b71a078d68624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute maximum element.  <a href="class_tiled_array_1_1_tensor.html#a5f7a6a051f5d87261a8b71a078d68624">More...</a><br /></td></tr>
<tr class="separator:a5f7a6a051f5d87261a8b71a078d68624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d2d35f79fdf07d7c6878c89d8a9288"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a33d2d35f79fdf07d7c6878c89d8a9288"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a33d2d35f79fdf07d7c6878c89d8a9288">dot</a> (const Right &amp;other) const</td></tr>
<tr class="memdesc:a33d2d35f79fdf07d7c6878c89d8a9288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector dot (not inner!) product.  <a href="class_tiled_array_1_1_tensor.html#a33d2d35f79fdf07d7c6878c89d8a9288">More...</a><br /></td></tr>
<tr class="separator:a33d2d35f79fdf07d7c6878c89d8a9288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82161c441a1caca56cb1a894c6ebc7b0"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a82161c441a1caca56cb1a894c6ebc7b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a82161c441a1caca56cb1a894c6ebc7b0">inner_product</a> (const Right &amp;other) const</td></tr>
<tr class="memdesc:a82161c441a1caca56cb1a894c6ebc7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector inner product.  <a href="class_tiled_array_1_1_tensor.html#a82161c441a1caca56cb1a894c6ebc7b0">More...</a><br /></td></tr>
<tr class="separator:a82161c441a1caca56cb1a894c6ebc7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af8b56ffb1b81b392017203932ee03e6f"><td class="memTemplParams" colspan="2">template&lt;typename Index1 , typename Index2 , typename  = std::enable_if_t&lt;detail::is_integral_range_v&lt;Index1&gt; &amp;&amp;                                        detail::is_integral_range_v&lt;Index2&gt;&gt;&gt; </td></tr>
<tr class="memitem:af8b56ffb1b81b392017203932ee03e6f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#af8b56ffb1b81b392017203932ee03e6f">block</a> (const Index1 &amp;lower_bound, const Index2 &amp;upper_bound)</td></tr>
<tr class="memdesc:af8b56ffb1b81b392017203932ee03e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a view of the block defined by <code>lower_bound</code> and <code>upper_bound</code>.  <a href="class_tiled_array_1_1_tensor.html#af8b56ffb1b81b392017203932ee03e6f">More...</a><br /></td></tr>
<tr class="separator:af8b56ffb1b81b392017203932ee03e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9302ebcbac69ec35bc0f4524d7cd381"><td class="memTemplParams" colspan="2">template&lt;typename Index1 , typename Index2 , typename  = std::enable_if_t&lt;detail::is_integral_range_v&lt;Index1&gt; &amp;&amp;                                        detail::is_integral_range_v&lt;Index2&gt;&gt;&gt; </td></tr>
<tr class="memitem:ab9302ebcbac69ec35bc0f4524d7cd381"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; const T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ab9302ebcbac69ec35bc0f4524d7cd381">block</a> (const Index1 &amp;lower_bound, const Index2 &amp;upper_bound) const</td></tr>
<tr class="memdesc:ab9302ebcbac69ec35bc0f4524d7cd381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a view of the block defined by <code>lower_bound</code> and <code>upper_bound</code>.  <a href="class_tiled_array_1_1_tensor.html#ab9302ebcbac69ec35bc0f4524d7cd381">More...</a><br /></td></tr>
<tr class="separator:ab9302ebcbac69ec35bc0f4524d7cd381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a37519a7ff1e4165a008bc8b003f19809"><td class="memTemplParams" colspan="2">template&lt;typename Index1 , typename Index2 , typename  = std::enable_if_t&lt;std::is_integral_v&lt;Index1&gt; &amp;&amp;                                        std::is_integral_v&lt;Index2&gt;&gt;&gt; </td></tr>
<tr class="memitem:a37519a7ff1e4165a008bc8b003f19809"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a37519a7ff1e4165a008bc8b003f19809">block</a> (const std::initializer_list&lt; Index1 &gt; &amp;lower_bound, const std::initializer_list&lt; Index2 &gt; &amp;upper_bound)</td></tr>
<tr class="memdesc:a37519a7ff1e4165a008bc8b003f19809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a view of the block defined by <code>lower_bound</code> and <code>upper_bound</code>.  <a href="class_tiled_array_1_1_tensor.html#a37519a7ff1e4165a008bc8b003f19809">More...</a><br /></td></tr>
<tr class="separator:a37519a7ff1e4165a008bc8b003f19809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5729f9fe64ed5c2d953ffcfad00793a"><td class="memTemplParams" colspan="2">template&lt;typename Index1 , typename Index2 , typename  = std::enable_if_t&lt;std::is_integral_v&lt;Index1&gt; &amp;&amp;                                        std::is_integral_v&lt;Index2&gt;&gt;&gt; </td></tr>
<tr class="memitem:ad5729f9fe64ed5c2d953ffcfad00793a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; const T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ad5729f9fe64ed5c2d953ffcfad00793a">block</a> (const std::initializer_list&lt; Index1 &gt; &amp;lower_bound, const std::initializer_list&lt; Index2 &gt; &amp;upper_bound) const</td></tr>
<tr class="memdesc:ad5729f9fe64ed5c2d953ffcfad00793a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a view of the block defined by <code>lower_bound</code> and <code>upper_bound</code>.  <a href="class_tiled_array_1_1_tensor.html#ad5729f9fe64ed5c2d953ffcfad00793a">More...</a><br /></td></tr>
<tr class="separator:ad5729f9fe64ed5c2d953ffcfad00793a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a20c21c3879e579fc4c67836498b4cbd6"><td class="memTemplParams" colspan="2">template&lt;typename PairRange , typename  = std::enable_if_t&lt;detail::is_gpair_range_v&lt;PairRange&gt;&gt;&gt; </td></tr>
<tr class="memitem:a20c21c3879e579fc4c67836498b4cbd6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; const T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a20c21c3879e579fc4c67836498b4cbd6">block</a> (const PairRange &amp;bounds) const</td></tr>
<tr class="memdesc:a20c21c3879e579fc4c67836498b4cbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a view of the block defined by its <code>bounds</code> .  <a href="class_tiled_array_1_1_tensor.html#a20c21c3879e579fc4c67836498b4cbd6">More...</a><br /></td></tr>
<tr class="separator:a20c21c3879e579fc4c67836498b4cbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828903d60bcf6fe9b6948b982b048e7d"><td class="memTemplParams" colspan="2">template&lt;typename PairRange , typename  = std::enable_if_t&lt;detail::is_gpair_range_v&lt;PairRange&gt;&gt;&gt; </td></tr>
<tr class="memitem:a828903d60bcf6fe9b6948b982b048e7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a828903d60bcf6fe9b6948b982b048e7d">block</a> (const PairRange &amp;bounds)</td></tr>
<tr class="memdesc:a828903d60bcf6fe9b6948b982b048e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a view of the block defined by its <code>bounds</code> .  <a href="class_tiled_array_1_1_tensor.html#a828903d60bcf6fe9b6948b982b048e7d">More...</a><br /></td></tr>
<tr class="separator:a828903d60bcf6fe9b6948b982b048e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a067947c86081dbd78cfdabe56c547fd3"><td class="memTemplParams" colspan="2">template&lt;typename Index , typename  = std::enable_if_t&lt;std::is_integral_v&lt;Index&gt;&gt;&gt; </td></tr>
<tr class="memitem:a067947c86081dbd78cfdabe56c547fd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; const T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a067947c86081dbd78cfdabe56c547fd3">block</a> (const std::initializer_list&lt; std::initializer_list&lt; Index &gt;&gt; &amp;bounds) const</td></tr>
<tr class="memdesc:a067947c86081dbd78cfdabe56c547fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a view of the block defined by its <code>bounds</code> .  <a href="class_tiled_array_1_1_tensor.html#a067947c86081dbd78cfdabe56c547fd3">More...</a><br /></td></tr>
<tr class="separator:a067947c86081dbd78cfdabe56c547fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b81f76e5131112b218d4b6153c0f38f"><td class="memTemplParams" colspan="2">template&lt;typename Index , typename  = std::enable_if_t&lt;std::is_integral_v&lt;Index&gt;&gt;&gt; </td></tr>
<tr class="memitem:a9b81f76e5131112b218d4b6153c0f38f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a9b81f76e5131112b218d4b6153c0f38f">block</a> (const std::initializer_list&lt; std::initializer_list&lt; Index &gt;&gt; &amp;bounds)</td></tr>
<tr class="memdesc:a9b81f76e5131112b218d4b6153c0f38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a view of the block defined by its <code>bounds</code> .  <a href="class_tiled_array_1_1_tensor.html#a9b81f76e5131112b218d4b6153c0f38f">More...</a><br /></td></tr>
<tr class="separator:a9b81f76e5131112b218d4b6153c0f38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a99586ecbed993b0a7dc33ca231131d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99586ecbed993b0a7dc33ca231131d15">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef A <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#a99586ecbed993b0a7dc33ca231131d15">allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocator type. </p>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00064">64</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a643a4203b62aa1e370d6995aad071f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643a4203b62aa1e370d6995aad071f40">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_tensor.html#a13b3ca56e0bf2b27a8632d1598c1d526">const_pointer</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#a643a4203b62aa1e370d6995aad071f40">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element const iterator type. </p>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00077">77</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a13b3ca56e0bf2b27a8632d1598c1d526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b3ca56e0bf2b27a8632d1598c1d526">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef allocator_type::const_pointer <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#a13b3ca56e0bf2b27a8632d1598c1d526">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element const pointer type. </p>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00073">73</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a8b80372c9a8886e30106219eca40b66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b80372c9a8886e30106219eca40b66c">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef allocator_type::const_reference <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#a8b80372c9a8886e30106219eca40b66c">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element reference type. </p>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00070">70</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a104deacaf44eb9d0fa97b32c59d53cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a104deacaf44eb9d0fa97b32c59d53cc5">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef allocator_type::difference_type <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#a104deacaf44eb9d0fa97b32c59d53cc5">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Difference type. </p>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00075">75</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a9074d502998bbd5010bdf269aa67c350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9074d502998bbd5010bdf269aa67c350">&#9670;&nbsp;</a></span>index1_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_range.html#a7eef119570cf35f5c554a379edab856a">range_type::index1_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#a9074d502998bbd5010bdf269aa67c350">index1_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1-index type </p>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00060">60</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a7c3a6bcdbeae5dec3343d6ae28df8284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3a6bcdbeae5dec3343d6ae28df8284">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_tensor.html#ace0c51fc37253afe287423fe5971da8c">pointer</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#a7c3a6bcdbeae5dec3343d6ae28df8284">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element iterator type. </p>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00076">76</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="abc2e1a62ce018f90f552510d29fd9ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc2e1a62ce018f90f552510d29fd9ed2">&#9670;&nbsp;</a></span>numeric_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type.html">TiledArray::detail::numeric_type</a>&lt;T&gt;::type <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the numeric type that supports T </p>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00079">79</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ad041efe131da1739c84d97e7808f0044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad041efe131da1739c84d97e7808f0044">&#9670;&nbsp;</a></span>ordinal_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_range.html#a383765e8eefd94a2af57b5b5344e354e">range_type::ordinal_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#ad041efe131da1739c84d97e7808f0044">ordinal_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ordinal type. </p>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00061">61</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ace0c51fc37253afe287423fe5971da8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0c51fc37253afe287423fe5971da8c">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef allocator_type::pointer <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#ace0c51fc37253afe287423fe5971da8c">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element pointer type. </p>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00071">71</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a9a6953592a083f07bc6132a571a9d767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a6953592a083f07bc6132a571a9d767">&#9670;&nbsp;</a></span>range_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_range.html">Range</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> range type. </p>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00059">59</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ac8dc24eca41c8655a8871e838183e24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8dc24eca41c8655a8871e838183e24b">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef allocator_type::reference <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#ac8dc24eca41c8655a8871e838183e24b">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element reference type. </p>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00068">68</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a9a3ff935ffdd12ded18a1041a0a18faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3ff935ffdd12ded18a1041a0a18faf">&#9670;&nbsp;</a></span>scalar_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type.html">TiledArray::detail::scalar_type</a>&lt;T&gt;::type <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#a9a3ff935ffdd12ded18a1041a0a18faf">scalar_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the scalar type that supports T </p>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00081">81</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a034d7cd975f2ed9cbe79adeccb687229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034d7cd975f2ed9cbe79adeccb687229">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_range.html#a383765e8eefd94a2af57b5b5344e354e">range_type::ordinal_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#a034d7cd975f2ed9cbe79adeccb687229">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size type (to meet the container concept) </p>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00063">63</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a5608ebaf867dc02438adf9475a5ed719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5608ebaf867dc02438adf9475a5ed719">&#9670;&nbsp;</a></span>Tensor_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;T, A&gt; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This class type. </p>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00058">58</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ab64c1efaee17c30ac1559f18e1eb0e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64c1efaee17c30ac1559f18e1eb0e88">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef allocator_type::value_type <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#ab64c1efaee17c30ac1559f18e1eb0e88">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array element type. </p>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00066">66</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a52053224a88d9d8478805d7c5f89ec59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52053224a88d9d8478805d7c5f89ec59">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00144">144</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a414d8ebf6c834c5500ca5b5408708f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a414d8ebf6c834c5500ca5b5408708f58">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00145">145</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a437e6fa337043142c4be807cd46bf5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437e6fa337043142c4be807cd46bf5d1">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00146">146</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a709fe578d55e8ee8c1e187d6f1a1ad4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a709fe578d55e8ee8c1e187d6f1a1ad4e">&#9670;&nbsp;</a></span>~Tensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::~<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00147">147</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="aff000b8850b2992ff765eb3f8f116632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff000b8850b2992ff765eb3f8f116632">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct tensor. </p>
<p>Construct a tensor with a range equal to <code>range</code>. The data is uninitialized. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>The range of the tensor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00162">162</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ad06d56e445f36d572109abbafc1a32e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06d56e445f36d572109abbafc1a32e5">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Value , typename std::enable_if&lt; std::is_same&lt; Value, value_type &gt;::value &amp;&amp;detail::is_tensor&lt; Value &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a tensor with a fill value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>An array with the size of of each dimension </td></tr>
    <tr><td class="paramname">value</td><td>The value of the tensor elements </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00175">175</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ad06d56e445f36d572109abbafc1a32e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06d56e445f36d572109abbafc1a32e5">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Value , typename std::enable_if&lt; detail::is_numeric_v&lt; Value &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a tensor with a fill value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>An array with the size of of each dimension </td></tr>
    <tr><td class="paramname">value</td><td>The value of the tensor elements </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00190">190</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a7a04249ef7d49a620988dec54b296f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a04249ef7d49a620988dec54b296f1a">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename InIter , typename std::enable_if&lt; TiledArray::detail::is_input_iterator&lt; InIter &gt;::value &amp;&amp;!std::is_pointer&lt; InIter &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an evaluated tensor. </p>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00200">200</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ad46913eeb18eceebf619a6d73698704a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46913eeb18eceebf619a6d73698704a">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00208">208</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="aeb452aab64792336398f4b52f4f67df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb452aab64792336398f4b52f4f67df7">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>il</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00213">213</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="aa8514a8061acfd51b3551dd42fd54c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8514a8061acfd51b3551dd42fd54c0a">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename std::enable_if&lt; is_tensor&lt; T1 &gt;::value &amp;&amp;!std::is_same&lt; T1, Tensor_ &gt;::value &amp;&amp;!detail::has_conversion_operator_v&lt; T1, Tensor_ &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a copy of a tensor interface object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>A tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tensor to be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this constructor is disabled if <code>T1</code> already has a conversion operator to this type </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00227">227</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a97bb481eb9dc1357f2c8816fc456e3bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97bb481eb9dc1357f2c8816fc456e3bf">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename Perm , typename std::enable_if&lt; is_tensor&lt; T1 &gt;::value &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a permuted tensor copy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>A tensor type </td></tr>
    <tr><td class="paramname">Perm</td><td>A permutation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tensor to be copied </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation that will be applied to the copy </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00244">244</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="af833692ef1ebff1764c2cabbebd1e2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af833692ef1ebff1764c2cabbebd1e2f9">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename Op , typename std::enable_if_t&lt; is_tensor&lt; T1 &gt;::value &amp;&amp;!detail::is_permutation_v&lt; std::decay_t&lt; Op &gt;&gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy and modify the data from <code>other</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>A tensor type </td></tr>
    <tr><td class="paramname">Op</td><td>An element-wise operation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tensor argument </td></tr>
    <tr><td class="paramname">op</td><td>The element-wise operation </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00276">276</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="aeecb683b594553acfcf27fc321723c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeecb683b594553acfcf27fc321723c28">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename Op , typename Perm , typename std::enable_if_t&lt; is_tensor&lt; T1 &gt;::value &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy, modify, and permute the data from <code>other</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>A tensor type </td></tr>
    <tr><td class="paramname">Op</td><td>An element-wise operation type </td></tr>
    <tr><td class="paramname">Perm</td><td>A permutation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tensor argument </td></tr>
    <tr><td class="paramname">op</td><td>The element-wise operation </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00292">292</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a4212439f4e33716dabdf6ecafb626991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4212439f4e33716dabdf6ecafb626991">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename Op , typename std::enable_if&lt; is_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy and modify the data from <code>left</code>, and <code>right</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>A tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>A tensor type </td></tr>
    <tr><td class="paramname">Op</td><td>An element-wise operation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
    <tr><td class="paramname">op</td><td>The element-wise operation </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00321">321</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ae9e0066dc1184e3a5d6d6c7b5b46738a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e0066dc1184e3a5d6d6c7b5b46738a">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename Op , typename Perm , typename std::enable_if&lt; is_tensor&lt; T1, T2 &gt;::value &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy, modify, and permute the data from <code>left</code>, and <code>right</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>A tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>A tensor type </td></tr>
    <tr><td class="paramname">Op</td><td>An element-wise operation type </td></tr>
    <tr><td class="paramname">Perm</td><td>A permutation tile </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
    <tr><td class="paramname">op</td><td>The element-wise operation </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation that will be applied to the arguments </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00340">340</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5f7a6a051f5d87261a8b71a078d68624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7a6a051f5d87261a8b71a078d68624">&#9670;&nbsp;</a></span>abs_max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a9a3ff935ffdd12ded18a1041a0a18faf">scalar_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::abs_max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Absolute maximum element. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum elements of this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l02110">2110</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ae6914ca99f535592a4477df637511b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6914ca99f535592a4477df637511b58">&#9670;&nbsp;</a></span>abs_min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a9a3ff935ffdd12ded18a1041a0a18faf">scalar_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::abs_min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Absolute minimum element. </p>
<dl class="section return"><dt>Returns</dt><dd>The minimum elements of this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l02096">2096</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a5aa248d8fc5421a3403e9eee7e47fc4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa248d8fc5421a3403e9eee7e47fc4a">&#9670;&nbsp;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> a constant to a copy of this tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The constant to be added to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the sum of the elements of <code>this</code> and <code>value</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01195">1195</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a6f220a7b61e87f4f334e3df7e11f35f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f220a7b61e87f4f334e3df7e11f35f7">&#9670;&nbsp;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> a constant to a permuted copy of this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Perm</td><td>A permutation tile </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The constant to be added to this tensor </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the sum of the elements of <code>this</code> and <code>value</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01209">1209</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a259865850e25a60be57add9ffc139ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259865850e25a60be57add9ffc139ee9">&#9670;&nbsp;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> this and <code>other</code> to construct a new tensors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be added to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the sum of the elements of <code>this</code> and <code>other</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01121">1121</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_tiled_array_1_1_tensor_a259865850e25a60be57add9ffc139ee9_icgraph.png" border="0" usemap="#aclass_tiled_array_1_1_tensor_a259865850e25a60be57add9ffc139ee9_icgraph" alt=""/></div>
<map name="class_tiled_array_1_1_tensor_a259865850e25a60be57add9ffc139ee9_icgraph" id="aclass_tiled_array_1_1_tensor_a259865850e25a60be57add9ffc139ee9_icgraph">
<area shape="rect" title="Add this and other to construct a new tensors." alt="" coords="213,13,384,39"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#adafd98999ba0678b42e4a8f1312a4252" title="Subtract a constant from a copy of this tensor." alt="" coords="5,5,165,47"/>
</map>
</div>

</div>
</div>
<a id="abc2f0e1b76bf74c9c06c4fddfdda4529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc2f0e1b76bf74c9c06c4fddfdda4529">&#9670;&nbsp;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Perm , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> this and <code>other</code> to construct a new, permuted tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Perm</td><td>A permutation tile </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be added to this tensor </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the sum of the elements of <code>this</code> and <code>other</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01141">1141</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="af70de9d453ba8286336bfbaeee552ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70de9d453ba8286336bfbaeee552ed1">&#9670;&nbsp;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile.">Scale</a> and add this and <code>other</code> to construct a new tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be added to this tensor </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the sum of the elements of <code>this</code> and <code>other</code>, scaled by <code>factor</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01162">1162</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a18711b9ba7d59183efc69f0948a4d245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18711b9ba7d59183efc69f0948a4d245">&#9670;&nbsp;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Scalar , typename Perm , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile.">Scale</a> and add this and <code>other</code> to construct a new, permuted tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
    <tr><td class="paramname">Perm</td><td>A permutation tile </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be added to this tensor </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the sum of the elements of <code>this</code> and <code>other</code>, scaled by <code>factor</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01182">1182</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ad959a4848795f8352fd9dfd25631948a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad959a4848795f8352fd9dfd25631948a">&#9670;&nbsp;</a></span>add_to() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::add_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> a constant to this tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The constant to be added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01248">1248</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a3dfff2aa620117307ba085091693a768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dfff2aa620117307ba085091693a768">&#9670;&nbsp;</a></span>add_to() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::add_to </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> <code>other</code> to this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be added to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01222">1222</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_tiled_array_1_1_tensor_a3dfff2aa620117307ba085091693a768_icgraph.png" border="0" usemap="#aclass_tiled_array_1_1_tensor_a3dfff2aa620117307ba085091693a768_icgraph" alt=""/></div>
<map name="class_tiled_array_1_1_tensor_a3dfff2aa620117307ba085091693a768_icgraph" id="aclass_tiled_array_1_1_tensor_a3dfff2aa620117307ba085091693a768_icgraph">
<area shape="rect" title="Add other to this tensor." alt="" coords="233,5,372,47"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a8e44d414e05fe2fe09648ad9856ade68" title="Subtract a constant from this tensor." alt="" coords="5,5,185,47"/>
</map>
</div>

</div>
</div>
<a id="a91c2a4263360a58dbaba16cb434e2794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c2a4263360a58dbaba16cb434e2794">&#9670;&nbsp;</a></span>add_to() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::add_to </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation.">Add</a> <code>other</code> to this tensor, and scale the result. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be added to this tensor </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01238">1238</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a6cb2732327b1e80aae0f82e590824642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb2732327b1e80aae0f82e590824642">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a7c3a6bcdbeae5dec3343d6ae28df8284">iterator</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator factory. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first data element </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00590">590</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="aca1674e15d020be9f9087d935589a849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1674e15d020be9f9087d935589a849">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a643a4203b62aa1e370d6995aad071f40">const_iterator</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator factory. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first data element </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00585">585</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a622a65abf1a4fee5b1239c248006802e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622a65abf1a4fee5b1239c248006802e">&#9670;&nbsp;</a></span>binary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Op , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use a binary, element wise operation to construct a new tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Op</td><td>The binary operation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The right-hand argument in the binary operation </td></tr>
    <tr><td class="paramname">op</td><td>The binary, element-wise operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> of the new tensor is equal to <code>op(*this[i],other[i])</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00950">950</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_tiled_array_1_1_tensor_a622a65abf1a4fee5b1239c248006802e_icgraph.png" border="0" usemap="#aclass_tiled_array_1_1_tensor_a622a65abf1a4fee5b1239c248006802e_icgraph" alt=""/></div>
<map name="class_tiled_array_1_1_tensor_a622a65abf1a4fee5b1239c248006802e_icgraph" id="aclass_tiled_array_1_1_tensor_a622a65abf1a4fee5b1239c248006802e_icgraph">
<area shape="rect" title="Use a binary, element wise operation to construct a new tensor." alt="" coords="265,156,404,197"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a259865850e25a60be57add9ffc139ee9" title="Add this and other to construct a new tensors." alt="" coords="33,5,189,47"/>
<area shape="rect" href="class_tiled_array_1_1_sparse_shape.html#a936d0bdbef824d1c65fbc532cbd72671" title="Add shapes." alt="" coords="5,71,217,98"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a83ef14e0a09d55fee40c40fbf5ac58b2" title="Use a binary, element wise operation to construct a new, permuted tensor." alt="" coords="25,123,198,164"/>
<area shape="rect" href="class_tiled_array_1_1_sparse_shape.html#ae72b7cee1a27dbef2ad7af6f7b235e5c" title="Compute union of two shapes." alt="" coords="21,188,201,229"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#af6c8926e73667ca0d495d17084d1ddf0" title="Multiply this by right to create a new tensor." alt="" coords="30,253,193,295"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a78564b48b7777a611ab711489b54849e" title="Subtract right from this and return the result." alt="" coords="31,319,191,360"/>
</map>
</div>

</div>
</div>
<a id="a83ef14e0a09d55fee40c40fbf5ac58b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ef14e0a09d55fee40c40fbf5ac58b2">&#9670;&nbsp;</a></span>binary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Op , typename Perm , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use a binary, element wise operation to construct a new, permuted tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Op</td><td>The binary operation type </td></tr>
    <tr><td class="paramname">Perm</td><td>A permutation tile </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The right-hand argument in the binary operation </td></tr>
    <tr><td class="paramname">op</td><td>The binary, element-wise operation </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> of the new tensor is equal to <code>op(*this[i],other[i])</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00968">968</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="af8b56ffb1b81b392017203932ee03e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b56ffb1b81b392017203932ee03e6f">&#9670;&nbsp;</a></span>block() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Index1 , typename Index2 , typename  = std::enable_if_t&lt;detail::is_integral_range_v&lt;Index1&gt; &amp;&amp;                                        detail::is_integral_range_v&lt;Index2&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt;T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a>&gt; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const Index1 &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index2 &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a view of the block defined by <code>lower_bound</code> and <code>upper_bound</code>. </p>
<p>Examples of using this: </p><div class="fragment"><div class="line">std::vector&lt;size_t&gt; lobounds = {0, 1, 2};</div>
<div class="line">std::vector&lt;size_t&gt; upbounds = {4, 6, 8};</div>
<div class="line"><span class="keyword">auto</span> tview = t.block(lobounds, upbounds);</div>
<div class="line">assert(tview.range().includes(lobounds));</div>
<div class="line">assert(tview(lobounds) == t(lobounds));</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index1</td><td>An integral range type </td></tr>
    <tr><td class="paramname">Index2</td><td>An integral range type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lower_bound</td><td>The lower bound </td></tr>
    <tr><td class="paramname">upper_bound</td><td>The upper bound </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a {const,mutable} view of the block defined by <code>lower_bound</code> and <code>upper_bound</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the size of <code>lower_bound</code> is not equal to that of <code>upper_bound</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When <code>lower_bound[i] &gt;= upper_bound[i]</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00704">704</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_tiled_array_1_1_tensor_af8b56ffb1b81b392017203932ee03e6f_icgraph.png" border="0" usemap="#aclass_tiled_array_1_1_tensor_af8b56ffb1b81b392017203932ee03e6f_icgraph" alt=""/></div>
<map name="class_tiled_array_1_1_tensor_af8b56ffb1b81b392017203932ee03e6f_icgraph" id="aclass_tiled_array_1_1_tensor_af8b56ffb1b81b392017203932ee03e6f_icgraph">
<area shape="rect" title="Constructs a view of the block defined by lower_bound and upper_bound." alt="" coords="233,5,372,47"/>
<area shape="rect" href="class_tiled_array_1_1_sparse_shape.html#afc63decd7b2f8c09274229cd0d69cf84" title="Creates a copy of this with a sub&#45;block updated with contents of another shape." alt="" coords="5,5,185,47"/>
</map>
</div>

</div>
</div>
<a id="ab9302ebcbac69ec35bc0f4524d7cd381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9302ebcbac69ec35bc0f4524d7cd381">&#9670;&nbsp;</a></span>block() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Index1 , typename Index2 , typename  = std::enable_if_t&lt;detail::is_integral_range_v&lt;Index1&gt; &amp;&amp;                                        detail::is_integral_range_v&lt;Index2&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt;const T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a>&gt; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const Index1 &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index2 &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a view of the block defined by <code>lower_bound</code> and <code>upper_bound</code>. </p>
<p>Examples of using this: </p><div class="fragment"><div class="line">std::vector&lt;size_t&gt; lobounds = {0, 1, 2};</div>
<div class="line">std::vector&lt;size_t&gt; upbounds = {4, 6, 8};</div>
<div class="line"><span class="keyword">auto</span> tview = t.block(lobounds, upbounds);</div>
<div class="line">assert(tview.range().includes(lobounds));</div>
<div class="line">assert(tview(lobounds) == t(lobounds));</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index1</td><td>An integral range type </td></tr>
    <tr><td class="paramname">Index2</td><td>An integral range type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lower_bound</td><td>The lower bound </td></tr>
    <tr><td class="paramname">upper_bound</td><td>The upper bound </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a {const,mutable} view of the block defined by <code>lower_bound</code> and <code>upper_bound</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the size of <code>lower_bound</code> is not equal to that of <code>upper_bound</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When <code>lower_bound[i] &gt;= upper_bound[i]</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00714">714</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a828903d60bcf6fe9b6948b982b048e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a828903d60bcf6fe9b6948b982b048e7d">&#9670;&nbsp;</a></span>block() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename PairRange , typename  = std::enable_if_t&lt;detail::is_gpair_range_v&lt;PairRange&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt;T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a>&gt; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const PairRange &amp;&#160;</td>
          <td class="paramname"><em>bounds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a view of the block defined by its <code>bounds</code> . </p>
<p>Examples of using this: </p><div class="fragment"><div class="line">std::vector&lt;size_t&gt; lobounds = {0, 1, 2};</div>
<div class="line">std::vector&lt;size_t&gt; upbounds = {4, 6, 8};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// using vector of pairs</span></div>
<div class="line">std::vector&lt;std::pair&lt;size_t,size_t&gt;&gt; vpbounds{{0,4}, {1,6}, {2,8}};</div>
<div class="line"><span class="keyword">auto</span> tview0 = t.block(vpbounds);</div>
<div class="line"><span class="comment">// using vector of tuples</span></div>
<div class="line">std::vector&lt;std::tuple&lt;size_t,size_t&gt;&gt; vtbounds{{0,4}, {1,6}, {2,8}};</div>
<div class="line"><span class="keyword">auto</span> tview1 = t.block(vtbounds);</div>
<div class="line">assert(tview0 == tview1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// using zipped ranges of bounds (using Boost.Range)</span></div>
<div class="line"><span class="comment">// need to #include &lt;boost/range/combine.hpp&gt;</span></div>
<div class="line"><span class="keyword">auto</span> tview2 = t.block(boost::combine(lobounds, upbounds));</div>
<div class="line">assert(tview0 == tview2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// using zipped ranges of bounds (using Ranges-V3)</span></div>
<div class="line"><span class="comment">// need to #include &lt;range/v3/view/zip.hpp&gt;</span></div>
<div class="line"><span class="keyword">auto</span> tview3 = t.block(ranges::views::zip(lobounds, upbounds));</div>
<div class="line">assert(tview0 == tview3);</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PairRange</td><td>Type representing a range of generalized pairs (see TiledArray::detail::is_gpair_v ) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bounds</td><td>The block bounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a {const,mutable} view of the block defined by its <code>bounds</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the size of <code>lower_bound</code> is not equal to that of <code>upper_bound</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When <code>get&lt;0&gt;(bounds[i]) &gt;= get&lt;1&gt;(bounds[i])</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00808">808</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a20c21c3879e579fc4c67836498b4cbd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c21c3879e579fc4c67836498b4cbd6">&#9670;&nbsp;</a></span>block() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename PairRange , typename  = std::enable_if_t&lt;detail::is_gpair_range_v&lt;PairRange&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt;const T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a>&gt; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const PairRange &amp;&#160;</td>
          <td class="paramname"><em>bounds</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a view of the block defined by its <code>bounds</code> . </p>
<p>Examples of using this: </p><div class="fragment"><div class="line">std::vector&lt;size_t&gt; lobounds = {0, 1, 2};</div>
<div class="line">std::vector&lt;size_t&gt; upbounds = {4, 6, 8};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// using vector of pairs</span></div>
<div class="line">std::vector&lt;std::pair&lt;size_t,size_t&gt;&gt; vpbounds{{0,4}, {1,6}, {2,8}};</div>
<div class="line"><span class="keyword">auto</span> tview0 = t.block(vpbounds);</div>
<div class="line"><span class="comment">// using vector of tuples</span></div>
<div class="line">std::vector&lt;std::tuple&lt;size_t,size_t&gt;&gt; vtbounds{{0,4}, {1,6}, {2,8}};</div>
<div class="line"><span class="keyword">auto</span> tview1 = t.block(vtbounds);</div>
<div class="line">assert(tview0 == tview1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// using zipped ranges of bounds (using Boost.Range)</span></div>
<div class="line"><span class="comment">// need to #include &lt;boost/range/combine.hpp&gt;</span></div>
<div class="line"><span class="keyword">auto</span> tview2 = t.block(boost::combine(lobounds, upbounds));</div>
<div class="line">assert(tview0 == tview2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// using zipped ranges of bounds (using Ranges-V3)</span></div>
<div class="line"><span class="comment">// need to #include &lt;range/v3/view/zip.hpp&gt;</span></div>
<div class="line"><span class="keyword">auto</span> tview3 = t.block(ranges::views::zip(lobounds, upbounds));</div>
<div class="line">assert(tview0 == tview3);</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PairRange</td><td>Type representing a range of generalized pairs (see TiledArray::detail::is_gpair_v ) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bounds</td><td>The block bounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a {const,mutable} view of the block defined by its <code>bounds</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the size of <code>lower_bound</code> is not equal to that of <code>upper_bound</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When <code>get&lt;0&gt;(bounds[i]) &gt;= get&lt;1&gt;(bounds[i])</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00800">800</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a37519a7ff1e4165a008bc8b003f19809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37519a7ff1e4165a008bc8b003f19809">&#9670;&nbsp;</a></span>block() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Index1 , typename Index2 , typename  = std::enable_if_t&lt;std::is_integral_v&lt;Index1&gt; &amp;&amp;                                        std::is_integral_v&lt;Index2&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt;T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a>&gt; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; Index1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; Index2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a view of the block defined by <code>lower_bound</code> and <code>upper_bound</code>. </p>
<p>Examples of using this: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> tview = t.block({0, 1, 2}, {4, 6, 8});</div>
<div class="line">assert(tview.range().includes(lobounds));</div>
<div class="line">assert(tview(lobounds) == t(lobounds));</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index1</td><td>An integral type </td></tr>
    <tr><td class="paramname">Index2</td><td>An integral type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lower_bound</td><td>The lower bound </td></tr>
    <tr><td class="paramname">upper_bound</td><td>The upper bound </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a {const,mutable} view of the block defined by <code>lower_bound</code> and <code>upper_bound</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the size of <code>lower_bound</code> is not equal to that of <code>upper_bound</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When <code>lower_bound[i] &gt;= upper_bound[i]</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00744">744</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ad5729f9fe64ed5c2d953ffcfad00793a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5729f9fe64ed5c2d953ffcfad00793a">&#9670;&nbsp;</a></span>block() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Index1 , typename Index2 , typename  = std::enable_if_t&lt;std::is_integral_v&lt;Index1&gt; &amp;&amp;                                        std::is_integral_v&lt;Index2&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt;const T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a>&gt; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; Index1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; Index2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a view of the block defined by <code>lower_bound</code> and <code>upper_bound</code>. </p>
<p>Examples of using this: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> tview = t.block({0, 1, 2}, {4, 6, 8});</div>
<div class="line">assert(tview.range().includes(lobounds));</div>
<div class="line">assert(tview(lobounds) == t(lobounds));</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index1</td><td>An integral type </td></tr>
    <tr><td class="paramname">Index2</td><td>An integral type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lower_bound</td><td>The lower bound </td></tr>
    <tr><td class="paramname">upper_bound</td><td>The upper bound </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a {const,mutable} view of the block defined by <code>lower_bound</code> and <code>upper_bound</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the size of <code>lower_bound</code> is not equal to that of <code>upper_bound</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When <code>lower_bound[i] &gt;= upper_bound[i]</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00755">755</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a9b81f76e5131112b218d4b6153c0f38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b81f76e5131112b218d4b6153c0f38f">&#9670;&nbsp;</a></span>block() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Index , typename  = std::enable_if_t&lt;std::is_integral_v&lt;Index&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt;T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a>&gt; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; std::initializer_list&lt; Index &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bounds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a view of the block defined by its <code>bounds</code> . </p>
<p>Examples of using this: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> tview0 = t.block({{0,4}, {1,6}, {2,8}});</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>An integral type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bounds</td><td>The block bounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a {const,mutable} view of the block defined by its <code>bounds</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the size of <code>lower_bound</code> is not equal to that of <code>upper_bound</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When <code>get&lt;0&gt;(bounds[i]) &gt;= get&lt;1&gt;(bounds[i])</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00839">839</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a067947c86081dbd78cfdabe56c547fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067947c86081dbd78cfdabe56c547fd3">&#9670;&nbsp;</a></span>block() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Index , typename  = std::enable_if_t&lt;std::is_integral_v&lt;Index&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt;const T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a>&gt; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; std::initializer_list&lt; Index &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bounds</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a view of the block defined by its <code>bounds</code> . </p>
<p>Examples of using this: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> tview0 = t.block({{0,4}, {1,6}, {2,8}});</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>An integral type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bounds</td><td>The block bounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a {const,mutable} view of the block defined by its <code>bounds</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the size of <code>lower_bound</code> is not equal to that of <code>upper_bound</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When <code>get&lt;0&gt;(bounds[i]) &gt;= get&lt;1&gt;(bounds[i])</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00831">831</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a7b98a790ddf50ce4097387d49119017c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b98a790ddf50ce4097387d49119017c">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00359">359</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_tiled_array_1_1_tensor_a7b98a790ddf50ce4097387d49119017c_icgraph.png" border="0" usemap="#aclass_tiled_array_1_1_tensor_a7b98a790ddf50ce4097387d49119017c_icgraph" alt=""/></div>
<map name="class_tiled_array_1_1_tensor_a7b98a790ddf50ce4097387d49119017c_icgraph" id="aclass_tiled_array_1_1_tensor_a7b98a790ddf50ce4097387d49119017c_icgraph">
<area shape="rect" title=" " alt="" coords="233,39,372,80"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a041163e241c9d1ecd99598984fae784a" title="Shift the lower and upper bound of this range." alt="" coords="15,5,175,47"/>
<area shape="rect" href="class_tiled_array_1_1_sparse_shape.html#afc63decd7b2f8c09274229cd0d69cf84" title="Creates a copy of this with a sub&#45;block updated with contents of another shape." alt="" coords="5,71,185,112"/>
</map>
</div>

</div>
</div>
<a id="a78bda38f32136cd4fea2d438e13ca7ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78bda38f32136cd4fea2d438e13ca7ab">&#9670;&nbsp;</a></span>conj() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::conj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a complex conjugated copy of this tensor. </p>
<dl class="section return"><dt>Returns</dt><dd>A copy of this tensor that contains the complex conjugate the values </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01528">1528</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a9cf795bd542f5f1c19779354487a20f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf795bd542f5f1c19779354487a20f9">&#9670;&nbsp;</a></span>conj() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::conj </td>
          <td>(</td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a complex conjugated and permuted copy of this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Perm</td><td>A permutation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A permuted copy of this tensor that contains the complex conjugate values </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01554">1554</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ac603273ec73a837ae049660cb7b3c539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac603273ec73a837ae049660cb7b3c539">&#9670;&nbsp;</a></span>conj() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::conj </td>
          <td>(</td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a complex conjugated and scaled copy of this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of this tensor that contains the scaled complex conjugate the values </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01541">1541</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a9838508c8bafa4402d54e9714cd671b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9838508c8bafa4402d54e9714cd671b7">&#9670;&nbsp;</a></span>conj() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Scalar , typename Perm , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::conj </td>
          <td>(</td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a complex conjugated, scaled, and permuted copy of this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
    <tr><td class="paramname">Perm</td><td>A permutation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A permuted copy of this tensor that contains the complex conjugate values </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01571">1571</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="af3ada2b7db72107f273a04394bdccac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ada2b7db72107f273a04394bdccac5">&#9670;&nbsp;</a></span>conj_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::conj_to </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Complex conjugate this tensor. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01579">1579</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a184678a6a02973c2a2de3ee08354855e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184678a6a02973c2a2de3ee08354855e">&#9670;&nbsp;</a></span>conj_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::conj_to </td>
          <td>(</td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Complex conjugate and scale this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01591">1591</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a372ad5542cb41792eb72a6e1da63b6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372ad5542cb41792eb72a6e1da63b6b0">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#ace0c51fc37253afe287423fe5971da8c">pointer</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data direct access. </p>
<dl class="section return"><dt>Returns</dt><dd>A const pointer to the tensor data </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00614">614</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a9270d658412efce71cde14a4e9488664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9270d658412efce71cde14a4e9488664">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a13b3ca56e0bf2b27a8632d1598c1d526">const_pointer</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data direct access. </p>
<dl class="section return"><dt>Returns</dt><dd>A const pointer to the tensor data </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00609">609</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_tiled_array_1_1_tensor_a9270d658412efce71cde14a4e9488664_icgraph.png" border="0" usemap="#aclass_tiled_array_1_1_tensor_a9270d658412efce71cde14a4e9488664_icgraph" alt=""/></div>
<map name="class_tiled_array_1_1_tensor_a9270d658412efce71cde14a4e9488664_icgraph" id="aclass_tiled_array_1_1_tensor_a9270d658412efce71cde14a4e9488664_icgraph">
<area shape="rect" title="Data direct access." alt="" coords="488,269,627,310"/>
<area shape="rect" href="class_tiled_array_1_1_sparse_shape.html#a6e638781d0d2ec4347947b7ed627b9e5" title=" " alt="" coords="227,5,439,32"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#a716b4de519b8ce66cdf12b9e6578f30b" title="fuses the SparseShape objects of a tilewise&#45;round&#45;robin distributed vector of Arrays into single Spar..." alt="" coords="225,57,440,98"/>
<area shape="rect" href="kronecker__delta_8h.html#ae33f74c464abec8b0dfb2318ccdc1ffb" title=" " alt="" coords="301,123,365,149"/>
<area shape="rect" href="class_tiled_array_1_1_sparse_shape.html#a369e1a3d9a37069ede03c6726f0c6005" title=" " alt="" coords="243,174,423,215"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#ae91166d3998a0f1ea70bd76ea3a4fcab" title="Contract this tensor with other." alt="" coords="245,239,420,281"/>
<area shape="rect" href="namespace_tiled_array.html#a55a3b9976b8eacacfa0517e6bdc7c44d" title="collective bitwise&#45;compare&#45;reduce for SparseShape objects" alt="" coords="243,305,422,332"/>
<area shape="rect" href="namespace_tiled_array.html#a15916eaafd6285509fe08919de285f23" title=" " alt="" coords="246,356,419,383"/>
<area shape="rect" href="namespace_tiled_array_1_1detail.html#af29fcee5d56ed2b3110413f3d8d31d2f" title="extracts the shape of a slice of a fused array created with fuse_vector_of_arrays" alt="" coords="232,407,433,449"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#ad06d56e445f36d572109abbafc1a32e5" title="Construct a tensor with a fill value." alt="" coords="245,473,420,514"/>
<area shape="rect" href="class_tiled_array_1_1_sparse_shape.html#acf0399cdc088cd6ebe7be0749613a621" title="Transform the norm tensor with an operation." alt="" coords="243,538,423,579"/>
<area shape="rect" href="namespace_tiled_array.html#ac602cf7316f1296d1f59f76975f5cdfb" title="fuses a vector of DistArray objects, each with the same TiledRange into a DistArray with 1 more dimen..." alt="" coords="5,57,177,98"/>
<area shape="rect" href="namespace_tiled_array.html#a40ec22d8c4caa8f1662a6c124430e802" title="extracts a subarray of a fused array created with fuse_vector_of_arrays and creates the array in loca..." alt="" coords="15,407,168,449"/>
</map>
</div>

</div>
</div>
<a id="a33d2d35f79fdf07d7c6878c89d8a9288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d2d35f79fdf07d7c6878c89d8a9288">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::dot </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector dot (not inner!) product. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The right-hand tensor to be reduced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dot product of the this and <code>other</code> If numeric_type is real, this is equivalent to inner product </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_tiled_array_1_1_tensor.html#a82161c441a1caca56cb1a894c6ebc7b0" title="Vector inner product.">Tensor::inner_product</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l02130">2130</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a42ac278b525693192e0c84e330016890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ac278b525693192e0c84e330016890">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the tensor is empty. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this tensor was default constructed (contains no data), otherwise <code>false</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00620">620</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_tiled_array_1_1_tensor_a42ac278b525693192e0c84e330016890_icgraph.png" border="0" usemap="#aclass_tiled_array_1_1_tensor_a42ac278b525693192e0c84e330016890_icgraph" alt=""/></div>
<map name="class_tiled_array_1_1_tensor_a42ac278b525693192e0c84e330016890_icgraph" id="aclass_tiled_array_1_1_tensor_a42ac278b525693192e0c84e330016890_icgraph">
<area shape="rect" title="Test if the tensor is empty." alt="" coords="228,5,367,47"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#ae91166d3998a0f1ea70bd76ea3a4fcab" title="Contract this tensor with other." alt="" coords="5,5,180,47"/>
</map>
</div>

</div>
</div>
<a id="a388e96f2343d855abff091534612abbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388e96f2343d855abff091534612abbd">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a7c3a6bcdbeae5dec3343d6ae28df8284">iterator</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator factory. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the last data element </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00602">602</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a694f5a6f30c4f98cca111e2de3d7be90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a694f5a6f30c4f98cca111e2de3d7be90">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a643a4203b62aa1e370d6995aad071f40">const_iterator</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator factory. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the last data element </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00595">595</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a48166eac5917c1bd91ad06edf149355a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48166eac5917c1bd91ad06edf149355a">&#9670;&nbsp;</a></span>gemm() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename AU , typename V , typename AV , typename ElementMultiplyAddOp , typename  = std::enable_if_t&lt;std::is_invocable_r_v&lt;                void, std::remove_reference_t&lt;ElementMultiplyAddOp&gt;,                value_type&amp;, const U&amp;, const V&amp;&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::gemm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; U, AU &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; V, AV &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1math_1_1_gemm_helper.html">math::GemmHelper</a> &amp;&#160;</td>
          <td class="paramname"><em>gemm_helper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementMultiplyAddOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>elem_muladd_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01887">1887</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="af12cb6d7375f20c89f8a42327efe2fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12cb6d7375f20c89f8a42327efe2fa5">&#9670;&nbsp;</a></span>gemm() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename AU , typename V , typename AV , typename W &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::gemm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; U, AU &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; V, AV &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const W&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1math_1_1_gemm_helper.html">math::GemmHelper</a> &amp;&#160;</td>
          <td class="paramname"><em>gemm_helper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contract two tensors and accumulate the scaled result to this tensor. </p>
<p>GEMM is limited to matrix like contractions. For example, the following contractions are supported: </p><div class="fragment"><div class="line">C[a,b] = A[a,i,j] * B[i,j,b]</div>
<div class="line">C[a,b] = A[a,i,j] * B[b,i,j]</div>
<div class="line">C[a,b] = A[i,j,a] * B[i,j,b]</div>
<div class="line">C[a,b] = A[i,j,a] * B[b,i,j]</div>
<div class="line"> </div>
<div class="line">C[a,b,c,d] = A[a,b,i,j] * B[i,j,c,d]</div>
<div class="line">C[a,b,c,d] = A[a,b,i,j] * B[c,d,i,j]</div>
<div class="line">C[a,b,c,d] = A[i,j,a,b] * B[i,j,c,d]</div>
<div class="line">C[a,b,c,d] = A[i,j,a,b] * B[c,d,i,j]</div>
</div><!-- fragment --><p> Notice that in the above contractions, the inner and outer indices of the arguments for exactly two contiguous groups in each tensor and that each group is in the same order in all tensors. That is, the indices of the tensors must fit the one of the following patterns: </p><div class="fragment"><div class="line">C[M...,N...] = A[M...,K...] * B[K...,N...]</div>
<div class="line">C[M...,N...] = A[M...,K...] * B[N...,K...]</div>
<div class="line">C[M...,N...] = A[K...,M...] * B[K...,N...]</div>
<div class="line">C[M...,N...] = A[K...,M...] * B[N...,K...]</div>
</div><!-- fragment --><p> This allows use of optimized BLAS functions to evaluate tensor contractions. <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> contractions that do not fit this pattern require one or more tensor permutation so that the tensors fit the required pattern. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The left-hand tensor element type </td></tr>
    <tr><td class="paramname">AU</td><td>The left-hand tensor allocator type </td></tr>
    <tr><td class="paramname">V</td><td>The right-hand tensor element type </td></tr>
    <tr><td class="paramname">AV</td><td>The right-hand tensor allocator type </td></tr>
    <tr><td class="paramname">W</td><td>The type of the scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor that will be contracted </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor that will be contracted </td></tr>
    <tr><td class="paramname">factor</td><td>The contraction result will be scaling by this value, then accumulated into <code>this@param</code>  gemm_helper The *GEMM operation meta data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>if this is uninitialized, i.e., if <code>this-&gt;<a class="el" href="class_tiled_array_1_1_tensor.html#a42ac278b525693192e0c84e330016890" title="Test if the tensor is empty.">empty()</a>==true</code> will this is equivalent to <div class="fragment"><div class="line"><span class="keywordflow">return</span> (*<span class="keyword">this</span> = left.gemm(right, factor, gemm_helper));</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01741">1741</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ae91166d3998a0f1ea70bd76ea3a4fcab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91166d3998a0f1ea70bd76ea3a4fcab">&#9670;&nbsp;</a></span>gemm() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename AU , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::gemm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; U, AU &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1math_1_1_gemm_helper.html">math::GemmHelper</a> &amp;&#160;</td>
          <td class="paramname"><em>gemm_helper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contract this tensor with <code>other</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The other tensor element type </td></tr>
    <tr><td class="paramname">AU</td><td>The other tensor allocator type </td></tr>
    <tr><td class="paramname">V</td><td>The type of <code>factor</code> scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tensor that will be contracted with this tensor </td></tr>
    <tr><td class="paramname">factor</td><td>Multiply the result by this constant </td></tr>
    <tr><td class="paramname">gemm_helper</td><td>The *GEMM operation meta data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor which is the result of contracting this tensor with <code>other</code> and scaled by <code>factor</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01609">1609</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_tiled_array_1_1_tensor_ae91166d3998a0f1ea70bd76ea3a4fcab_icgraph.png" border="0" usemap="#aclass_tiled_array_1_1_tensor_ae91166d3998a0f1ea70bd76ea3a4fcab_icgraph" alt=""/></div>
<map name="class_tiled_array_1_1_tensor_ae91166d3998a0f1ea70bd76ea3a4fcab_icgraph" id="aclass_tiled_array_1_1_tensor_ae91166d3998a0f1ea70bd76ea3a4fcab_icgraph">
<area shape="rect" title="Contract this tensor with other." alt="" coords="233,29,372,71"/>
<area shape="rect" href="class_tiled_array_1_1_sparse_shape.html#a369e1a3d9a37069ede03c6726f0c6005" title=" " alt="" coords="5,29,185,71"/>
</map>
</div>

</div>
</div>
<a id="a82161c441a1caca56cb1a894c6ebc7b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82161c441a1caca56cb1a894c6ebc7b0">&#9670;&nbsp;</a></span>inner_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::inner_product </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector inner product. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The right-hand tensor to be reduced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dot product of the this and <code>other</code> If numeric_type is real, this is equivalent to dot product </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_tiled_array_1_1_tensor.html#a33d2d35f79fdf07d7c6878c89d8a9288" title="Vector dot (not inner!) product.">Tensor::dot</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l02147">2147</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a272585651b1233bb8f90d23c88a12c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272585651b1233bb8f90d23c88a12c61">&#9670;&nbsp;</a></span>inplace_binary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Op , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::inplace_binary </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use a binary, element wise operation to modify this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Op</td><td>The binary operation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The right-hand argument in the binary operation </td></tr>
    <tr><td class="paramname">op</td><td>The binary, element-wise operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When this tensor is empty. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When <code>other</code> is empty. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the range of this tensor is not equal to the range of <code>other</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When this and <code>other</code> are the same. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01005">1005</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_tiled_array_1_1_tensor_a272585651b1233bb8f90d23c88a12c61_icgraph.png" border="0" usemap="#aclass_tiled_array_1_1_tensor_a272585651b1233bb8f90d23c88a12c61_icgraph" alt=""/></div>
<map name="class_tiled_array_1_1_tensor_a272585651b1233bb8f90d23c88a12c61_icgraph" id="aclass_tiled_array_1_1_tensor_a272585651b1233bb8f90d23c88a12c61_icgraph">
<area shape="rect" title="Use a binary, element wise operation to modify this tensor." alt="" coords="236,71,375,112"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a3dfff2aa620117307ba085091693a768" title="Add other to this tensor." alt="" coords="9,5,185,47"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#aebdd5ac100129cb2858243e3d6e301d1" title="Multiply this tensor by right." alt="" coords="5,71,188,112"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a6732b912c2ce09fcf078d814f0ca8cb9" title="Subtract right from this tensor." alt="" coords="7,136,187,177"/>
</map>
</div>

</div>
</div>
<a id="af23df0d855cd33e6e977bd39e780ca9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23df0d855cd33e6e977bd39e780ca9a">&#9670;&nbsp;</a></span>inplace_unary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::inplace_unary </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use a unary, element wise operation to modify this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The unary operation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The unary, element-wise operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When this tensor is empty. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01062">1062</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_tiled_array_1_1_tensor_af23df0d855cd33e6e977bd39e780ca9a_icgraph.png" border="0" usemap="#aclass_tiled_array_1_1_tensor_af23df0d855cd33e6e977bd39e780ca9a_icgraph" alt=""/></div>
<map name="class_tiled_array_1_1_tensor_af23df0d855cd33e6e977bd39e780ca9a_icgraph" id="aclass_tiled_array_1_1_tensor_af23df0d855cd33e6e977bd39e780ca9a_icgraph">
<area shape="rect" title="Use a unary, element wise operation to modify this tensor." alt="" coords="240,104,379,145"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#ad959a4848795f8352fd9dfd25631948a" title="Add a constant to this tensor." alt="" coords="11,5,187,47"/>
<area shape="rect" href="class_tiled_array_1_1_sparse_shape.html#a369e1a3d9a37069ede03c6726f0c6005" title=" " alt="" coords="9,71,189,112"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a0f298b826efdc604b419d2da13d4a862" title="Negate elements of this tensor." alt="" coords="11,136,187,177"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a19ee5e211e0a606f194bde6699b9d373" title="Scale this tensor." alt="" coords="5,201,192,243"/>
</map>
</div>

</div>
</div>
<a id="a92f492a7c588bc82c2fafc45519bdb6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f492a7c588bc82c2fafc45519bdb6b">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Numeric  = numeric_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::max </td>
          <td>(</td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1is__strictly__ordered.html">detail::is_strictly_ordered</a>&lt; Numeric &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum element. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum elements of this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l02085">2085</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a8a22a994aafd87df8d012ddce92bad3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a22a994aafd87df8d012ddce92bad3a">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Numeric  = numeric_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::min </td>
          <td>(</td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1is__strictly__ordered.html">detail::is_strictly_ordered</a>&lt; Numeric &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum element. </p>
<dl class="section return"><dt>Returns</dt><dd>The minimum elements of this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l02073">2073</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="af6c8926e73667ca0d495d17084d1ddf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c8926e73667ca0d495d17084d1ddf0">&#9670;&nbsp;</a></span>mult() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::mult </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply this by <code>right</code> to create a new tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be multiplied by this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the product of the elements of <code>this</code> and <code>right</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01398">1398</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_tiled_array_1_1_tensor_af6c8926e73667ca0d495d17084d1ddf0_icgraph.png" border="0" usemap="#aclass_tiled_array_1_1_tensor_af6c8926e73667ca0d495d17084d1ddf0_icgraph" alt=""/></div>
<map name="class_tiled_array_1_1_tensor_af6c8926e73667ca0d495d17084d1ddf0_icgraph" id="aclass_tiled_array_1_1_tensor_af6c8926e73667ca0d495d17084d1ddf0_icgraph">
<area shape="rect" title="Multiply this by right to create a new tensor." alt="" coords="233,5,372,47"/>
<area shape="rect" href="class_tiled_array_1_1_sparse_shape.html#a58e6c815e2b1f46f941d47736c5201f9" title=" " alt="" coords="5,5,185,47"/>
</map>
</div>

</div>
</div>
<a id="afbfd1dabf6aaf4a91a5224d0f671e572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfd1dabf6aaf4a91a5224d0f671e572">&#9670;&nbsp;</a></span>mult() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Perm , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::mult </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply this by <code>right</code> to create a new, permuted tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Perm</td><td>a permutation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be multiplied by this tensor </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the product of the elements of <code>this</code> and <code>right</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01418">1418</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a5aec85b9b6e42edf0f8dbe76dcf3cdb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aec85b9b6e42edf0f8dbe76dcf3cdb9">&#9670;&nbsp;</a></span>mult() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::mult </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile.">Scale</a> and multiply this by <code>right</code> to create a new tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be multiplied by this tensor </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the product of the elements of <code>this</code> and <code>right</code>, scaled by <code>factor</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01439">1439</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a2ddf077ade58420b77b72284ca05cd1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ddf077ade58420b77b72284ca05cd1d">&#9670;&nbsp;</a></span>mult() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Scalar , typename Perm , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::mult </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile.">Scale</a> and multiply this by <code>right</code> to create a new, permuted tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
    <tr><td class="paramname">Perm</td><td>A permutation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be multiplied by this tensor </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the product of the elements of <code>this</code> and <code>right</code>, scaled by <code>factor</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01459">1459</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="aebdd5ac100129cb2858243e3d6e301d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebdd5ac100129cb2858243e3d6e301d1">&#9670;&nbsp;</a></span>mult_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::mult_to </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply this tensor by <code>right</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be multiplied by this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01475">1475</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a18aa389491689d55c015492e5b2f139e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18aa389491689d55c015492e5b2f139e">&#9670;&nbsp;</a></span>mult_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::mult_to </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile.">Scale</a> and multiply this tensor by <code>right</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be multiplied by this tensor </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01491">1491</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a90085facd751fa8fd4eff4aa4b1d73ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90085facd751fa8fd4eff4aa4b1d73ef">&#9670;&nbsp;</a></span>neg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::neg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a negated copy of this tensor. </p>
<dl class="section return"><dt>Returns</dt><dd>A new tensor that contains the negative values of this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01502">1502</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a09dec24fc584b7fbd1ec62df6e6e4941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09dec24fc584b7fbd1ec62df6e6e4941">&#9670;&nbsp;</a></span>neg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::neg </td>
          <td>(</td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a negated and permuted copy of this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Perm</td><td>A permutation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor that contains the negative values of this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01513">1513</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a0f298b826efdc604b419d2da13d4a862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f298b826efdc604b419d2da13d4a862">&#9670;&nbsp;</a></span>neg_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::neg_to </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negate elements of this tensor. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01520">1520</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a724f7712da193d3b71d6f5d2f00ae4b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724f7712da193d3b71d6f5d2f00ae4b3">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename ResultType  = scalar_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultType <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector 2-norm. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultType</td><td>return type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This evaluates <code>std::sqrt</code>(ResultType(this-&gt;<a class="el" href="class_tiled_array_1_1_tensor.html#a47757d8cd5015280a09ee20f453c86c2" title="Square of vector 2-norm.">squared_norm()</a>)) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The vector norm of this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l02065">2065</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="aee30f450ec40eb4d5df2f054b384ed85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee30f450ec40eb4d5df2f054b384ed85">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename... Index, std::enable_if_t&lt; detail::is_integral_list&lt; Index... &gt;::value &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#ac8dc24eca41c8655a8871e838183e24b">reference</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const Index &amp;...&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>an integral list ( see <a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__list.html">TiledArray::detail::is_integral_list</a> )</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>an index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the element at position <code>i</code> . </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This asserts (using TA_ASSERT) that this is not empty and ord is included in the range </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00576">576</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="af40b96a1c4b7750244b8505b39ecc53f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40b96a1c4b7750244b8505b39ecc53f">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename... Index, std::enable_if_t&lt; detail::is_integral_list&lt; Index... &gt;::value &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a8b80372c9a8886e30106219eca40b66c">const_reference</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const Index &amp;...&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const element accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>an integral list ( see <a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__list.html">TiledArray::detail::is_integral_list</a> )</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>an index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the element at position <code>i</code> . </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This asserts (using TA_ASSERT) that this is not empty and ord is included in the range </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00561">561</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a0a5a17c369d356dc4001df631308341e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5a17c369d356dc4001df631308341e">&#9670;&nbsp;</a></span>operator()() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Index , std::enable_if_t&lt; detail::is_integral_range_v&lt; Index &gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#ac8dc24eca41c8655a8871e838183e24b">reference</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>An integral range type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>an index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the element at position <code>i</code> . </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This asserts (using TA_ASSERT) that this is not empty and ord is included in the range </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00516">516</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a9be3cd4f960dda017f9832f0d1a12f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be3cd4f960dda017f9832f0d1a12f15">&#9670;&nbsp;</a></span>operator()() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Index , std::enable_if_t&lt; detail::is_integral_range_v&lt; Index &gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a8b80372c9a8886e30106219eca40b66c">const_reference</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const element accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>An integral range type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>an index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the element at position <code>i</code> . </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This asserts (using TA_ASSERT) that this is not empty and ord is included in the range </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00501">501</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a55ce6b66356074415d13c6e1a28282fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ce6b66356074415d13c6e1a28282fb">&#9670;&nbsp;</a></span>operator()() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Integer , std::enable_if_t&lt; std::is_integral_v&lt; Integer &gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#ac8dc24eca41c8655a8871e838183e24b">reference</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; Integer &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Integer</td><td>An integral type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>an index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the element at position <code>i</code> . </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This asserts (using TA_ASSERT) that this is not empty and ord is included in the range </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00546">546</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ad5a5986f523b7cb219da0b0b7d41e776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a5986f523b7cb219da0b0b7d41e776">&#9670;&nbsp;</a></span>operator()() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Integer , std::enable_if_t&lt; std::is_integral_v&lt; Integer &gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a8b80372c9a8886e30106219eca40b66c">const_reference</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; Integer &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const element accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Integer</td><td>An integral type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>an index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the element at position <code>i</code> . </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This asserts (using TA_ASSERT) that this is not empty and ord is included in the range </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00531">531</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a864d3eed3caa265526a36b1e042aaeb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864d3eed3caa265526a36b1e042aaeb9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename std::enable_if&lt; is_tensor&lt; T1 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00371">371</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a5bb641cc67d36bf3e87b59eaf10a2dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb641cc67d36bf3e87b59eaf10a2dff">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00148">148</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a375a995714597079b944907eb89245bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a375a995714597079b944907eb89245bc">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00152">152</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a369f15590536ef934aadcf7ca3e81c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369f15590536ef934aadcf7ca3e81c39">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Index , std::enable_if_t&lt; detail::is_integral_range_v&lt; Index &gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#ac8dc24eca41c8655a8871e838183e24b">reference</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>An integral range type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>an index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the element at position <code>i</code> . </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This asserts (using TA_ASSERT) that this is not empty and ord is included in the range </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00456">456</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="aee102f98ee1f3dbbff088326c4cb451d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee102f98ee1f3dbbff088326c4cb451d">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Index , std::enable_if_t&lt; detail::is_integral_range_v&lt; Index &gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a8b80372c9a8886e30106219eca40b66c">const_reference</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const element accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>An integral range type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>an index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the element at position <code>i</code> . </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This asserts (using TA_ASSERT) that this is not empty and ord is included in the range </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00441">441</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a80576d30a4df7373e9c8d2cb4dc31c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80576d30a4df7373e9c8d2cb4dc31c02">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Ordinal , std::enable_if_t&lt; std::is_integral&lt; Ordinal &gt;::value &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#ac8dc24eca41c8655a8871e838183e24b">reference</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const Ordinal&#160;</td>
          <td class="paramname"><em>ord</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ordinal</td><td>an integer type that represents an ordinal </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ord</td><td>an ordinal index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the element at position <code>ord</code> . </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This asserts (using TA_ASSERT) that this is not empty and ord is included in the range </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00426">426</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="aa16630328ba56e7a3a07d54b7874e351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16630328ba56e7a3a07d54b7874e351">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Ordinal , std::enable_if_t&lt; std::is_integral&lt; Ordinal &gt;::value &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a8b80372c9a8886e30106219eca40b66c">const_reference</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const Ordinal&#160;</td>
          <td class="paramname"><em>ord</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const element accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ordinal</td><td>an integer type that represents an ordinal </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ord</td><td>an ordinal index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the element at position <code>ord</code> . </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This asserts (using TA_ASSERT) that this is not empty and ord is included in the range </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00411">411</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ab94a39ec1c61317a773d2c36b6f7c609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94a39ec1c61317a773d2c36b6f7c609">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Integer , std::enable_if_t&lt; std::is_integral_v&lt; Integer &gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#ac8dc24eca41c8655a8871e838183e24b">reference</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; Integer &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Integer</td><td>An integral type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>an index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the element at position <code>i</code> . </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This asserts (using TA_ASSERT) that this is not empty and ord is included in the range </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00486">486</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a6b2b8aab181d58b58375240cb45caa24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2b8aab181d58b58375240cb45caa24">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Integer , std::enable_if_t&lt; std::is_integral_v&lt; Integer &gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a8b80372c9a8886e30106219eca40b66c">const_reference</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; Integer &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const element accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Integer</td><td>An integral type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>an index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the element at position <code>i</code> . </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This asserts (using TA_ASSERT) that this is not empty and ord is included in the range </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00471">471</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a414d53dd49a11ae4a6e67907a5daa521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a414d53dd49a11ae4a6e67907a5daa521">&#9670;&nbsp;</a></span>permute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::permute </td>
          <td>(</td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a permuted copy of this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Perm</td><td>A permutation tile </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A permuted copy of this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00853">853</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="af5f4315e4e0cdef9beb147ce929c5db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f4315e4e0cdef9beb147ce929c5db7">&#9670;&nbsp;</a></span>product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::product </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Product of elements. </p>
<dl class="section return"><dt>Returns</dt><dd>The product of all elements of this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l02039">2039</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a68a674f9d2eae6d11a1e1885a0648bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a674f9d2eae6d11a1e1885a0648bb4">&#9670;&nbsp;</a></span>range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> range object mutable accessor. </p>
<dl class="section return"><dt>Returns</dt><dd>The tensor range object </dd></dl>
<dl class="section note"><dt>Note</dt><dd>asserts that this object has been already initialized </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00392">392</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ac6cab4cebeee61ec14aaf83ecc4b9952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6cab4cebeee61ec14aaf83ecc4b9952">&#9670;&nbsp;</a></span>range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> range object accessor. </p>
<dl class="section return"><dt>Returns</dt><dd>The tensor range object </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00384">384</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_tiled_array_1_1_tensor_ac6cab4cebeee61ec14aaf83ecc4b9952_icgraph.png" border="0" usemap="#aclass_tiled_array_1_1_tensor_ac6cab4cebeee61ec14aaf83ecc4b9952_icgraph" alt=""/></div>
<map name="class_tiled_array_1_1_tensor_ac6cab4cebeee61ec14aaf83ecc4b9952_icgraph" id="aclass_tiled_array_1_1_tensor_ac6cab4cebeee61ec14aaf83ecc4b9952_icgraph">
<area shape="rect" title="Tensor range object accessor." alt="" coords="233,231,372,273"/>
<area shape="rect" href="kronecker__delta_8h.html#ae33f74c464abec8b0dfb2318ccdc1ffb" title=" " alt="" coords="63,5,127,32"/>
<area shape="rect" href="class_tiled_array_1_1_sparse_shape.html#a369e1a3d9a37069ede03c6726f0c6005" title=" " alt="" coords="5,57,185,98"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#ae91166d3998a0f1ea70bd76ea3a4fcab" title="Contract this tensor with other." alt="" coords="8,122,183,163"/>
<area shape="rect" href="class_tiled_array_1_1_sparse_shape.html#ae72b7cee1a27dbef2ad7af6f7b235e5c" title="Compute union of two shapes." alt="" coords="5,187,185,229"/>
<area shape="rect" href="struct_tiled_array_1_1detail_1_1_trace_3_01_tensor_3_01_t_00_01_a_01_4_00_01detail_1_1enable__if__numeric__t_3_01_t_01_4_01_4.html#a023ad52473e939cad13e869d3d8f0c05" title=" " alt="" coords="10,253,181,339"/>
<area shape="rect" href="namespace_tiled_array.html#a15916eaafd6285509fe08919de285f23" title=" " alt="" coords="9,363,182,389"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#aff000b8850b2992ff765eb3f8f116632" title="Construct tensor." alt="" coords="8,414,183,455"/>
<area shape="rect" href="class_tiled_array_1_1_sparse_shape.html#acf0399cdc088cd6ebe7be0749613a621" title="Transform the norm tensor with an operation." alt="" coords="5,479,185,521"/>
</map>
</div>

</div>
</div>
<a id="a130321a40b1c94254c839758689e6eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130321a40b1c94254c839758689e6eba">&#9670;&nbsp;</a></span>reduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename ReduceOp , typename JoinOp , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::reduce </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>reduce_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JoinOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>join_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>identity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary reduction operation. </p>
<p>Perform an element-wise binary reduction of the data of <code>this</code> and <code>other</code> by executing <code>join_op(result, reduce_op(*this[i], other[i]))</code> for each <code>i</code> in the index range of <code>this</code> . <code>result</code> is initialized to <code>identity</code> . If HAVE_INTEL_TBB is defined, and this is a contiguous tensor, the reduction will be executed in an undefined order, otherwise will execute in the order of increasing <code>i</code> . </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand argument tensor type </td></tr>
    <tr><td class="paramname">ReduceOp</td><td>The reduction operation type </td></tr>
    <tr><td class="paramname">JoinOp</td><td>The join operation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The right-hand argument of the binary reduction </td></tr>
    <tr><td class="paramname">reduce_op</td><td>The element-wise reduction operation</td></tr>
    <tr><td class="paramname">join_op</td><td>The join result operation </td></tr>
    <tr><td class="paramname">identity</td><td>The identity value of the reduction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reduced value </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l02022">2022</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ac7e2825494e7578e27becf11d2a6b794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e2825494e7578e27becf11d2a6b794">&#9670;&nbsp;</a></span>reduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename ReduceOp , typename JoinOp , typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::reduce </td>
          <td>(</td>
          <td class="paramtype">ReduceOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>reduce_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JoinOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>join_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>identity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary reduction operation. </p>
<p>Perform an element-wise reduction of the data by executing <code>join_op(result, reduce_op(*this[i]))</code> for each <code>i</code> in the index range of <code>this</code> . <code>result</code> is initialized to <code>identity</code> . If HAVE_INTEL_TBB is defined, and this is a contiguous tensor, the reduction will be executed in an undefined order, otherwise will execute in the order of increasing <code>i</code> . </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReduceOp</td><td>The reduction operation type </td></tr>
    <tr><td class="paramname">JoinOp</td><td>The join operation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_op</td><td>The element-wise reduction operation </td></tr>
    <tr><td class="paramname">join_op</td><td>The join result operation </td></tr>
    <tr><td class="paramname">identity</td><td>The identity value of the reduction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reduced value </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01996">1996</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_tiled_array_1_1_tensor_ac7e2825494e7578e27becf11d2a6b794_icgraph.png" border="0" usemap="#aclass_tiled_array_1_1_tensor_ac7e2825494e7578e27becf11d2a6b794_icgraph" alt=""/></div>
<map name="class_tiled_array_1_1_tensor_ac7e2825494e7578e27becf11d2a6b794_icgraph" id="aclass_tiled_array_1_1_tensor_ac7e2825494e7578e27becf11d2a6b794_icgraph">
<area shape="rect" title="Unary reduction operation." alt="" coords="279,283,417,324"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a5f7a6a051f5d87261a8b71a078d68624" title="Absolute maximum element." alt="" coords="23,5,213,47"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#ae6914ca99f535592a4477df637511b58" title="Absolute minimum element." alt="" coords="25,71,211,112"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a33d2d35f79fdf07d7c6878c89d8a9288" title="Vector dot (not inner!) product." alt="" coords="41,136,195,177"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a82161c441a1caca56cb1a894c6ebc7b0" title="Vector inner product." alt="" coords="35,202,201,258"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a92f492a7c588bc82c2fafc45519bdb6b" title="Maximum element." alt="" coords="37,283,199,324"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a8a22a994aafd87df8d012ddce92bad3a" title="Minimum element." alt="" coords="39,348,197,389"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#af5f4315e4e0cdef9beb147ce929c5db7" title="Product of elements." alt="" coords="27,413,209,455"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a47757d8cd5015280a09ee20f453c86c2" title="Square of vector 2&#45;norm." alt="" coords="5,479,231,520"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a31122a03a46628005e60ed0ad1494f14" title="Sum of elements." alt="" coords="38,544,198,585"/>
</map>
</div>

</div>
</div>
<a id="a199903e3d39e1eaa85f6f3a582bde77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199903e3d39e1eaa85f6f3a582bde77e">&#9670;&nbsp;</a></span>scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a scaled copy of this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements of this tensor are scaled by <code>factor</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01077">1077</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_tiled_array_1_1_tensor_a199903e3d39e1eaa85f6f3a582bde77e_icgraph.png" border="0" usemap="#aclass_tiled_array_1_1_tensor_a199903e3d39e1eaa85f6f3a582bde77e_icgraph" alt=""/></div>
<map name="class_tiled_array_1_1_tensor_a199903e3d39e1eaa85f6f3a582bde77e_icgraph" id="aclass_tiled_array_1_1_tensor_a199903e3d39e1eaa85f6f3a582bde77e_icgraph">
<area shape="rect" title="Construct a scaled copy of this tensor." alt="" coords="212,5,351,47"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a78bda38f32136cd4fea2d438e13ca7ab" title="Create a complex conjugated copy of this tensor." alt="" coords="5,5,164,47"/>
</map>
</div>

</div>
</div>
<a id="a728823702c51b94983044531bf8130c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a728823702c51b94983044531bf8130c3">&#9670;&nbsp;</a></span>scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Scalar , typename Perm , typename  = std::enable_if_t&lt;detail::is_numeric_v&lt;Scalar&gt; &amp;&amp;                                        detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a scaled and permuted copy of this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
    <tr><td class="paramname">Perm</td><td>A permutation tile </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements of this tensor are scaled by <code>factor</code> and permuted </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01093">1093</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a19ee5e211e0a606f194bde6699b9d373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ee5e211e0a606f194bde6699b9d373">&#9670;&nbsp;</a></span>scale_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Scalar , typename std::enable_if&lt; detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::scale_to </td>
          <td>(</td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile.">Scale</a> this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01106">1106</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_tiled_array_1_1_tensor_a19ee5e211e0a606f194bde6699b9d373_icgraph.png" border="0" usemap="#aclass_tiled_array_1_1_tensor_a19ee5e211e0a606f194bde6699b9d373_icgraph" alt=""/></div>
<map name="class_tiled_array_1_1_tensor_a19ee5e211e0a606f194bde6699b9d373_icgraph" id="aclass_tiled_array_1_1_tensor_a19ee5e211e0a606f194bde6699b9d373_icgraph">
<area shape="rect" title="Scale this tensor." alt="" coords="232,5,371,47"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#af3ada2b7db72107f273a04394bdccac5" title="Complex conjugate this tensor." alt="" coords="5,5,184,47"/>
</map>
</div>

</div>
</div>
<a id="a18da463545a06f07288ea5c8439c63a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18da463545a06f07288ea5c8439c63a8">&#9670;&nbsp;</a></span>serialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Archive , typename std::enable_if&lt; madness::archive::is_output_archive&lt; Archive &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output serialization function. </p>
<p>This function enables serialization within MADNESS </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Archive</td><td>The output archive type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ar</td><td>The output archive </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00630">630</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a18da463545a06f07288ea5c8439c63a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18da463545a06f07288ea5c8439c63a8">&#9670;&nbsp;</a></span>serialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Archive , typename std::enable_if&lt; madness::archive::is_input_archive&lt; Archive &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input serialization function. </p>
<p>This function implements serialization to/from MADNESS archive objects </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Archive</td><td>The input archive type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ar</td><td>The input archive </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00648">648</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a041163e241c9d1ecd99598984fae784a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041163e241c9d1ecd99598984fae784a">&#9670;&nbsp;</a></span>shift() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Index , std::enable_if_t&lt; detail::is_integral_range_v&lt; Index &gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::shift </td>
          <td>(</td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>bound_shift</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> the lower and upper bound of this range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>An integral range type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bound_shift</td><td>The shift to be applied to the tensor range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shifted copy of this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00917">917</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ab080220cf616d0710a89d30d36abbe3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab080220cf616d0710a89d30d36abbe3a">&#9670;&nbsp;</a></span>shift() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Integer , std::enable_if_t&lt; std::is_integral_v&lt; Integer &gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::shift </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; Integer &gt; &amp;&#160;</td>
          <td class="paramname"><em>bound_shift</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> the lower and upper bound of this range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Integer</td><td>An integral type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bound_shift</td><td>The shift to be applied to the tensor range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shifted copy of this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00931">931</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a99244c08d85b7a5a2836418e0cdece1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99244c08d85b7a5a2836418e0cdece1c">&#9670;&nbsp;</a></span>shift_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Index , std::enable_if_t&lt; detail::is_integral_range_v&lt; Index &gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::shift_to </td>
          <td>(</td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>bound_shift</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> the lower and upper bound of this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>An integral range type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bound_shift</td><td>The shift to be applied to the tensor range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00890">890</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_tiled_array_1_1_tensor_a99244c08d85b7a5a2836418e0cdece1c_icgraph.png" border="0" usemap="#aclass_tiled_array_1_1_tensor_a99244c08d85b7a5a2836418e0cdece1c_icgraph" alt=""/></div>
<map name="class_tiled_array_1_1_tensor_a99244c08d85b7a5a2836418e0cdece1c_icgraph" id="aclass_tiled_array_1_1_tensor_a99244c08d85b7a5a2836418e0cdece1c_icgraph">
<area shape="rect" title="Shift the lower and upper bound of this tensor." alt="" coords="213,5,352,47"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a041163e241c9d1ecd99598984fae784a" title="Shift the lower and upper bound of this range." alt="" coords="5,5,165,47"/>
</map>
</div>

</div>
</div>
<a id="a5c9da26ffb207aa005eb6b9bb797a5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9da26ffb207aa005eb6b9bb797a5fa">&#9670;&nbsp;</a></span>shift_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Integer , std::enable_if_t&lt; std::is_integral_v&lt; Integer &gt;&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::shift_to </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; Integer &gt; &amp;&#160;</td>
          <td class="paramname"><em>bound_shift</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile.">Shift</a> the lower and upper bound of this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Integer</td><td>An integral type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bound_shift</td><td>The shift to be applied to the tensor range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00903">903</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ab27ca10b5f528a0625e1eacd76106880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27ca10b5f528a0625e1eacd76106880">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#ad041efe131da1739c84d97e7808f0044">ordinal_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">Tensor</a> dimension size accessor. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00400">400</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_tiled_array_1_1_tensor_ab27ca10b5f528a0625e1eacd76106880_icgraph.png" border="0" usemap="#aclass_tiled_array_1_1_tensor_ab27ca10b5f528a0625e1eacd76106880_icgraph" alt=""/></div>
<map name="class_tiled_array_1_1_tensor_ab27ca10b5f528a0625e1eacd76106880_icgraph" id="aclass_tiled_array_1_1_tensor_ab27ca10b5f528a0625e1eacd76106880_icgraph">
<area shape="rect" title="Tensor dimension size accessor." alt="" coords="232,23,371,65"/>
<area shape="rect" href="namespace_tiled_array.html#a55a3b9976b8eacacfa0517e6bdc7c44d" title="collective bitwise&#45;compare&#45;reduce for SparseShape objects" alt="" coords="5,5,184,32"/>
<area shape="rect" href="namespace_tiled_array.html#a15916eaafd6285509fe08919de285f23" title=" " alt="" coords="8,56,181,83"/>
</map>
</div>

</div>
</div>
<a id="a47757d8cd5015280a09ee20f453c86c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47757d8cd5015280a09ee20f453c86c2">&#9670;&nbsp;</a></span>squared_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a9a3ff935ffdd12ded18a1041a0a18faf">scalar_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::squared_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Square of vector 2-norm. </p>
<dl class="section return"><dt>Returns</dt><dd>The vector norm of this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l02048">2048</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_tiled_array_1_1_tensor_a47757d8cd5015280a09ee20f453c86c2_icgraph.png" border="0" usemap="#aclass_tiled_array_1_1_tensor_a47757d8cd5015280a09ee20f453c86c2_icgraph" alt=""/></div>
<map name="class_tiled_array_1_1_tensor_a47757d8cd5015280a09ee20f453c86c2_icgraph" id="aclass_tiled_array_1_1_tensor_a47757d8cd5015280a09ee20f453c86c2_icgraph">
<area shape="rect" title="Square of vector 2&#45;norm." alt="" coords="220,5,359,47"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a724f7712da193d3b71d6f5d2f00ae4b3" title="Vector 2&#45;norm." alt="" coords="5,5,172,47"/>
</map>
</div>

</div>
</div>
<a id="adafd98999ba0678b42e4a8f1312a4252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adafd98999ba0678b42e4a8f1312a4252">&#9670;&nbsp;</a></span>subt() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::subt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract a constant from a copy of this tensor. </p>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the different between the elements of <code>this</code> and <code>value</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01339">1339</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ab4b8e9ed97e9644d14924722d8bdd49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b8e9ed97e9644d14924722d8bdd49d">&#9670;&nbsp;</a></span>subt() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::subt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract a constant from a permuted copy of this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Perm</td><td>A permutation tile </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The constant to be subtracted </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the different between the elements of <code>this</code> and <code>value</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01350">1350</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a78564b48b7777a611ab711489b54849e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78564b48b7777a611ab711489b54849e">&#9670;&nbsp;</a></span>subt() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::subt </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract <code>right</code> from this and return the result. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be subtracted from this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the different between the elements of <code>this</code> and <code>right</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01263">1263</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a4bc6d00597df4d0f48d92b46ec37679e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc6d00597df4d0f48d92b46ec37679e">&#9670;&nbsp;</a></span>subt() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Perm , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::subt </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract <code>right</code> from this and return the result permuted by <code>perm</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Perm</td><td>A permutation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be subtracted from this tensor </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the different between the elements of <code>this</code> and <code>right</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01283">1283</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="af5e08d5ee93b4007248ae0ae45159471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e08d5ee93b4007248ae0ae45159471">&#9670;&nbsp;</a></span>subt() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::subt </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtract <code>right</code> from this and return the result scaled by a scaling <code>factor</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be subtracted from this tensor </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the different between the elements of <code>this</code> and <code>right</code>, scaled by <code>factor</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01305">1305</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a0152022f08ae620245967e5b25bf18d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0152022f08ae620245967e5b25bf18d9">&#9670;&nbsp;</a></span>subt() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Scalar , typename Perm , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_numeric_v&lt; Scalar &gt; &amp;&amp;detail::is_permutation_v&lt; Perm &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::subt </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtract <code>right</code> from this and return the result scaled by a scaling <code>factor</code> and permuted by <code>perm</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
    <tr><td class="paramname">Perm</td><td>A permutation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be subtracted from this tensor </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the different between the elements of <code>this</code> and <code>right</code>, scaled by <code>factor</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01326">1326</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a8e44d414e05fe2fe09648ad9856ade68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e44d414e05fe2fe09648ad9856ade68">&#9670;&nbsp;</a></span>subt_to() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::subt_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract a constant from this tensor. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01386">1386</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a6732b912c2ce09fcf078d814f0ca8cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6732b912c2ce09fcf078d814f0ca8cb9">&#9670;&nbsp;</a></span>subt_to() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::subt_to </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract <code>right</code> from this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be subtracted from this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01361">1361</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="af9a421cd397418787307aac0d453a3d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a421cd397418787307aac0d453a3d7">&#9670;&nbsp;</a></span>subt_to() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;detail::is_numeric_v&lt; Scalar &gt;&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::subt_to </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract <code>right</code> from and scale this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be subtracted from this tensor </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01377">1377</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a31122a03a46628005e60ed0ad1494f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31122a03a46628005e60ed0ad1494f14">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sum of elements. </p>
<dl class="section return"><dt>Returns</dt><dd>The sum of all elements of this tensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l02030">2030</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ab7f33f8afac53cb621c12cac5e1d256a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f33f8afac53cb621c12cac5e1d256a">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap tensor data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tensor to swap with this </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00678">678</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a7e9f9ab3a09d88f89ac402fcf656e056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9f9ab3a09d88f89ac402fcf656e056">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename TileType  = Tensor_, typename  = detail::enable_if_trace_is_defined_t&lt;TileType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generalized tensor trace. </p>
<p>This function will compute the sum of the hyper diagonal elements of tensor. </p><dl class="section return"><dt>Returns</dt><dd>The trace of this tensor </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When this tensor is empty. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01975">1975</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a436d7001abd661cec40f412138d6defd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436d7001abd661cec40f412138d6defd">&#9670;&nbsp;</a></span>unary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::unary </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use a unary, element wise operation to construct a new tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The unary operation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The unary, element-wise operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> of the new tensor is equal to <code>op(*this[i])</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When this tensor is empty. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01018">1018</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_tiled_array_1_1_tensor_a436d7001abd661cec40f412138d6defd_icgraph.png" border="0" usemap="#aclass_tiled_array_1_1_tensor_a436d7001abd661cec40f412138d6defd_icgraph" alt=""/></div>
<map name="class_tiled_array_1_1_tensor_a436d7001abd661cec40f412138d6defd_icgraph" id="aclass_tiled_array_1_1_tensor_a436d7001abd661cec40f412138d6defd_icgraph">
<area shape="rect" title="Use a unary, element wise operation to construct a new tensor." alt="" coords="233,136,372,177"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a5aa248d8fc5421a3403e9eee7e47fc4a" title="Add a constant to a copy of this tensor." alt="" coords="17,5,173,47"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a90085facd751fa8fd4eff4aa4b1d73ef" title="Create a negated copy of this tensor." alt="" coords="17,71,173,112"/>
<area shape="rect" href="class_tiled_array_1_1_sparse_shape.html#ae644157183f2741224c5fa26ed1f0aef" title="Scale shape." alt="" coords="5,136,185,177"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a199903e3d39e1eaa85f6f3a582bde77e" title="Construct a scaled copy of this tensor." alt="" coords="12,201,179,243"/>
<area shape="rect" href="class_tiled_array_1_1_tensor.html#a1f907f15ed5a44df959cfccc950368ac" title="Use a unary, element wise operation to construct a new, permuted tensor." alt="" coords="11,267,180,308"/>
</map>
</div>

</div>
</div>
<a id="a1f907f15ed5a44df959cfccc950368ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f907f15ed5a44df959cfccc950368ac">&#9670;&nbsp;</a></span>unary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;typename Op , typename Perm , typename  = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::unary </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use a unary, element wise operation to construct a new, permuted tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The unary operation type </td></tr>
    <tr><td class="paramname">Perm</td><td>A permutation tile </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The unary operation </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A permuted tensor with elements that have been modified by <code>op</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When this tensor is empty. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>The dimension of <code>perm</code> does not match that of this tensor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01034">1034</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>TiledArray/conversions/<a class="el" href="foreach_8h_source.html">foreach.h</a></li>
<li>TiledArray/tensor/<a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a></li>
</ul>
</div><!-- contents -->

<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
    Generated at Sat Apr 24 2021 05:44:23 for <a href="https://https://github.com/ValeevGroup/tiledarray/">TiledArray</a>
    1.0.0 by &#160;<a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.20
</small></address>
</body>
<script type="text/javascript" src="doxy-boot.js"></script>
</html>
