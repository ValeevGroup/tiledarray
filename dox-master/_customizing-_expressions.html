<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.20"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>TiledArray: Customizing TiledArray Expressions</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
        <script type="text/javascript" src="jquery.smartmenus.js"></script>
        <!-- SmartMenus jQuery Bootstrap Addon -->
        <script type="text/javascript" src="jquery.smartmenus.bootstrap.js"></script>
        <!-- SmartMenus jQuery plugin -->
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">TiledArray 1.0.0</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="userguide.html"><span>User&#160;Guide</span></a></li>
      <li><a href="usergroup0.html"><span>Programmer&#160;Guides</span></a></li>
      <li><a href="usergroup1.html"><span>Source&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Customizing <a class="el" href="namespace_tiled_array.html">TiledArray</a> Expressions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__home_travis_build_ValeevGroup_tiledarray_doc_dox_dev_Customizing-Expressions"></a>End-user interface of <a class="el" href="namespace_tiled_array.html">TiledArray</a> is a Domain-Specific Language (DSL), embedded in C++, for performing basic arithmetic and user-defined operations on <code>DistArray</code> objects. For example, contraction of order-3 tensors to produce an order-2 tensor can be expressed as </p><div class="fragment"><div class="line">TArray&lt;float&gt; a, b, c;</div>
<div class="line"><span class="comment">// initialization of order-3 tensors a, b is not shown</span></div>
<div class="line"> </div>
<div class="line">c(<span class="stringliteral">&quot;i,j&quot;</span>) = a(<span class="stringliteral">&quot;i,k,l&quot;</span>) * b(<span class="stringliteral">&quot;k,j,l&quot;</span>); <span class="comment">// Einstein notation described in https://en.wikipedia.org/wiki/Tensor_contraction</span></div>
</div><!-- fragment --><p>Even such a simple expression is implemented as a sequence of elementary operations, such as permutation and tensor contraction; understanding what happens under the hood is important for writing optimized <a class="el" href="namespace_tiled_array.html">TiledArray</a> code. Furthermore, <a class="el" href="namespace_tiled_array.html">TiledArray</a> DSL is extensible: users can write their own expressions to provide custom functions or optimizations. Understanding how expressions are evaluated is needed for such customizations.</p>
<p>This document is intended for users who</p>
<ol type="1">
<li>want to understand how <a class="el" href="namespace_tiled_array.html">TiledArray</a> DSL expressions are evaluated so that they can can control and optimize the evaluation of <a class="el" href="namespace_tiled_array.html">TiledArray</a> expressions, or</li>
<li>want to understand how to extend the DSL to suit their needs.</li>
</ol>
<h1>Implementation</h1>
<p><a class="el" href="namespace_tiled_array.html">TiledArray</a> DSL is built using the <a href="https://en.wikipedia.org/wiki/Expression_templates">expression template</a> idiom. Lazy evaluation of DSL expressions allows to (heuristically) optimize their evaluation by minimizing the number of permutations, minimizing memory accesses, minimizing temporary storage, and combining arithmetic operations; DSL does NOT perform more extensive term rewriting, such as operation reordering, factorization (strength reduction), or common subexpression elimination. Such task can be performed by the user (or, by an optimizing compiler), provided sufficient understanding of how the <a class="el" href="namespace_tiled_array.html">TiledArray</a> DSL expressions are evaluated.</p>
<h2>DSL Overview</h2>
<p>DSL expressions are evaluated in a multi-stage process, each step of which can be overridden to suit your needs.</p>
<ol type="1">
<li><b>construct an expression object</b>: expression objects are the nodes of the <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a> describing a composite expression</li>
<li><b>construct expression engine</b>: expression engines compute the metadata needed to evaluate the expression, such as the following properties of the result:<ol type="a">
<li>index list</li>
<li>structure<ol type="i">
<li><code>Permutation</code></li>
<li><code>TiledRange</code></li>
<li>shape</li>
</ol>
</li>
<li>data distribution<ol type="i">
<li>world</li>
<li>process map</li>
</ol>
</li>
</ol>
</li>
<li><b>evaluate the expression</b>: decompose expression into a set of tasks and submit these tasks to the task queue<ol type="a">
<li>tile operation</li>
<li>construct the distributed evaluator</li>
<li>schedule tile evaluation tasks</li>
</ol>
</li>
</ol>
<h2>Expression Interface</h2>
<p>Expression objects capture the minimum amount of information required to define the operation. Namely, the expression objects capture the syntax of expressions and do not deal with other details (such as how the expression is actually evaluated, sizes of intermediate quantities, etc.). Together the objects represent an Abstract Syntax Tree representation of an expression. Since the expression objects only capture compile-time syntax of an expression, runtime evaluation of the expression involves converting AST to a tree of objects (engines) that contain the information necessary to actually evaluate the expression at runtime (see the Engine Interface section for more details).</p>
<p>There are three basic types of expression objects:</p>
<ol type="1">
<li>leaf &ndash; no arguments (e.g. an <code>Array</code> + index list)</li>
<li>unary &ndash; one argument (e.g. negation)</li>
<li>binary &ndash; two arguments (e.g. addition)</li>
</ol>
<p>Non-leaf expression objects in <a class="el" href="namespace_tiled_array.html">TiledArray</a> keep track of the argument expressions and expresson metadata (such as scaling factors). Leaf expression objects keep track of the target <code>DistArray</code> object to which the expression is bound to and the corresponding Einstein convention annotation (if any).</p>
<h3>Expression Example Walkthrough</h3>
<p>To understand how expressions are represented and then evaluated let's consider a simple example:</p>
<div class="fragment"><div class="line">c(<span class="stringliteral">&quot;i,j&quot;</span>) = a(<span class="stringliteral">&quot;i,k,l&quot;</span>) * b(<span class="stringliteral">&quot;k,j,l&quot;</span>); <span class="comment">// contraction over indices k and l</span></div>
</div><!-- fragment --><p>Here we assume that <code>a</code>, <code>b</code>, are <code>c</code> are declared elsewhere as <code>DistArray</code> objects, and <code>a</code> and <code>b</code> have been initialized appropriately.</p>
<p>Since TA DSL is embedded into C++, evaluation of this expression follows C++'s operator precedence <a href="https://en.cppreference.com/w/cpp/language/operator_precedence">rules</a>, which for this case amounts to:</p>
<ol type="1">
<li>Function call operator (<code>TsrArray&lt;float&gt;::operator()(const std::string&amp;)</code>)</li>
<li>Multiplication operator</li>
<li>Direct assignment</li>
</ol>
<h4>Step 1: Form TsrExpr Instances</h4>
<p>The call operator, <code>TArray&lt;float&gt;::operator()(const std::string&amp;)</code>, creates an instance of the <code>TsrExpr&lt;TArray&lt;float&gt;&gt;</code> class. Each instance holds the string indices provided to the call operator as well as a reference to the <code>TArray&lt;float&gt;</code> instance whose call operator was invoked. If we define some temporaries according to:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> tensor_expr = TsrExpr&lt;TArray&lt;float&gt;&gt;; <span class="comment">// the full type of the TsrExpr</span></div>
<div class="line">tensor_expr annotated_c = c(<span class="stringliteral">&quot;i,j&quot;</span>);</div>
<div class="line">tensor_expr annotated_a = a(<span class="stringliteral">&quot;i,k,l&quot;</span>);</div>
<div class="line">tensor_expr annotated_b = b(<span class="stringliteral">&quot;k,j,l&quot;</span>);</div>
</div><!-- fragment --><p>then conceptually our example becomes:</p>
<div class="fragment"><div class="line">TArray&lt;float&gt; a, b, c; <span class="comment">// a and b are assumed initialized, c initialized below</span></div>
<div class="line"><span class="keyword">using</span> tensor_expr = TsrExpr&lt;TArray&lt;float&gt;&gt;; <span class="comment">// the full type of the TsrExpr</span></div>
<div class="line">tensor_expr annotated_c = c(<span class="stringliteral">&quot;i,j&quot;</span>);</div>
<div class="line">tensor_expr annotated_a = a(<span class="stringliteral">&quot;i,k,l&quot;</span>);</div>
<div class="line">tensor_expr annotated_b = b(<span class="stringliteral">&quot;k,j,l&quot;</span>);</div>
<div class="line">annotated_c = annotated_a * annotated_b;</div>
</div><!-- fragment --><p>This step largely serves as the kicking-off point for creating the abstract syntax tree (AST) and does little else.</p>
<h4>Step 2: Multiplication</h4>
<p>Step 1 formed leaves for the AST, step 2 creates a branch by resolving the multiplication operator. In this case <code>operator*(const Expr&lt;tensor_expr&gt;&amp;,const Expr&lt;tensor_expr&gt;&amp;)</code> is selected. The resulting <code>MultExpr&lt;tensor_expr, tensor_expr&gt;</code> instance contains references to <code>annotated_a</code> and <code>annotated_b</code>, but again little else has happened. If we define:</p>
<div class="fragment"><div class="line">MultExpr&lt;tensor_expr, tensor_expr&gt; a_x_b = annotated_a * annotated_b;</div>
</div><!-- fragment --><p>then conceptually our example becomes:</p>
<div class="fragment"><div class="line">TArray&lt;float&gt; a, b, c; <span class="comment">// a and b are assumed initialized, c initialized below</span></div>
<div class="line"><span class="keyword">using</span> tensor_expr = TsrExpr&lt;TArray&lt;float&gt;&gt;; <span class="comment">// the full type of the TsrExpr</span></div>
<div class="line">tensor_expr annotated_c = c(<span class="stringliteral">&quot;i,j&quot;</span>);</div>
<div class="line">tensor_expr annotated_a = a(<span class="stringliteral">&quot;i,k,l&quot;</span>);</div>
<div class="line">tensor_expr annotated_b = b(<span class="stringliteral">&quot;k,j,l&quot;</span>);</div>
<div class="line">MultExpr&lt;tensor_expr, tensor_expr&gt; a_x_b = annotated_a * annotated_b;</div>
<div class="line">annotated_c = a_x_b;</div>
</div><!-- fragment --><h4>Step 3: Assignment</h4>
<p>This is where the magic happens. For our particular example the overload that gets called is <code>annotated_c</code>'s <code>operator=</code>, which has the signature:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> D&gt;</div>
<div class="line">TArray&lt;float&gt; TsrExpr&lt;TArray&lt;float&gt;&gt;::operator=(<span class="keyword">const</span> Expr&lt;D&gt;&amp;);</div>
</div><!-- fragment --><p>This passes tensor <code>c</code> to the provided expression's <code>eval_to</code> member. Inside <code>eval_to</code>:</p>
<ol type="1">
<li>An engine is made</li>
<li>The engine is initialized</li>
<li>The engine generates a distributed evaluator</li>
<li>The distributed evaluator is run</li>
<li>Data is moved from the distributed evaluator to <code>c</code>.</li>
</ol>
<p>These five steps contain a lot of detail which we are glossing over at this level. More details pertaining to how the engine works can be found here.</p>
<h4>Generalizing to More Complicated Expressions</h4>
<p>The above three steps can be generalized to:</p>
<ol type="1">
<li>Form leaves</li>
<li>Form branches</li>
<li>Evaluate resulting tree</li>
</ol>
<p>Step 1, form leaves, converts DSL-objects into expressions which can enter into the expression layer. With the leaves formed, step 2 creates the branches by combining: leaves with leaves, leaves with branches, and branches with branches. The formation of branches is not associative and the exact structure is dictated by C++'s operator precedence rules. AST formation terminates when the code has been wrapped up into a single AST and that AST is being assigned to a <code>TsrExpr</code> instance. Once AST formation is complete, step 3 occurs which is to evaluate the AST and assign the result to the <code>TsrExpr</code>.</p>
<h3>Custom Expression Examples</h3>
<p>To help you implement your own custom expressions copy and paste the appropriate expression code templates below and fill in the implementation details.</p>
<h4>Example: Custom Leaf Expression</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tiledarray_8h.html">tiledarray.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Forward declarations</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>MyLeafExpression;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>MyLeafEngine;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespace_tiled_array.html">TiledArray</a> {</div>
<div class="line">  <span class="keyword">namespace </span>expressions {</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define expression types</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> A&gt;</div>
<div class="line">    <span class="keyword">struct </span>ExprTrait&lt;MyLeafExpression&lt;A&gt; &gt; {</div>
<div class="line">      <span class="keyword">typedef</span> A array_type; <span class="comment">// The Array type</span></div>
<div class="line">      <span class="keyword">typedef</span> MyLeafEngine&lt;A&gt; engine_type; <span class="comment">// Expression engine type</span></div>
<div class="line">      <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="struct_tiled_array_1_1detail_1_1scalar__type.html">TiledArray::detail::scalar_type&lt;A&gt;::type</a> scalar_type;  <span class="comment">// Tile scalar type</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">  } <span class="comment">// namespace expressions</span></div>
<div class="line">} <span class="comment">// namespace TiledArray</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A&gt;</div>
<div class="line"><span class="keyword">class </span>MyLeafExpression :</div>
<div class="line">    <span class="keyword">public</span> Expr&lt;MyLeafExpression&lt;A&gt; &gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">typedef</span> MyLeafExpression&lt;A&gt; MyLeafExpression_; <span class="comment">// This class type</span></div>
<div class="line">  <span class="keyword">typedef</span> Expr&lt;MyLeafExpression_&gt; Expr_; <span class="comment">// Expression base type</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="struct_tiled_array_1_1expressions_1_1_expr_trait.html">TiledArray::expressions::ExprTrait&lt;MyLeafExpression_&gt;::array_type</a></div>
<div class="line">      array_type; <span class="comment">// The array type</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="struct_tiled_array_1_1expressions_1_1_expr_trait.html">TiledArray::expressions::ExprTrait&lt;MyLeafExpression_&gt;::engine_type</a></div>
<div class="line">      engine_type; <span class="comment">// Expression engine type</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> array_type&amp; array_; </div>
<div class="line">  std::string annotation_; </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Not allowed</span></div>
<div class="line">  MyLeafExpression_&amp; operator=(MyLeafExpression_&amp;);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  MyLeafExpression(<span class="keyword">const</span> array_type&amp; array, <span class="keyword">const</span> std::string&amp; annotation) :</div>
<div class="line">    Expr_(), array_(array), annotation_(annotation) { }</div>
<div class="line"> </div>
<div class="line">  MyLeafExpression(<span class="keyword">const</span> MyLeafExpression_&amp; other) :</div>
<div class="line">    array_(other.array_), annotation_(other.annotation_)</div>
<div class="line">  { }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> array_type&amp; array()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> array_; }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::string&amp; annotation()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> annotation_; }</div>
<div class="line"> </div>
<div class="line">}; <span class="comment">// class MyLeafExpression</span></div>
</div><!-- fragment --><h4>Example: Custom Unary Expression</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tiledarray_8h.html">tiledarray.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Forward declarations</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>MyUnaryExpression;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>MyUnaryEngine;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespace_tiled_array.html">TiledArray</a> {</div>
<div class="line">  <span class="keyword">namespace </span>expressions {</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define expression types</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arg&gt;</div>
<div class="line">    <span class="keyword">struct </span>ExprTrait&lt;MyUnaryExpression&lt;Arg&gt; &gt; : </div>
<div class="line">      <span class="keyword">public</span> UnaryExprTrait&lt;Arg, MyUnaryEngine&gt; </div>
<div class="line">    { };</div>
<div class="line"> </div>
<div class="line">  } <span class="comment">// namespace expressions</span></div>
<div class="line">} <span class="comment">// namespace TiledArray</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// My expression object</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arg&gt;</div>
<div class="line"><span class="keyword">class </span>MyUnaryExpression : <span class="keyword">public</span> UnaryExpr&lt;MyUnaryExpression&lt;Arg&gt; &gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">typedef</span> MyUnaryExpression &lt;Arg&gt; MyUnaryExpression_; <span class="comment">// This class type</span></div>
<div class="line">  <span class="keyword">typedef</span> UnaryExpr&lt;MyUnaryExpression_&gt; UnaryExpr_; <span class="comment">// Unary base class type</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="struct_tiled_array_1_1expressions_1_1_expr_trait.html">TiledArray::expressions::ExprTrait&lt; MyUnaryExpression_ &gt;::argument_type</a></div>
<div class="line">      argument_type; <span class="comment">// The argument expression type</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="struct_tiled_array_1_1expressions_1_1_expr_trait.html">TiledArray::expressions::ExprTrait&lt; MyUnaryExpression_ &gt;::engine_type</a></div>
<div class="line">      engine_type; <span class="comment">// Expression engine type</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Not allowed</span></div>
<div class="line">  MyUnaryExpression_&amp; operator=(<span class="keyword">const</span> MyUnaryExpression_&amp;);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Constructors</span></div>
<div class="line"> </div>
<div class="line">  MyUnaryExpression(<span class="keyword">const</span> argument_type&amp; arg) :</div>
<div class="line">    UnaryExpr_(arg)</div>
<div class="line">  { }</div>
<div class="line"> </div>
<div class="line">  MyUnaryExpression(<span class="keyword">const</span> MyUnaryExpression_&amp; other) :</div>
<div class="line">    UnaryExpr_(other)</div>
<div class="line">  { }</div>
<div class="line"> </div>
<div class="line">}; <span class="comment">// class MyScalingExpr</span></div>
</div><!-- fragment --><h4>Example: Custom Binary Expression</h4>
<p>Work in progress.</p>
<h2>Expression Engine Interface</h2>
<p>Engine objects result from interpreting the AST using the runtime data (such as annotation strings, tensor ranks, etc.). They form a tree that represents a ready-to-evaluate expression. Evaluation of the engine tree is accomplished by traversing the tree and generating distributed evaluator objects that implement particular operations as DAGs of tasks.</p>
<h3>Example Walkthrough</h3>
<p>Let's consider the same expression example as earlier to understand how engines are constructed and what they do: </p><div class="fragment"><div class="line">TArray&lt;float&gt; a, b, c; <span class="comment">// a and b are assumed initialized, c initialized below</span></div>
<div class="line">c(<span class="stringliteral">&quot;i,j&quot;</span>) = a(<span class="stringliteral">&quot;i,k,l&quot;</span>) * b(<span class="stringliteral">&quot;k,j,l&quot;</span>); <span class="comment">// contraction over indices k and l</span></div>
</div><!-- fragment --><p>The first engine is created when the AST is assigned to <code>c("i,j")</code>. Inside the assignment operator, the <code>eval_to</code> member of the AST is invoked (and provided <code>c</code>). For our present purposes <code>eval_to</code> does 3 relevant things:</p>
<ol type="1">
<li>It constructs the overall engine</li>
<li>It initializes the overall engine</li>
<li>It creates a distributed evaluator</li>
</ol>
<p>For reference, in the contraction example, the overall engine is of type:</p>
<div class="fragment"><div class="line"><span class="comment">// The type of the engine powering the TsrExpr instances</span></div>
<div class="line"><span class="keyword">using</span> tsr_engine = TsrEngine&lt;TArray&lt;float&gt;, Tensor&lt;float&gt;, <span class="keyword">true</span>&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The overall engine type of the equation</span></div>
<div class="line">MultEngine&lt;tsr_engine, tsr_engine, Tensor&lt;float&gt;&gt;</div>
</div><!-- fragment --><h4>Step 1: Construction</h4>
<p>The input to constructor for the overall engine is the overall expression to be evaluated. The constructor itself does little aside from setting the default values and propagating the map from the input expression to the engine.</p>
<h4>Step 2: Initialization</h4>
<p>The overall engine's <code>init</code> member is called and provided: the parallel runtime, the process map, and a <code>IndexList</code> instance containing the final tensor indices (<em>i.e.</em>, the indices of the tensor being assigned to). The <code>init</code> member function ultimately calls:</p>
<ol type="1">
<li><code>init_indices</code></li>
<li><code>init_struct</code></li>
<li><code>init_distribution</code></li>
</ol>
<p>in that order.</p>
<h5>Step 2a: Variable Initialization</h5>
<p>Variable initialization starts in <code>MultEngine::init_indices(const IndexList&amp; target_indices)</code>. The purpose of the <code>init_indices</code> is to propagate the target indices (in this case, <code>{"i","j"}</code>) for each computation step down the tree; the goal is to minimize the number of permutations (layout changes) needed to evaluate the tree (this is complicated by the fact that some operations can permute their arguments and/or result implicitly, namely GEMM). N.B. For some operations (e.g., reductions) the target index list is empty, hence the <code>init_indices()</code> overload is used in that case.</p>
<p>Calling <code>init_indices(target_indices)</code> on the top engine in the engine tree calls the <code>init_indices</code> recursively on its descendants; in this case, <code>init_indices</code> will be invoked for the engines of the expressions on the left and right sides of the <code>*</code> operator (since the left and right arguments are leaves of the AST, these will be no-ops). After giving the expressions on the left and right a chance to initialize their indices the indices for the left and right side are used to determine what sort of multiplication this is (a contraction or a Hadamard-product) and the appropriate base class's <code>perm_indices</code> is then called.</p>
<h5>Step 2b: Struct Initialization</h5>
<p>This function initializes the details for the resulting tensor, specifically:</p>
<ol type="1">
<li>the permutation to go from the result of the expression to the result tensor</li>
<li>the tiling of the result tensor</li>
<li>the sparsity of the resulting tensor</li>
</ol>
<p>Within the <code>MultEngine</code> instance this is done first for both the left and right expressions. Next, taking the type of multiplication occurring into account, the results of calling <code>struct_init</code> on the left and right expressions are combined to generate the details of the tensor resulting from the multiplication.</p>
<h4>Step 3: Make a Distributed Evaluator</h4>
<p>For our <code>MultEngine</code> the type of the distributed evaluator is <code>DistEval&lt;Tensor&lt;float&gt;, DensePolicy&gt;</code>. Again this process is repeated recursively for the left and right expressions in <code>MultEngine</code> resulting in the distributed evaluators for the left and right expressions, which are then forwarded to the PIMPL for the DistEval returned by <code>MultEngine</code>. The distributed evaluator is what actually runs the operation.</p>
<h1>Complete Example: Multiplication by scalar</h1>
<p>This example demonstrates how to implement scaling expressions by a scalar. The <a class="el" href="namespace_tiled_array.html">TiledArray</a> tile operation <code>Scal</code> is used for demonstration purposes, but you are free to substitute your own tile operation. See the <a class="el" href="_customizing-_arrays.html#User-Defined-Tiles">User Defined Tiles</a> section for more details.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tiledarray_8h.html">tiledarray.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Forward declarations</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>MyScalingExpr;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>MyScalingEngine;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespace_tiled_array.html">TiledArray</a> {</div>
<div class="line">  <span class="keyword">namespace </span>expressions {</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define engine types</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arg&gt;</div>
<div class="line">    <span class="keyword">struct </span>EngineTrait&lt;MyScalingEngine&lt;Arg&gt; &gt; :</div>
<div class="line">      <span class="keyword">public</span> UnaryEngineTrait&lt;Arg, TiledArray::math::Scal&gt;</div>
<div class="line">    { };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define expression types</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arg&gt;</div>
<div class="line">    <span class="keyword">struct </span>ExprTrait&lt;ScalExpr&lt;Arg&gt; &gt; : </div>
<div class="line">      <span class="keyword">public</span> UnaryExprTrait&lt;Arg, ScalEngine&gt; </div>
<div class="line">    { };</div>
<div class="line"> </div>
<div class="line">  } <span class="comment">// namespace expressions</span></div>
<div class="line">} <span class="comment">// namespace TiledArray</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// My scaling expression engine</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arg&gt;</div>
<div class="line"><span class="keyword">class </span>MyScalingEngine : <span class="keyword">public</span> UnaryEngine&lt;MyScalingEngine&lt;Arg&gt; &gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// Class hierarchy typedefs</span></div>
<div class="line">  <span class="keyword">typedef</span> MyScalingEngine&lt;Arg&gt; MyScalingEngine_; <span class="comment">// This class type</span></div>
<div class="line">  <span class="keyword">typedef</span> UnaryEngine&lt;MyScalingEngine_&gt; UnaryEngine_; <span class="comment">// Unary expression engine base type</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> UnaryEngine_::ExprEngine_ ExprEngine_; <span class="comment">// Expression engine base type</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Argument typedefs</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> EngineTrait&lt;MyScalingEngine_&gt;::argument_type argument_type; <span class="comment">// The argument expression engine type</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Operational typedefs</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="struct_tiled_array_1_1expressions_1_1_engine_trait.html">TiledArray::expressions::EngineTrait&lt;MyScalingEngine_&gt;::value_type</a></div>
<div class="line">      value_type; <span class="comment">// The result tile type</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="struct_tiled_array_1_1expressions_1_1_engine_trait.html">TiledArray::expressions::EngineTrait&lt;MyScalingEngine_&gt;::scalar_type</a></div>
<div class="line">      scalar_type; <span class="comment">// Tile scalar type</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="struct_tiled_array_1_1expressions_1_1_engine_trait.html">TiledArray::expressions::EngineTrait&lt;MyScalingEngine_&gt;::op_type</a></div>
<div class="line">      op_type; <span class="comment">// The tile operation type</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="struct_tiled_array_1_1expressions_1_1_engine_trait.html">TiledArray::expressions::EngineTrait&lt;MyScalingEngine_&gt;::policy</a></div>
<div class="line">      policy; <span class="comment">// The result policy type</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="struct_tiled_array_1_1expressions_1_1_engine_trait.html">TiledArray::expressions::EngineTrait&lt;MyScalingEngine_&gt;::dist_eval_type</a></div>
<div class="line">      dist_eval_type; <span class="comment">// The distributed evaluator type</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Meta data typedefs</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="struct_tiled_array_1_1expressions_1_1_engine_trait.html">TiledArray::expressions::EngineTrait&lt;MyScalingEngine_&gt;::size_type</a></div>
<div class="line">      size_type; <span class="comment">// Size type</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="struct_tiled_array_1_1expressions_1_1_engine_trait.html">TiledArray::expressions::EngineTrait&lt;MyScalingEngine_&gt;::trange_type</a></div>
<div class="line">      trange_type; <span class="comment">// Tiled range type</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="struct_tiled_array_1_1expressions_1_1_engine_trait.html">TiledArray::expressions::EngineTrait&lt;MyScalingEngine_&gt;::shape_type</a></div>
<div class="line">      shape_type; <span class="comment">// Shape type</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="struct_tiled_array_1_1expressions_1_1_engine_trait.html">TiledArray::expressions::EngineTrait&lt;MyScalingEngine_&gt;::pmap_interface</a></div>
<div class="line">      pmap_interface; <span class="comment">// Process map interface type</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> </div>
<div class="line">  scalar_type factor_; <span class="comment">// Scaling factor</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Constructor</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> A&gt;</div>
<div class="line">  MyScalingEngine(<span class="keyword">const</span> MyScalingExpr&lt;A&gt;&amp; expr) :</div>
<div class="line">    UnaryEngine_(expr), factor_(expr.factor())</div>
<div class="line">  { }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Non-permuting shape factory function</span></div>
<div class="line">  shape_type <a class="code" href="namespace_tiled_array_1_1detail.html#ab46d9580d4d2230d0e34ee0ccfdafc72">make_shape</a>()<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> UnaryEngine_::arg_.shape().scale(factor_);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Permuting shape factory function</span></div>
<div class="line">  shape_type <a class="code" href="namespace_tiled_array_1_1detail.html#ab46d9580d4d2230d0e34ee0ccfdafc72">make_shape</a>(<span class="keyword">const</span> Permutation&amp; perm)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> UnaryEngine_::arg_.shape().scale(factor_, perm);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Non-permuting tile operation factory function</span></div>
<div class="line">  op_type make_tile_op()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> op_type(factor_); }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Permuting tile operation factory function</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Perm,</div>
<div class="line">            <span class="keyword">typename</span> = std::enable_if_t&lt;detail::is_permutation_v&lt;Perm&gt;&gt;&gt;</div>
<div class="line">  op_type make_tile_op(<span class="keyword">const</span> Perm&amp; perm)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> op_type(perm, factor_);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Expression identification tag used for printing</span></div>
<div class="line">  std::string make_tag()<span class="keyword"> const </span>{</div>
<div class="line">    std::stringstream ss;</div>
<div class="line">    ss &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; factor_ &lt;&lt; <span class="stringliteral">&quot;] &quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> ss.str();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">}; <span class="comment">// class MyScalingEngine</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Scaling expression</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arg&gt;</div>
<div class="line"><span class="keyword">class </span>ScalExpr : <span class="keyword">public</span> UnaryExpr&lt;ScalExpr&lt;Arg&gt; &gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">typedef</span> MyScalingExpr&lt;Arg&gt; MyScalingExpr_; <span class="comment">// This class type</span></div>
<div class="line">  <span class="keyword">typedef</span> UnaryExpr&lt;MyScalingExpr_&gt; UnaryExpr_; <span class="comment">// Unary base class type</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="struct_tiled_array_1_1expressions_1_1_expr_trait.html">TiledArray::expressions::ExprTrait&lt;MyScalingExpr_&gt;::argument_type</a> argument_type; <span class="comment">// The argument expression type</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="struct_tiled_array_1_1expressions_1_1_expr_trait.html">TiledArray::expressions::ExprTrait&lt;MyScalingExpr_&gt;::engine_type</a> engine_type; <span class="comment">// Expression engine type</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="struct_tiled_array_1_1expressions_1_1_expr_trait.html">TiledArray::expressions::ExprTrait&lt;MyScalingExpr_&gt;::scalar_type</a> scalar_type; <span class="comment">// Scalar type</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> </div>
<div class="line">  scalar_type factor_; </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Not allowed</span></div>
<div class="line">  ScalExpr_&amp; operator=(<span class="keyword">const</span> ScalExpr_&amp;);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Constructors</span></div>
<div class="line"> </div>
<div class="line">  MyScalingExpr(<span class="keyword">const</span> argument_type&amp; arg, <span class="keyword">const</span> scalar_type factor) :</div>
<div class="line">    UnaryExpr_(arg), factor_(factor)</div>
<div class="line">  { }</div>
<div class="line"> </div>
<div class="line">  MyScalingExpr(<span class="keyword">const</span> MyScalingExpr_&amp; other, <span class="keyword">const</span> scalar_type factor) :</div>
<div class="line">    UnaryExpr_(other), factor_(other.factor_ * factor)</div>
<div class="line">  { }</div>
<div class="line"> </div>
<div class="line">  MyScalingExpr(<span class="keyword">const</span> MyScalingExpr_&amp; other) : UnaryExpr_(other), factor_(other.factor_) { }</div>
<div class="line"> </div>
<div class="line">  scalar_type factor()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> factor_; }</div>
<div class="line"> </div>
<div class="line">}; <span class="comment">// class MyScalingExpr</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Expression object factory functions</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> D, <span class="keyword">typename</span> Scalar&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> madness::enable_if&lt;TiledArray::detail::is_numeric&lt;Scalar&gt;, ScalExpr&lt;D&gt; &gt;::type</div>
<div class="line"><a class="code" href="namespace_tiled_array_1_1expressions.html#ae057e39af36bedb96b3d8b5e6001bde1">operator*</a>(<span class="keyword">const</span> Expr&lt;D&gt;&amp; expr, <span class="keyword">const</span> Scalar&amp; factor) {</div>
<div class="line">  <span class="keywordflow">return</span> ScalExpr&lt;D&gt;(expr.derived(), factor);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> D, <span class="keyword">typename</span> Scalar&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> madness::enable_if&lt;TiledArray::detail::is_numeric&lt;Scalar&gt;, ScalExpr&lt;D&gt; &gt;::type</div>
<div class="line"><a class="code" href="namespace_tiled_array_1_1expressions.html#ae057e39af36bedb96b3d8b5e6001bde1">operator*</a>(<span class="keyword">const</span> Scalar&amp; factor, <span class="keyword">const</span> Expr&lt;D&gt;&amp; expr) {</div>
<div class="line">  <span class="keywordflow">return</span> ScalExpr&lt;D&gt;(expr.derived(), factor);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arg, <span class="keyword">typename</span> Scalar&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> madness::enable_if&lt;TiledArray::detail::is_numeric&lt;Scalar&gt;, ScalExpr&lt;Arg&gt; &gt;::type</div>
<div class="line"><a class="code" href="namespace_tiled_array_1_1expressions.html#ae057e39af36bedb96b3d8b5e6001bde1">operator*</a>(<span class="keyword">const</span> ScalExpr&lt;Arg&gt;&amp; expr, <span class="keyword">const</span> Scalar&amp; factor) {</div>
<div class="line">  <span class="keywordflow">return</span> ScalExpr&lt;Arg&gt;(expr, factor);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arg, <span class="keyword">typename</span> Scalar&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> madness::enable_if&lt;TiledArray::detail::is_numeric&lt;Scalar&gt;, ScalExpr&lt;Arg&gt; &gt;::type</div>
<div class="line"><a class="code" href="namespace_tiled_array_1_1expressions.html#ae057e39af36bedb96b3d8b5e6001bde1">operator*</a>(<span class="keyword">const</span> Scalar&amp; factor, <span class="keyword">const</span> ScalExpr&lt;Arg&gt;&amp; expr) {</div>
<div class="line">  <span class="keywordflow">return</span> ScalExpr&lt;Arg&gt;(expr, factor);</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="astruct_tiled_array_1_1expressions_1_1_engine_trait_html"><div class="ttname"><a href="struct_tiled_array_1_1expressions_1_1_engine_trait.html">TiledArray::expressions::EngineTrait</a></div><div class="ttdef"><b>Definition:</b> <a href="expr__engine_8h_source.html#l00041">expr_engine.h:41</a></div></div>
<div class="ttc" id="astruct_tiled_array_1_1detail_1_1scalar__type_html"><div class="ttname"><a href="struct_tiled_array_1_1detail_1_1scalar__type.html">TiledArray::detail::scalar_type</a></div><div class="ttdoc">Type trait for extracting the scalar type of tensors and arrays.</div><div class="ttdef"><b>Definition:</b> <a href="type__traits_8h_source.html#l00744">type_traits.h:744</a></div></div>
<div class="ttc" id="anamespace_tiled_array_1_1expressions_html_ae057e39af36bedb96b3d8b5e6001bde1"><div class="ttname"><a href="namespace_tiled_array_1_1expressions.html#ae057e39af36bedb96b3d8b5e6001bde1">TiledArray::expressions::operator*</a></div><div class="ttdeci">std::enable_if&lt; TiledArray::detail::is_numeric_v&lt; Scalar &gt;, ScalAddExpr&lt; Left, Right, Scalar &gt; &gt;::type operator*(const AddExpr&lt; Left, Right &gt; &amp;expr, const Scalar &amp;factor)</div><div class="ttdoc">Scaled-addition expression factor.</div><div class="ttdef"><b>Definition:</b> <a href="add__expr_8h_source.html#l00191">add_expr.h:191</a></div></div>
<div class="ttc" id="anamespace_tiled_array_html"><div class="ttname"><a href="namespace_tiled_array.html">TiledArray</a></div><div class="ttdef"><b>Definition:</b> <a href="array__impl_8cpp_source.html#l00028">array_impl.cpp:28</a></div></div>
<div class="ttc" id="atiledarray_8h_html"><div class="ttname"><a href="tiledarray_8h.html">tiledarray.h</a></div></div>
<div class="ttc" id="anamespace_tiled_array_1_1detail_html_ab46d9580d4d2230d0e34ee0ccfdafc72"><div class="ttname"><a href="namespace_tiled_array_1_1detail.html#ab46d9580d4d2230d0e34ee0ccfdafc72">TiledArray::detail::make_shape</a></div><div class="ttdeci">auto make_shape(World &amp;world, const TiledArray::TiledRange &amp;trange)</div></div>
<div class="ttc" id="astruct_tiled_array_1_1expressions_1_1_expr_trait_html"><div class="ttname"><a href="struct_tiled_array_1_1expressions_1_1_expr_trait.html">TiledArray::expressions::ExprTrait</a></div><div class="ttdef"><b>Definition:</b> <a href="expr_8h_source.html#l00053">expr.h:53</a></div></div>

<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
    Generated at Sat Apr 24 2021 05:44:22 for <a href="https://https://github.com/ValeevGroup/tiledarray/">TiledArray</a>
    1.0.0 by &#160;<a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.20
</small></address>
</body>
<script type="text/javascript" src="doxy-boot.js"></script>
</html>
