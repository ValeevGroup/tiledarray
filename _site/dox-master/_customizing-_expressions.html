<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.17"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>TiledArray: Customizing TiledArray Expressions</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
        <script type="text/javascript" src="jquery.smartmenus.js"></script>
        <!-- SmartMenus jQuery Bootstrap Addon -->
        <script type="text/javascript" src="jquery.smartmenus.bootstrap.js"></script>
        <!-- SmartMenus jQuery plugin -->
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">TiledArray 1.0.0-alpha.2</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="userguide.html"><span>User&#160;Guide</span></a></li>
      <li><a href="usergroup0.html"><span>Programmer&#160;Guides</span></a></li>
      <li><a href="usergroup1.html"><span>Source&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Customizing <a class="el" href="namespace_tiled_array.html">TiledArray</a> Expressions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>End-user interface of <a class="el" href="namespace_tiled_array.html">TiledArray</a> is a Domain-Specific Language (DSL), embedded in C++, for performing basic arithmetic and user-defined operations on <code>DistArray</code> objects. For example, contraction of order-3 tensors to produce an order-2 tensor can be expressed as </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">TArray&lt;float&gt; a, b, c;</div>
<div class="line">// initialization of order-3 tensors a, b is not shown</div>
<div class="line"> </div>
<div class="line">c(&quot;i,j&quot;) = a(&quot;i,k,l&quot;) * b(&quot;k,j,l&quot;); // Einstein notation described in https://en.wikipedia.org/wiki/Tensor_contraction</div>
</div><!-- fragment --><p>Even such a simple expression is implemented as a sequence of elementary operations, such as permutation and tensor contraction; understanding what happens under the hood is important for writing optimized <a class="el" href="namespace_tiled_array.html">TiledArray</a> code. Furthermore, <a class="el" href="namespace_tiled_array.html">TiledArray</a> DSL is extensible: users can write their own expressions to provide custom functions or optimizations. Understanding how expressions are evaluated is needed for such customizations.</p>
<p>This document is intended for users who</p>
<ol type="1">
<li>want to understand how <a class="el" href="namespace_tiled_array.html">TiledArray</a> DSL expressions are evaluated so that they can can control and optimize the evaluation of <a class="el" href="namespace_tiled_array.html">TiledArray</a> expressions, or</li>
<li>want to understand how to extend the DSL to suit their needs.</li>
</ol>
<h1>Implementation</h1>
<p><a class="el" href="namespace_tiled_array.html">TiledArray</a> DSL is built using the <a href="https://en.wikipedia.org/wiki/Expression_templates">expression template</a> idiom. Lazy evaluation of DSL expressions allows to (heuristically) optimize their evaluation by minimizing the number of permutations, minimizing memory accesses, minimizing temporary storage, and combining arithmetic operations; DSL does NOT more extensive term rewriting, such as operation reordering, factorization (strength reduction), or common subexpression elimination. Such task can be performed by the user (with help of an optimizing compiler), provided sufficient understanding of how the <a class="el" href="namespace_tiled_array.html">TiledArray</a> DSL expressions are evaluated.</p>
<h2>DSL Overview</h2>
<p>DSL expressions are evaluated in a multi-stage process, each step of which can be overridden to suit your needs.</p>
<ol type="1">
<li><b>construct an expression object</b>: expression objects are the nodes of the <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a> describing a composite expression</li>
<li><b>construct expression engine</b>: expression engines compute the metadata needed to evaluate the expression, such a the following properties of the result:<ol type="a">
<li>variable list</li>
<li>structure<ol type="i">
<li><code>Permutation</code></li>
<li><code>TiledRange</code></li>
<li>shape</li>
</ol>
</li>
<li>data distribution<ol type="i">
<li>world</li>
<li>process map</li>
</ol>
</li>
</ol>
</li>
<li><b>evaluate the expression</b>: decompose expression into a set of tasks and submit these tasks to the task queue<ol type="a">
<li>tile operation</li>
<li>construct the distributed evaluator</li>
<li>schedule tile evaluation tasks</li>
</ol>
</li>
</ol>
<h2>Expression Interface</h2>
<p>Expression objects contain the minimum amount of information required to define the operation. For example, expression objects in <a class="el" href="namespace_tiled_array.html">TiledArray</a> store <code>Array</code> objects, scaling factors, and argument expressions. Note, you can add or modify member variables, member functions, or constructors to suit the needs of your application.</p>
<p>There are three basic types of expression objects:</p>
<ol type="1">
<li>leaf &ndash; no arguments (e.g. an <code>Array</code> + variable list)</li>
<li>unary &ndash; one argument (e.g. negation)</li>
<li>binary &ndash; two arguments (e.g. addition)</li>
</ol>
<p><b>Note:</b> When you implement your own expression, you should copy and paste the appropriate the expression interface below and fill in the implementation details.</p>
<h3>Leaf Expression Interface</h3>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;tiledarray.h&gt;</div>
<div class="line"> </div>
<div class="line">// Forward declarations</div>
<div class="line">template &lt;typename&gt; class MyLeafExpression;</div>
<div class="line">template &lt;typename&gt; class MyLeafEngine;</div>
<div class="line"> </div>
<div class="line">namespace TiledArray {</div>
<div class="line">  namespace expressions {</div>
<div class="line"> </div>
<div class="line">    // Define expression types</div>
<div class="line">    template &lt;typename A&gt;</div>
<div class="line">    struct ExprTrait&lt;MyLeafExpression&lt;A&gt; &gt; {</div>
<div class="line">      typedef A array_type; // The Array type</div>
<div class="line">      typedef MyLeafEngine&lt;A&gt; engine_type; // Expression engine type</div>
<div class="line">      typedef typename TiledArray::detail::scalar_type&lt;A&gt;::type scalar_type;  // Tile scalar type</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">  } // namespace expressions</div>
<div class="line">} // namespace TiledArray</div>
<div class="line"> </div>
<div class="line">/// My leaf expression objects</div>
<div class="line">template &lt;typename A&gt;</div>
<div class="line">class MyLeafExpression :</div>
<div class="line">    public Expr&lt;MyLeafExpression&lt;A&gt; &gt;</div>
<div class="line">{</div>
<div class="line">public:</div>
<div class="line">  typedef MyLeafExpression&lt;A&gt; MyLeafExpression_; // This class type</div>
<div class="line">  typedef Expr&lt;MyLeafExpression_&gt; Expr_; // Expression base type</div>
<div class="line">  typedef typename TiledArray::expressions::ExprTrait&lt;MyLeafExpression_&gt;::array_type</div>
<div class="line">      array_type; // The array type</div>
<div class="line">  typedef typename TiledArray::expressions::ExprTrait&lt;MyLeafExpression_&gt;::engine_type</div>
<div class="line">      engine_type; // Expression engine type</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line"> </div>
<div class="line">  const array_type&amp; array_; ///&lt; The array that this expression</div>
<div class="line">  std::string vars_; ///&lt; The tensor variable string</div>
<div class="line"> </div>
<div class="line">  // Not allowed</div>
<div class="line">  MyLeafExpression_&amp; operator=(MyLeafExpression_&amp;);</div>
<div class="line"> </div>
<div class="line">public:</div>
<div class="line"> </div>
<div class="line">  /// Constructors</div>
<div class="line"> </div>
<div class="line">  MyLeafExpression(const array_type&amp; array, const std::string&amp; vars) :</div>
<div class="line">    Expr_(), array_(array), vars_(vars) { }</div>
<div class="line"> </div>
<div class="line">  MyLeafExpression(const MyLeafExpression_&amp; other) :</div>
<div class="line">    array_(other.array_), vars_(other.vars_)</div>
<div class="line">  { }</div>
<div class="line"> </div>
<div class="line">  const array_type&amp; array() const { return array_; }</div>
<div class="line"> </div>
<div class="line">  const std::string&amp; vars() const { return vars_; }</div>
<div class="line"> </div>
<div class="line">}; // class MyLeafExpression</div>
</div><!-- fragment --><h3>Unary Expression Interface</h3>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;tiledarray.h&gt;</div>
<div class="line"> </div>
<div class="line">// Forward declarations</div>
<div class="line">template &lt;typename&gt; class MyUnaryExpression;</div>
<div class="line">template &lt;typename&gt; class MyUnaryEngine;</div>
<div class="line"> </div>
<div class="line">namespace TiledArray {</div>
<div class="line">  namespace expressions {</div>
<div class="line"> </div>
<div class="line">    // Define expression types</div>
<div class="line">    template &lt;typename Arg&gt;</div>
<div class="line">    struct ExprTrait&lt;MyUnaryExpression&lt;Arg&gt; &gt; : </div>
<div class="line">      public UnaryExprTrait&lt;Arg, MyUnaryEngine&gt; </div>
<div class="line">    { };</div>
<div class="line"> </div>
<div class="line">  } // namespace expressions</div>
<div class="line">} // namespace TiledArray</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">// My expression object</div>
<div class="line">template &lt;typename Arg&gt;</div>
<div class="line">class MyUnaryExpression : public UnaryExpr&lt;MyUnaryExpression&lt;Arg&gt; &gt; {</div>
<div class="line">public:</div>
<div class="line">  typedef MyUnaryExpression &lt;Arg&gt; MyUnaryExpression_; // This class type</div>
<div class="line">  typedef UnaryExpr&lt;MyUnaryExpression_&gt; UnaryExpr_; // Unary base class type</div>
<div class="line">  typedef typename TiledArray::expressions::ExprTrait&lt; MyUnaryExpression_ &gt;::argument_type</div>
<div class="line">      argument_type; // The argument expression type</div>
<div class="line">  typedef typename TiledArray::expressions::ExprTrait&lt; MyUnaryExpression_ &gt;::engine_type</div>
<div class="line">      engine_type; // Expression engine type</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line"> </div>
<div class="line">  // Not allowed</div>
<div class="line">  MyUnaryExpression_&amp; operator=(const MyUnaryExpression_&amp;);</div>
<div class="line"> </div>
<div class="line">public:</div>
<div class="line"> </div>
<div class="line">  // Constructors</div>
<div class="line"> </div>
<div class="line">  MyUnaryExpression(const argument_type&amp; arg) :</div>
<div class="line">    UnaryExpr_(arg)</div>
<div class="line">  { }</div>
<div class="line"> </div>
<div class="line">  MyUnaryExpression(const MyUnaryExpression_&amp; other) :</div>
<div class="line">    UnaryExpr_(other)</div>
<div class="line">  { }</div>
<div class="line"> </div>
<div class="line">}; // class MyScalingExpr</div>
</div><!-- fragment --><h3>Binary Expression Interface</h3>
<h2>Expression Engine Interface</h2>
<h1>Example Expression</h1>
<p>This example demonstrated how to construct a scaling expression. The <a class="el" href="namespace_tiled_array.html">TiledArray</a> tile operation <code>Scal</code> is used for demonstration purposes, but you are free to substitute your own tile operation. See Customizing Tile Operations for details.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;tiledarray.h&gt;</div>
<div class="line"> </div>
<div class="line">// Forward declarations</div>
<div class="line">template &lt;typename&gt; class MyScalingExpr;</div>
<div class="line">template &lt;typename&gt; class MyScalingEngine;</div>
<div class="line"> </div>
<div class="line">namespace TiledArray {</div>
<div class="line">  namespace expressions {</div>
<div class="line"> </div>
<div class="line">    // Define engine types</div>
<div class="line">    template &lt;typename Arg&gt;</div>
<div class="line">    struct EngineTrait&lt;MyScalingEngine&lt;Arg&gt; &gt; :</div>
<div class="line">      public UnaryEngineTrait&lt;Arg, TiledArray::math::Scal&gt;</div>
<div class="line">    { };</div>
<div class="line"> </div>
<div class="line">    // Define expression types</div>
<div class="line">    template &lt;typename Arg&gt;</div>
<div class="line">    struct ExprTrait&lt;ScalExpr&lt;Arg&gt; &gt; : </div>
<div class="line">      public UnaryExprTrait&lt;Arg, ScalEngine&gt; </div>
<div class="line">    { };</div>
<div class="line"> </div>
<div class="line">  } // namespace expressions</div>
<div class="line">} // namespace TiledArray</div>
<div class="line"> </div>
<div class="line">// My scaling expression engine</div>
<div class="line">template &lt;typename Arg&gt;</div>
<div class="line">class MyScalingEngine : public UnaryEngine&lt;MyScalingEngine&lt;Arg&gt; &gt; {</div>
<div class="line">public:</div>
<div class="line">  // Class hierarchy typedefs</div>
<div class="line">  typedef MyScalingEngine&lt;Arg&gt; MyScalingEngine_; // This class type</div>
<div class="line">  typedef UnaryEngine&lt;MyScalingEngine_&gt; UnaryEngine_; // Unary expression engine base type</div>
<div class="line">  typedef typename UnaryEngine_::ExprEngine_ ExprEngine_; // Expression engine base type</div>
<div class="line"> </div>
<div class="line">  // Argument typedefs</div>
<div class="line">  typedef typename EngineTrait&lt;MyScalingEngine_&gt;::argument_type argument_type; // The argument expression engine type</div>
<div class="line"> </div>
<div class="line">  // Operational typedefs</div>
<div class="line">  typedef typename TiledArray::expressions::EngineTrait&lt;MyScalingEngine_&gt;::value_type</div>
<div class="line">      value_type; // The result tile type</div>
<div class="line">  typedef typename TiledArray::expressions::EngineTrait&lt;MyScalingEngine_&gt;::scalar_type</div>
<div class="line">      scalar_type; // Tile scalar type</div>
<div class="line">  typedef typename TiledArray::expressions::EngineTrait&lt;MyScalingEngine_&gt;::op_type</div>
<div class="line">      op_type; // The tile operation type</div>
<div class="line">  typedef typename TiledArray::expressions::EngineTrait&lt;MyScalingEngine_&gt;::policy</div>
<div class="line">      policy; // The result policy type</div>
<div class="line">  typedef typename TiledArray::expressions::EngineTrait&lt;MyScalingEngine_&gt;::dist_eval_type</div>
<div class="line">      dist_eval_type; // The distributed evaluator type</div>
<div class="line"> </div>
<div class="line">  // Meta data typedefs</div>
<div class="line">  typedef typename TiledArray::expressions::EngineTrait&lt;MyScalingEngine_&gt;::size_type</div>
<div class="line">      size_type; // Size type</div>
<div class="line">  typedef typename TiledArray::expressions::EngineTrait&lt;MyScalingEngine_&gt;::trange_type</div>
<div class="line">      trange_type; // Tiled range type</div>
<div class="line">  typedef typename TiledArray::expressions::EngineTrait&lt;MyScalingEngine_&gt;::shape_type</div>
<div class="line">      shape_type; // Shape type</div>
<div class="line">  typedef typename TiledArray::expressions::EngineTrait&lt;MyScalingEngine_&gt;::pmap_interface</div>
<div class="line">      pmap_interface; // Process map interface type</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line"> </div>
<div class="line">  scalar_type factor_; // Scaling factor</div>
<div class="line"> </div>
<div class="line">public:</div>
<div class="line"> </div>
<div class="line">  // Constructor</div>
<div class="line">  template &lt;typename A&gt;</div>
<div class="line">  MyScalingEngine(const MyScalingExpr&lt;A&gt;&amp; expr) :</div>
<div class="line">    UnaryEngine_(expr), factor_(expr.factor())</div>
<div class="line">  { }</div>
<div class="line"> </div>
<div class="line">  // Non-permuting shape factory function</div>
<div class="line">  shape_type make_shape() const {</div>
<div class="line">    return UnaryEngine_::arg_.shape().scale(factor_);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // Permuting shape factory function</div>
<div class="line">  shape_type make_shape(const Permutation&amp; perm) const {</div>
<div class="line">    return UnaryEngine_::arg_.shape().scale(factor_, perm);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // Non-permuting tile operation factory function</div>
<div class="line">  op_type make_tile_op() const { return op_type(factor_); }</div>
<div class="line"> </div>
<div class="line">  // Permuting tile operation factory function</div>
<div class="line">  op_type make_tile_op(const Permutation&amp; perm) const { return op_type(perm, factor_); }</div>
<div class="line"> </div>
<div class="line">  // Expression identification tag used for printing</div>
<div class="line">  std::string make_tag() const {</div>
<div class="line">    std::stringstream ss;</div>
<div class="line">    ss &lt;&lt; &quot;[&quot; &lt;&lt; factor_ &lt;&lt; &quot;] &quot;;</div>
<div class="line">    return ss.str();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">}; // class MyScalingEngine</div>
<div class="line"> </div>
<div class="line">// Scaling expression</div>
<div class="line">template &lt;typename Arg&gt;</div>
<div class="line">class ScalExpr : public UnaryExpr&lt;ScalExpr&lt;Arg&gt; &gt; {</div>
<div class="line">public:</div>
<div class="line">  typedef MyScalingExpr&lt;Arg&gt; MyScalingExpr_; // This class type</div>
<div class="line">  typedef UnaryExpr&lt;MyScalingExpr_&gt; UnaryExpr_; // Unary base class type</div>
<div class="line">  typedef typename TiledArray::expressions::ExprTrait&lt;MyScalingExpr_&gt;::argument_type argument_type; // The argument expression type</div>
<div class="line">  typedef typename TiledArray::expressions::ExprTrait&lt;MyScalingExpr_&gt;::engine_type engine_type; // Expression engine type</div>
<div class="line">  typedef typename TiledArray::expressions::ExprTrait&lt;MyScalingExpr_&gt;::scalar_type scalar_type; // Scalar type</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line"> </div>
<div class="line">  scalar_type factor_; ///&lt; The scaling factor</div>
<div class="line"> </div>
<div class="line">  // Not allowed</div>
<div class="line">  ScalExpr_&amp; operator=(const ScalExpr_&amp;);</div>
<div class="line"> </div>
<div class="line">public:</div>
<div class="line"> </div>
<div class="line">  // Constructors</div>
<div class="line"> </div>
<div class="line">  MyScalingExpr(const argument_type&amp; arg, const scalar_type factor) :</div>
<div class="line">    UnaryExpr_(arg), factor_(factor)</div>
<div class="line">  { }</div>
<div class="line"> </div>
<div class="line">  MyScalingExpr(const MyScalingExpr_&amp; other, const scalar_type factor) :</div>
<div class="line">    UnaryExpr_(other), factor_(other.factor_ * factor)</div>
<div class="line">  { }</div>
<div class="line"> </div>
<div class="line">  MyScalingExpr(const MyScalingExpr_&amp; other) : UnaryExpr_(other), factor_(other.factor_) { }</div>
<div class="line"> </div>
<div class="line">  /// Scaling factor accessor</div>
<div class="line">  scalar_type factor() const { return factor_; }</div>
<div class="line"> </div>
<div class="line">}; // class MyScalingExpr</div>
<div class="line"> </div>
<div class="line">// Expression object factory functions</div>
<div class="line"> </div>
<div class="line">template &lt;typename D, typename Scalar&gt;</div>
<div class="line">inline typename madness::enable_if&lt;TiledArray::detail::is_numeric&lt;Scalar&gt;, ScalExpr&lt;D&gt; &gt;::type</div>
<div class="line">operator*(const Expr&lt;D&gt;&amp; expr, const Scalar&amp; factor) {</div>
<div class="line">  return ScalExpr&lt;D&gt;(expr.derived(), factor);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">template &lt;typename D, typename Scalar&gt;</div>
<div class="line">inline typename madness::enable_if&lt;TiledArray::detail::is_numeric&lt;Scalar&gt;, ScalExpr&lt;D&gt; &gt;::type</div>
<div class="line">operator*(const Scalar&amp; factor, const Expr&lt;D&gt;&amp; expr) {</div>
<div class="line">  return ScalExpr&lt;D&gt;(expr.derived(), factor);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">template &lt;typename Arg, typename Scalar&gt;</div>
<div class="line">inline typename madness::enable_if&lt;TiledArray::detail::is_numeric&lt;Scalar&gt;, ScalExpr&lt;Arg&gt; &gt;::type</div>
<div class="line">operator*(const ScalExpr&lt;Arg&gt;&amp; expr, const Scalar&amp; factor) {</div>
<div class="line">  return ScalExpr&lt;Arg&gt;(expr, factor);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">template &lt;typename Arg, typename Scalar&gt;</div>
<div class="line">inline typename madness::enable_if&lt;TiledArray::detail::is_numeric&lt;Scalar&gt;, ScalExpr&lt;Arg&gt; &gt;::type</div>
<div class="line">operator*(const Scalar&amp; factor, const ScalExpr&lt;Arg&gt;&amp; expr) {</div>
<div class="line">  return ScalExpr&lt;Arg&gt;(expr, factor);</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->

<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
    Generated at Wed Mar 4 2020 15:58:00 for <a href="https://https://github.com/ValeevGroup/tiledarray/">TiledArray</a>
    1.0.0-alpha.2 by &#160;<a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
<script type="text/javascript" src="doxy-boot.js"></script>
</html>
