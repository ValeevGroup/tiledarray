<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.17"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>TiledArray: Basic Programming of TiledArray</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
        <script type="text/javascript" src="jquery.smartmenus.js"></script>
        <!-- SmartMenus jQuery Bootstrap Addon -->
        <script type="text/javascript" src="jquery.smartmenus.bootstrap.js"></script>
        <!-- SmartMenus jQuery plugin -->
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">TiledArray 1.0.0-alpha.2</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="userguide.html"><span>User&#160;Guide</span></a></li>
      <li><a href="usergroup0.html"><span>Programmer&#160;Guides</span></a></li>
      <li><a href="usergroup1.html"><span>Source&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Basic Programming of <a class="el" href="namespace_tiled_array.html">TiledArray</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="namespace_tiled_array.html">TiledArray</a> is a framework for computing with block-sparse tensors on shared- and distributed-memory computers. It is designed to allow users to compose tensor expressions of arbitrary complexity in native C++ code that closely resembles the standard mathematical notation. <a class="el" href="namespace_tiled_array.html">TiledArray</a> is designed for strong scalability in real applications, with pilot benchmarks having executed on hundreds of thousands of cores.</p>
<p><a class="el" href="namespace_tiled_array.html">TiledArray</a> is built on top of the <a href="https://github.com/m-a-d-n-e-s-s/madness">MADNESS</a> parallel runtime, denoted here as MADWorld. MADWorld provides a powerful task-based programming model that is key to <a class="el" href="namespace_tiled_array.html">TiledArray</a>'s scalability.</p>
<p>This document is intended for new users of <a class="el" href="namespace_tiled_array.html">TiledArray</a>. It covers basic concepts, construction and initialization of tensors, composing tensor expressions, and accessing results. More advanced users are directed elsewhere in this Wiki for topics such as user-defined Tiles, etc.</p>
<p><b>NOTE:</b> This guide, and <a class="el" href="namespace_tiled_array.html">TiledArray</a> itself, is a work in progress. Therefore information may be changed or added at any time. While we strive to maintain a stable user interface, <a class="el" href="namespace_tiled_array.html">TiledArray</a> is still evolving, sometimes in non-backward-compatible ways.</p>
<h1>Primer</h1>
<h2>Concepts</h2>
<h3>Tensor/Array</h3>
<p><a class="el" href="namespace_tiled_array.html">TiledArray</a> represents tensors as ordinary (multidimensional) arrays of values (i.e. nothing specifies the transformation properties of the array data to make it a proper tensor); henceforth we will use tensor and array interchangeably. An order-_n_ tensor (i.e., a tensor with <em>n</em> indices) is represented as an <em>n</em>-dimensional array. Tensor in <a class="el" href="namespace_tiled_array.html">TiledArray</a> is a map from a Range of Indices (a hyperrectangular range in ℤ<sup>n</sup>) to ring ℜ. The highest-level tensor data structure in <a class="el" href="namespace_tiled_array.html">TiledArray</a> is a distributed tiled multidimensional array, modeling concept DistArray and represented by C++ class <code>DistArray</code>. DistArray is a directly-addressable sequence of <em>tiles</em>. Tiles are distributed among all or some processes in your application, hence only a subset of tiles is <em>rapidly</em> accessible from a given process. A DistArray is defined by a TiledRange, which specifies a cartesian tiling of the element Range, a Pmap, which maps tile index to the processor on which it resides, and a Shape, which specifies the structure of the array at the tile level (e.g. it can indicate whether a given tile is zero or not in a sparse array). <a class="el" href="namespace_tiled_array.html">TiledArray</a> supports two variants of DistArray out of the box: <em>dense</em>, in which all tiles are assumed non-zero, and <em>block-sparse</em>, in which some tiles may be assumed to be zero, and thus omitted.</p>
<h3>Range</h3>
<p>An order-_n_ Range is a hyperrectangle in ℤ<sup>n</sup>, where <em>n</em> ≥ 0 (currently <a class="el" href="namespace_tiled_array.html">TiledArray</a> only supports ranges in the nonnegative subset of ℤ<sup>n</sup>). Range is used to define valid values for element and tile Indices. The size of each <em>mode</em> (side) of the hyperrectangle is its <em>extent</em>; 0-based indexing of modes is used throughout.</p>
<h3>Index</h3>
<p>Index specifies a location in a range. An index may be a coordinate index or an ordinal index.</p>
<h3>Coordinate Index</h3>
<p>A sequence of non-negative <em>n</em> integers that represents an element of a Range. The first integer refers to the 0th mode of the range, etc. The following figure illustrates coordinate indices of the elements of a 4 by 4 matrix.</p>
<div class="image">
<img src="CoordinateIndex.png" alt=""/>
<div class="caption">
Coordinate indices in a 4x4 matrix</div></div>
   <h3>Ordinal Index</h3>
<p>A single nonnegative integer value specifying the position of an element in a totally-ordered Range. Row-major lexicographical order is used by most classes in <a class="el" href="namespace_tiled_array.html">TiledArray</a>. The following figure illustrates (row-major) ordinal indices of the elements of a 4 by 4 matrix.</p>
<div class="image">
<img src="OrdinalIndex.png" alt=""/>
<div class="caption">
Ordinal indices in a 4x4 matrix</div></div>
   <h3>TiledRange</h3>
<p>TiledRange is a Range each mode of which is <em>tiled</em>, i.e. divided into contiguous, non-overlaping blocks; cartesian product of mode tilings defines the overall tiling of the range into subranges; each such subrange is a tile of the TiledRange. Tiles in a TiledRange are indexed just like the elements of the underlying range, hence the notions of <em>element range</em> and <em>tile range</em> arise in discussing TiledRange .</p>
<h3>Tile</h3>
<p>Tile of an array is any hyperrectangular sub-block of the array; a Tile is an array of same order as the base array. Division of DistArray into tiles is defined by its TiledRange. Tiles are local objects, i.e. only the process on which the tile resides has access to its data. Tile is defined by its Range.</p>
<h3>Dense Array</h3>
<p>A dense array is an array where all tiles are explicitly stored. All tiles of a dense array are non-zero tiles.</p>
<div class="image">
<img src="DenseArray.png" alt=""/>
<div class="caption">
Dense 4x4 matrix</div></div>
   <h3>Block-Sparse Array</h3>
<p>In a block-spare array, only non-zero blocks are stored. For example, the array pictured below contains four non-zero blocks (shown in green). You may specify any block in an array to be a zero tile or non-zero tile. For example, a 2D, block-sparse array may look like:</p>
<div class="image">
<img src="BlockSparseArray.png" alt=""/>
<div class="caption">
Block-sparse 4x4 matrix</div></div>
   <p>where zero tiles are shown in white, while non-zero tiles are shown in green.</p>
<h3>Non-Zero and Zero Tiles</h3>
<p>A non-zero tile is a sub-block of a DistArray that explicitly stores all elements for that tile. A zero tile is a sub-block of a DistArray that implicitly contains all zero elements, but is never stored. where all elements are equal to zero (Note: The data for zero tiles is not explicitly stored).</p>
<div class="image">
<img src="ZeroArray.png" alt=""/>
<div class="caption">
Zero and non-zero in a block-sparse 4x4 matrix</div></div>
   <h3>Owner</h3>
<p>The owner of a tile is the process which stores that tile.</p>
<h3>Pmap</h3>
<p>A process map that defines ownership of each tile.</p>
<h3>Shape</h3>
<p>An object that specifies the structure of DistArray. E.g. it could be represented by a bitset where a set bit represents a non-zero tile and an unset bit represents zero tiles in a DistArray.</p>
<h2>Implementation</h2>
<p><a class="el" href="namespace_tiled_array.html">TiledArray</a> is a library written in standard C++ using features available in the 2017 ISO standard (commonly known as C++17). To use <a class="el" href="namespace_tiled_array.html">TiledArray</a> it is necessary to <code>#include</code> header <code><a class="el" href="tiledarray_8h.html">tiledarray.h</a></code>. imports most <a class="el" href="namespace_tiled_array.html">TiledArray</a> features into namespace <code><a class="el" href="namespace_tiled_array.html">TiledArray</a></code>. For convenience, namespace alias <code>TA</code> is also provided. Although the alias can be disabled by defining the <code>TILEDARRAY_DISABLE_NAMESPACE_TA</code> preprocessor variable, all examples will assume that the <code>TA</code> alias is not disabled.</p>
<p>P.S. It sometimes may be possible to reduce source code couplings by importing only <em>forwarding</em> declarations. This is done by <code>#include</code>ing header <code><a class="el" href="tiledarray__fwd_8h.html">tiledarray_fwd.h</a></code>.</p>
<h2>Parallel Runtime</h2>
<p><a class="el" href="namespace_tiled_array.html">TiledArray</a> exposes several features of the MADWorld programming model, most importantly <em>worlds</em>, <em>tasks</em>, and <em>futures</em>.</p>
<p>A world, represented by an object of <code>TA::World</code> class (which is currently just an alias to <code>madness::World</code>), represents a collection of MPI processes. World is an extension of the MPI (intra)communicator concept that provides not only a communication context but also an execution context (such as task queue, etc.). Each array in <a class="el" href="namespace_tiled_array.html">TiledArray</a> lives in a specific world (the default world, just like <code>MPI_COMM_WORLD</code>, spans the entire set of processes which called <code>MPI_Init_thread</code>).</p>
<p>Task is a unit of execution in MADWorld. Most operations in <a class="el" href="namespace_tiled_array.html">TiledArray</a> are expressed as a collection of <em>fine-grained</em> tasks scheduled by the MADWorld; the fine-grained nature of tasks allows to express much more parallelism than is possible with traditional approaches like fork-join. Task parallel runtime of MADWorld also allows to overlap task execution (computation) with data movement (communication), and thus tolerate better all sources of latency.</p>
<p>When submitting a task to the task queue, a <code><a class="el" href="classmadness_1_1_future.html">madness::Future</a></code> object is returned, which is a placeholder for the result of a task. Futures may also be given to other tasks as input. In this way, futures are used to define task dependencies; they can be thought as nodes of the graph of tasks representing the computation. Note that MADWorld futures are similar to <code>std::future</code> (or, rather, <code>std::shared_future</code>) in standard C++, the main distinction is that <code><a class="el" href="classmadness_1_1_future.html">madness::Future</a></code> is <em>global</em> (i.e. a Future on one process can refer to a result produced on another) and it is possible to <em>attach continuations</em> to <code><a class="el" href="classmadness_1_1_future.html">madness::Future</a></code>.</p>
<h1>Using <a class="el" href="namespace_tiled_array.html">TiledArray</a></h1>
<p>A typical scenario for using <a class="el" href="namespace_tiled_array.html">TiledArray</a> will perform the following steps:</p><ul>
<li>Initialize the parallel runtime environment</li>
<li>Construct <code>DistArray</code> objects</li>
<li>Initialize tile data of the arrays</li>
<li>Implement algebraic tensor expressions Let's walk through each step in detail.</li>
</ul>
<h2>Initializing the Parallel Runtime Environment</h2>
<p>To use <a class="el" href="namespace_tiled_array.html">TiledArray</a> it is necessary to first initialize its runtime environment, such as <a href="https://github.com/m-a-d-n-e-s-s/madness">MADNESS</a> and its dependents, CUDA, etc: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;tiledarray.h&gt; // imports most TiledArray features</div>
<div class="line"> </div>
<div class="line">int main(int argc, char* argv[]) {</div>
<div class="line">  // Initialize TiledArray</div>
<div class="line">  auto&amp; world = TA::initialize(argc, argv);</div>
<div class="line"> </div>
<div class="line">  // Do some work here.</div>
<div class="line"> </div>
<div class="line">  TA::finalize();</div>
<div class="line">  return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>TA::initialize</code> initializes the <a class="el" href="namespace_tiled_array.html">TiledArray</a> runtime and returns a reference to the default World object, which by default spans all MPI processes. <code>TA::finalize</code> shuts down the <a class="el" href="namespace_tiled_array.html">TiledArray</a> runtime; after this it is no longer possible to use <a class="el" href="namespace_tiled_array.html">TiledArray</a>, so this is typically done at the very end of the program. It is <em>not possible</em> to call <code>TA::initialize</code> <em>more than once</em> in your program.</p>
<p>Since <a class="el" href="namespace_tiled_array.html">TiledArray</a> depends on MPI (via MADWorld), <code>TA::initialize</code> first checks if MPI had been initialized. If MPI is not yet initialized <code>TA::initialize</code> will do so by calling <a href="https://www.open-mpi.org/doc/current/man3/MPI_Init_thread.3.php"><code>MPI_Init_thread</code></a>. If MPI had already been initialized, then <code>TA::initialize</code> will only check that MPI initialization requested proper level of thread safety (serialized or full).</p>
<p>It is easy to initialize <a class="el" href="namespace_tiled_array.html">TiledArray</a> on a subset of MPI processes by passing the corresponding MPI communicator to <code>TA::initialize</code>: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;tiledarray.h&gt;</div>
<div class="line"> </div>
<div class="line">int main(int argc, char* argv[]) {</div>
<div class="line">  // Initialize MPI</div>
<div class="line">  int thread_level_provided;</div>
<div class="line">  MPI_Init_thread(&amp;argc, &amp;argv, MPI_THREAD_MULTIPLE, &amp;thread_level_provided);</div>
<div class="line">  assert(MPI_THREAD_MULTIPLE == thread_level_provided);</div>
<div class="line"> </div>
<div class="line">  // create a communicator spanning even ranks only</div>
<div class="line">  int me;  MPI_Comm_rank(MPI_COMM_WORLD, &amp;me);</div>
<div class="line">  MPI_Comm comm_evens; MPI_Comm_split(MPI_COMM_WORLD, (me % 2 ? MPI_UNDEFINED : 0), 0, &amp;comm_evens);</div>
<div class="line"> </div>
<div class="line">  // Initialize TiledArray on even ranks only</div>
<div class="line">  if (comm_evens != MPI_COMM_NULL) {</div>
<div class="line">    auto&amp; world = TA::initialize(argc, argv, comm_evens);</div>
<div class="line"> </div>
<div class="line">    // Do some work here.</div>
<div class="line"> </div>
<div class="line">    // Finalize TiledArray</div>
<div class="line">    TA::finalize();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // must finalize MPI since we initialized it ourselves</div>
<div class="line">  MPI_Finalize();</div>
<div class="line"> </div>
<div class="line">  return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Construct an array</h2>
<p>To construct a <code>DistArray</code> object, you must supply following the meta data:</p><ul>
<li><a href="#construct-tiledrange-object">TiledRange</a></li>
<li>(optional) <a href="#construct-a-process-map-object">Pmap</a></li>
<li>(block-sparse only) <a href="#construct-shape-object">Shape</a></li>
</ul>
<h3>Construct TiledRange object</h3>
<p>A TiledRange is defined by tensor/Cartesian product of tilings for each mode. Tiling for 1 mode is represented by class <code>TA::TiledRange1</code> which is most easily constructed by specifying tile boundaries as an array of indices. For example, the following code defines 2 tilings for interval [0,10), both consisting of 3 tiles: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">TA::TiledRange1 TR0{0,3,8,10};</div>
<div class="line">TA::TiledRange1 TR1{0,4,7,10};</div>
</div><!-- fragment --><p>The size of tiles in <code>TR0</code> are 3, 5, and 2, whereas <code>TR1</code>'s tiles has sizes 4, 3, and 3. Combining these tilings produces an order-2 <code>TiledRange</code>, </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">TA::TiledRange TR{TR0,TR1};</div>
</div><!-- fragment --><p>with 3 tiles in each mode, for a total of <code>10 x 10</code> (or 100) elements partitioned into 9 tiles, as pictured below:</p>
<p>[[images/tiledrange.png|height=250px]]</p>
<p><code>TR</code> can be constructed directly without defining <code>TiledRange1</code> objects first as follows: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">TA::TiledRange TR{{0,3,8,10},</div>
<div class="line">                  {0,4,7,10}};</div>
</div><!-- fragment --><p>The TiledRange constructor in the above example is useful for simple examples and prototyping code. However, in production code it will be likely necessary to construct <code>TiledRange</code> objects with an iterator list of <code>TiledRange1</code> objects, e.g.: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">// Construct tile boundary vector</div>
<div class="line">std::vector&lt;std::size_t&gt; tile_boundaries;</div>
<div class="line">for(std::size_t i = 0; i &lt;= 16; i += 4)</div>
<div class="line">  tile_boundaries.push_back(i);</div>
<div class="line"> </div>
<div class="line">// Construct a set of 1D TiledRanges</div>
<div class="line">std::vector&lt;TA::TiledRange1&gt;</div>
<div class="line">    ranges(2, TA::TiledRange1(tile_boundaries.begin(), tile_boundaries.end()));</div>
<div class="line"> </div>
<div class="line">// Construct the 2D TiledRange</div>
<div class="line">TA::TiledRange trange(ranges.begin(), ranges.end());</div>
</div><!-- fragment --><p>where <code>tile_boundaries</code> defines the boundaries of tiles along a single dimension, <code>ranges</code> is the set of tile boundaries (one per dimension), and <code>trange</code> is the tiled range object that is used to construct <code>DistArray</code> objects.</p>
<h3>Construct a Process Map Object</h3>
<p>A process map is used to determine owner of a given tile with requiring communication between processes. Process maps also maintain a list of local tiles (tiles owned by the current process). <a class="el" href="namespace_tiled_array.html">TiledArray</a> provides several different types process maps that can be used to initialize <code>DistArray</code> objects. The process maps provided by <a class="el" href="namespace_tiled_array.html">TiledArray</a> are blocked, block-cyclic, hashed, and replicated. With the exception of the replicated process map (which always returns the current process as the owner) a process map will always return the same owner for a given tile on any process. You may also create a custom process map class that is derived from <code>TA::Pmap</code>.</p>
<p><b>Note</b>: You are not required to explicitly construct a process map for a <code>DistArray</code> object as the <code>DistArray</code> object will construct one for you if none is provided. You may want to construct a process map yourself if you require a particular data layout. Process maps can also be used aid in the distribution of work among processes before your array object is constructed (this may be useful when constructing sparse shapes).</p>
<p>To construct a process map using one of the process map provided by <a class="el" href="namespace_tiled_array.html">TiledArray</a>: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">const std::size_t m = 20;</div>
<div class="line">const std::size_t n = 10;</div>
<div class="line"> </div>
<div class="line">std::shared_ptr&lt;TA::Pmap&gt;</div>
<div class="line">    blocked_pmap(new TA::detail::BlockedPmap(world, m * n));</div>
<div class="line"> </div>
<div class="line">// {4,4} = # of processor rows/columns in 2d grid ... hardwired here, but should be determined programmatically</div>
<div class="line">std::shared_ptr&lt;TA::Pmap&gt;</div>
<div class="line">    cyclic_pmap(new TA::detail::CyclicPmap(world, m, n, 4, 4));</div>
<div class="line"> </div>
<div class="line">std::shared_ptr&lt;TA::Pmap&gt;</div>
<div class="line">    hash_pmap(new TA::detail::HashPmap(world, m * n));</div>
</div><!-- fragment --><p>An program is provided by <a class="el" href="namespace_tiled_array.html">TiledArray</a> in examples/pmap_test/ that demonstrates the tile distribution that is generated by the various process map objects. You can vary the output of this program by changing the number of MPI processes when running the test program. For example, the output for 16 MPI processes looks like: </p><div class="fragment"><div class="line">$ mpirun -n 16 pmap</div>
<div class="line">MADNESS runtime initialized with 7 threads in the pool and affinity -1 -1 -1</div>
<div class="line">Block</div>
<div class="line"> 0  0  0  0  0  0  0  0  0  0</div>
<div class="line"> 0  0  0  1  1  1  1  1  1  1</div>
<div class="line"> 1  1  1  1  1  1  2  2  2  2</div>
<div class="line"> 2  2  2  2  2  2  2  2  2  3</div>
<div class="line"> 3  3  3  3  3  3  3  3  3  3</div>
<div class="line"> 3  3  4  4  4  4  4  4  4  4</div>
<div class="line"> 4  4  4  4  4  5  5  5  5  5</div>
<div class="line"> 5  5  5  5  5  5  5  5  6  6</div>
<div class="line"> 6  6  6  6  6  6  6  6  6  6</div>
<div class="line"> 6  7  7  7  7  7  7  7  7  7</div>
<div class="line"> 7  7  7  7  8  8  8  8  8  8</div>
<div class="line"> 8  8  8  8  8  8  8  9  9  9</div>
<div class="line"> 9  9  9  9  9  9  9  9  9  9</div>
<div class="line">10 10 10 10 10 10 10 10 10 10</div>
<div class="line">10 10 10 11 11 11 11 11 11 11</div>
<div class="line">11 11 11 11 11 11 12 12 12 12</div>
<div class="line">12 12 12 12 12 12 12 12 12 13</div>
<div class="line">13 13 13 13 13 13 13 13 13 13</div>
<div class="line">13 13 14 14 14 14 14 14 14 14</div>
<div class="line">14 14 14 14 14 15 15 15 15 15</div>
<div class="line"> </div>
<div class="line">0: { 0 1 2 3 4 5 6 7 8 9 10 11 12 }</div>
<div class="line">1: { 13 14 15 16 17 18 19 20 21 22 23 24 25 }</div>
<div class="line">2: { 26 27 28 29 30 31 32 33 34 35 36 37 38 }</div>
<div class="line">3: { 39 40 41 42 43 44 45 46 47 48 49 50 51 }</div>
<div class="line">4: { 52 53 54 55 56 57 58 59 60 61 62 63 64 }</div>
<div class="line">5: { 65 66 67 68 69 70 71 72 73 74 75 76 77 }</div>
<div class="line">6: { 78 79 80 81 82 83 84 85 86 87 88 89 90 }</div>
<div class="line">7: { 91 92 93 94 95 96 97 98 99 100 101 102 103 }</div>
<div class="line">8: { 104 105 106 107 108 109 110 111 112 113 114 115 116 }</div>
<div class="line">9: { 117 118 119 120 121 122 123 124 125 126 127 128 129 }</div>
<div class="line">10: { 130 131 132 133 134 135 136 137 138 139 140 141 142 }</div>
<div class="line">11: { 143 144 145 146 147 148 149 150 151 152 153 154 155 }</div>
<div class="line">12: { 156 157 158 159 160 161 162 163 164 165 166 167 168 }</div>
<div class="line">13: { 169 170 171 172 173 174 175 176 177 178 179 180 181 }</div>
<div class="line">14: { 182 183 184 185 186 187 188 189 190 191 192 193 194 }</div>
<div class="line">15: { 195 196 197 198 199 }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">Cyclic</div>
<div class="line"> 0  1  2  0  1  2  0  1  2  0 </div>
<div class="line"> 3  4  5  3  4  5  3  4  5  3 </div>
<div class="line"> 6  7  8  6  7  8  6  7  8  6 </div>
<div class="line"> 9 10 11  9 10 11  9 10 11  9 </div>
<div class="line">12 13 14 12 13 14 12 13 14 12 </div>
<div class="line"> 0  1  2  0  1  2  0  1  2  0</div>
<div class="line"> 3  4  5  3  4  5  3  4  5  3</div>
<div class="line"> 6  7  8  6  7  8  6  7  8  6</div>
<div class="line"> 9 10 11  9 10 11  9 10 11  9 </div>
<div class="line">12 13 14 12 13 14 12 13 14 12 </div>
<div class="line"> 0  1  2  0  1  2  0  1  2  0 </div>
<div class="line"> 3  4  5  3  4  5  3  4  5  3 </div>
<div class="line"> 6  7  8  6  7  8  6  7  8  6 </div>
<div class="line"> 9 10 11  9 10 11  9 10 11  9 </div>
<div class="line">12 13 14 12 13 14 12 13 14 12 </div>
<div class="line"> 0  1  2  0  1  2  0  1  2  0 </div>
<div class="line"> 3  4  5  3  4  5  3  4  5  3 </div>
<div class="line"> 6  7  8  6  7  8  6  7  8  6 </div>
<div class="line"> 9 10 11  9 10 11  9 10 11  9 </div>
<div class="line">12 13 14 12 13 14 12 13 14 12 </div>
<div class="line"> </div>
<div class="line">0: { 0 3 6 9 50 53 56 59 100 103 106 109 150 153 156 159 }</div>
<div class="line">1: { 1 4 7 51 54 57 101 104 107 151 154 157 }</div>
<div class="line">2: { 2 5 8 52 55 58 102 105 108 152 155 158 }</div>
<div class="line">3: { 10 13 16 19 60 63 66 69 110 113 116 119 160 163 166 169 }</div>
<div class="line">4: { 11 14 17 61 64 67 111 114 117 161 164 167 }</div>
<div class="line">5: { 12 15 18 62 65 68 112 115 118 162 165 168 }</div>
<div class="line">6: { 20 23 26 29 70 73 76 79 120 123 126 129 170 173 176 179 }</div>
<div class="line">7: { 21 24 27 71 74 77 121 124 127 171 174 177 }</div>
<div class="line">8: { 22 25 28 72 75 78 122 125 128 172 175 178 }</div>
<div class="line">9: { 30 33 36 39 80 83 86 89 130 133 136 139 180 183 186 189 }</div>
<div class="line">10: { 31 34 37 81 84 87 131 134 137 181 184 187 }</div>
<div class="line">11: { 32 35 38 82 85 88 132 135 138 182 185 188 }</div>
<div class="line">12: { 40 43 46 49 90 93 96 99 140 143 146 149 190 193 196 199 }</div>
<div class="line">13: { 41 44 47 91 94 97 141 144 147 191 194 197 }</div>
<div class="line">14: { 42 45 48 92 95 98 142 145 148 192 195 198 }</div>
<div class="line">15: { }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">Hash</div>
<div class="line"> 8  8  2 12  9  7  4  9 13 15 </div>
<div class="line"> 4 14 10 13 14 15  9  7  1  5 </div>
<div class="line">11  1 13  1 11  1  8 13  6  2 </div>
<div class="line"> 2  6 13 12 14 12 11  2  9  3 </div>
<div class="line"> 8  5 11 11 14  2 12  2  4  8 </div>
<div class="line">11  9  1 14 13 15  4  1  6  1 </div>
<div class="line">14 12  4  6 12  1 13  1  1 10 </div>
<div class="line"> 8  7 14  5  2  7 13  4  8  9 </div>
<div class="line"> 4 13  9  9 12  7  4  2 14  8 </div>
<div class="line">15  8 11 11 14  9  0  2  0  4 </div>
<div class="line">14  9  0  3  3 10  4 12  3  8 </div>
<div class="line"> 2  9  6  9  7  7 11 11 14 10 </div>
<div class="line"> 3 12 13 13 15 11 11 14  7  8 </div>
<div class="line">11 13  4 13 14 11  9  3  5 14 </div>
<div class="line"> 9 11 13  6  8 14 12  0  0  5 </div>
<div class="line"> 6  7  9  9  9  0 10 10  8  5 </div>
<div class="line"> 6  1 11 12 12 12 10  3  6  7 </div>
<div class="line">15  2  6  1 10  2  4  1  5  1 </div>
<div class="line">12 10  8  0 10  2 15 13 12  1 </div>
<div class="line"> 5  8 14 15  8 14  4  5  1  6 </div>
<div class="line">    </div>
<div class="line">0: { 96 98 102 147 148 155 183 }</div>
<div class="line">1: { 18 21 23 25 52 57 59 65 67 68 161 173 177 179 189 198 }</div>
<div class="line">2: { 2 29 30 37 45 47 74 87 97 110 171 175 185 }</div>
<div class="line">3: { 39 103 104 108 120 137 167 }</div>
<div class="line">4: { 6 10 48 56 62 77 80 86 99 106 132 176 196 }</div>
<div class="line">5: { 19 41 73 138 149 159 178 190 197 }</div>
<div class="line">6: { 28 31 58 63 112 143 150 160 168 172 199 }</div>
<div class="line">7: { 5 17 71 75 85 114 115 128 151 169 }</div>
<div class="line">8: { 0 1 26 40 49 70 78 89 91 109 129 144 158 182 191 194 }</div>
<div class="line">9: { 4 7 16 38 51 79 82 83 95 101 111 113 136 140 152 153 154 }</div>
<div class="line">10: { 12 69 105 119 156 157 166 174 181 184 }</div>
<div class="line">11: { 20 24 36 42 43 50 92 93 116 117 125 126 130 135 141 162 }</div>
<div class="line">12: { 3 33 35 46 61 64 84 107 121 146 163 164 165 180 188 }</div>
<div class="line">13: { 8 13 22 27 32 54 66 76 81 122 123 131 133 142 187 }</div>
<div class="line">14: { 11 14 34 44 53 60 72 88 94 100 118 127 134 139 145 192 195 }</div>
<div class="line">15: { 9 15 55 90 124 170 186 193 }</div>
</div><!-- fragment --><h3>Construct Shape Object</h3>
<p><a class="el" href="namespace_tiled_array.html">TiledArray</a> supports two types of arrays: dense and sparse. If you are using dense arrays then you do not need to provide a shape object when constructing your arrays. However, to use block-sparse arrays you must use the sparse variant of the <code>TA::DistArray</code> class; you will also need to provide a <code>TA::SparseShape</code> object to its constructor. Note: although it is possible to use user-defined Shape classes, here we only discuss the stadnard <code>TA::SparseShape</code> class provided as a standard component of <a class="el" href="namespace_tiled_array.html">TiledArray</a>.</p>
<p>A <code>TA::SparseShape</code> can be thought of as a dense (local) array whose elements are the Frobenius norm values for each tile. Hence the extents of the shape object are simply the extents of the tile range of the TiledRange object. Frobenius norm is chosen since its submultiplicative character makes it possible to bound the norms of tensor products; this is essential to be able to predict the shape of the result of a tensor expression.</p>
<p>There are two methods for constructing shape objects: distributed and replicated. You want to use distributed construction when computation of shape norms is expensive. When using distributed construction, contributions to the shape are reduced over all processes (via an all-reduce algorithm). Conversely, you want to use replicated construction when computing tile norms is inexpensive and takes less time than sharing the shape data.</p>
<p>The steps required to initialize a sparse shape are:</p>
<ol type="1">
<li>Set the zero tile threshold</li>
<li>Construct a [TiledRange](TiledRange) object</li>
<li>Construct a [process map](Construct a process map) (optional)</li>
</ol>
<h4>Zero-Tile Threshold</h4>
<p>The zero-tile threshold is used to determine whether a tile zero or non-zero. A tile is considered to be zero if the 2-norm of the tile divided by the number of elements in the tile is less than the given threshold. That is: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">tile.norm() / tile.range().volume() &lt; TA::SparseShape::threshold()</div>
</div><!-- fragment --><p>To set the zero-tile threshold call: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">TA::SparseShape::threshold(my_theshold);</div>
</div><!-- fragment --><p>where <code>my_theshold</code> is the zero threshold you specify for your application. This threshold is a global value and is used for all <code>SparseShape</code> objects. Because the zero-tile threshold is shared by all shapes, it is recommended that you set this value only once at the beginning of your program. If you change the threshold during the execution of your application, it affect all subsequent zero-tile checks but it will not change shape data. You are responsible for ensuring that changes the the threshold value during execution do not adversely affect your application.</p>
<h4>Distributed SparseShape Construction</h4>
<p>With distributed SparseShape construction, the shape data is <em>partially</em> initialized in each process. With this method, only set tile norms for <b>local</b> tiles, otherwise the norm data stored in shape will be artificially inflated.</p>
<p>The advantage of this method is that computation of tile norms is distributed among all processes, but requires communication between processes. Distributed construction is preferred when the cost of recomputing tile norms on all processes is too high or impractical. The tile norms are shared among processes by the <code>TA::SparseShape</code> constructor via an all-reduce summation.</p>
<p>With distributed construction, it is convenient to use a process map to help partition the work load. The process map can then be used to construct <code>TA::DistArray</code> objects. </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">// User provided tile factory function.</div>
<div class="line">Tensor&lt;double&gt; make_tile(const TA::Range&amp; range);</div>
<div class="line"> </div>
<div class="line">// ...</div>
<div class="line"> </div>
<div class="line">// tile norms are provided as a dense tensor of floats</div>
<div class="line">TA::Tensor&lt;float&gt; tile_norms(trange.tile_range());</div>
<div class="line">for(std::size_t i = 0; i &lt; tile_norms.volume(); ++i) {</div>
<div class="line">  if(pmap-&gt;is_local(i)) {</div>
<div class="line">    Tensor&lt;double&gt; tile = make_tile(trange.make_tile_range(i));</div>
<div class="line"> </div>
<div class="line">    tile_norm[i] = tile.norm();</div>
<div class="line">  </div>
<div class="line">    // ...</div>
<div class="line"> </div>
<div class="line">  } else {</div>
<div class="line">    tile_norms[i] = 0;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Then construct the <code>TA::SparseShape</code> object with the tile norm and tiled range. </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">TA::SparseShape&lt;float&gt; shape(world, tile_norms, trange);</div>
</div><!-- fragment --><p>Note that in the above example we loop over every possible local tile and compute it's norm. For mostly sparse arrays it is necessary to loop over the nonzero tiles only. The following example demonstrates how to do this for a matrix with nonzero blocks on the diagonal only. </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">// tile norms will be provided as a sequence of nonzero elements</div>
<div class="line">std::vector&lt;std::pair&lt;std::array&lt;size_t,2&gt;,float&gt;&gt; tile_norms;</div>
<div class="line">// n = the number of tiles in each dimension of the matrix</div>
<div class="line">for(std::size_t i = 0; i &lt; n; ++i) {</div>
<div class="line">  const auto ii = i * n + i;  // the tile ordinal index</div>
<div class="line">  if(pmap-&gt;is_local(ii)) {</div>
<div class="line">    // compute_tile_norm({i,i}) returns the norm estimate of tile {i,i}</div>
<div class="line">    tile_norm.push_back(std::make_pair(std::array&lt;size_t,2&gt;{i,i},compute_tile_norm({i,i})));</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">TA::SparseShape&lt;float&gt; shape(world, tile_norms, trange);</div>
</div><!-- fragment --><h4>Replicated SparseShape Construction</h4>
<p>With replicated SparseShape construction, the shape data is fully initialized in all processes. It is important that the shape data be identical on all processes, otherwise your application will not function correctly (most likely it will deadlock).</p>
<p>The advantage of this method is that it does not require communication between process, but computation of tile norms for all tiles must be done on all nodes. This method is preferred when the cost of recomputation of tile norms is less than cost of communication used in distributed shape construction.</p>
<p>First, create a <code>TA::Tensor&lt;float&gt;</code> object that contains the 2-norm (or <a href="http://mathworld.wolfram.com/FrobeniusNorm.html">Frobenius Norm</a>) of each tile. </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">// User provided tile factory function.</div>
<div class="line">Tensor&lt;double&gt; make_tile(const TA::Range&amp; range);</div>
<div class="line"> </div>
<div class="line">// ...</div>
<div class="line"> </div>
<div class="line">TA::Tensor&lt;float&gt; tile_norms(trange.tiles_range());</div>
<div class="line">for(std::size_t i = 0; i &lt; tile_norms.volume(); ++i) {</div>
<div class="line">  Tensor&lt;double&gt; tile = make_tile(trange.make_tile_range(i));</div>
<div class="line"> </div>
<div class="line">  tile_norm[i] = tile.norm();</div>
<div class="line">  </div>
<div class="line">  // ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>Then construct the <code>TA::SparseShape</code> object with the tile norm and tiled range. </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">TA::SparseShape&lt;float&gt; shape(tile_norms, trange);</div>
</div><!-- fragment --><h3>Construct a DistArray</h3>
<p>Once you have a TiledRange and optionally shape and process map constructed, you are ready to construct a DistArray object. <code>TA::DistArray</code> class is parametrized by 2 types:</p><ul>
<li><code>Tile</code> &ndash; an Array type used to represent tiles of the DistArray object.</li>
<li><code>Policy</code> &ndash; a policy type that configures the behavior of DistArray; this includes whether DistArray is dense or block-sparse, which Range and TiledRange types are used, etc.</li>
</ul>
<p>The ability to parametrize <code>TA::DistArray</code> is essential for many advanced applications: for example, the ability to customize tiles makes it possible to compute with arrays whose tiles are generated lazily (on-the-fly), support computing on heterogeneous platforms and/or with disk/NVRAM-based tile storage, utilize compressed tile formats, use multiprecision representations, etc. Similarly, by customizing Policy it is possible to implement more general sparsity types than illustrated in this guide. However, user-defined Tiles and Policies is a more advanced topic that will be covered elsewhere; here we will focus on the two most common cases that are supported out-of-the-box: dense and block-sparse DistArray with dense CPU-only tiles over integers, reals, and complex numbers. To make using such DistArrays easier <a class="el" href="namespace_tiled_array.html">TiledArray</a> defines the following type aliases:</p><ul>
<li><code>TA::TArray&lt;Ring&gt;</code>: dense DistArray over ring type <code>Ring</code> (alias for <code>TA::DistArray&lt;TA::Tensor&lt;Ring&gt;,TA::DensePolicy&gt;</code>)</li>
<li><code>TA::TArrayD</code>: dense DistArray over <code>double</code> (alias for <code>TA::TArray&lt;double&gt;</code>)</li>
<li><code>TA::TArrayF</code>: dense DistArray over <code>float</code></li>
<li><code>TA::TArrayZ</code>: dense DistArray over <code>std::complex&lt;double&gt;</code></li>
<li><code>TA::TArrayC</code>: dense DistArray over <code>std::complex&lt;float&gt;</code></li>
<li><code>TA::TArrayI</code>: dense DistArray over <code>int</code></li>
<li><code>TA::TArrayL</code>: dense DistArray over <code>long</code></li>
<li><code>TA::TSpArray&lt;Ring&gt;</code>: block-sparse DistArray over ring type <code>Ring</code> (alias for <code>TA::DistArray&lt;TA::Tensor&lt;Ring&gt;,TA::SparsePolicy&gt;</code>)</li>
<li><code>TA::TSpArrayD</code>: block-sparse DistArray over <code>double</code> (alias for <code>TA::TSpArray&lt;double&gt;</code>)</li>
<li><code>TA::TSpArrayF</code>: block-sparse DistArray over <code>float</code></li>
<li><code>TA::TSpArrayZ</code>: block-sparse DistArray over <code>std::complex&lt;double&gt;</code></li>
<li><code>TA::TSpArrayC</code>: block-sparse DistArray over <code>std::complex&lt;float&gt;</code></li>
<li><code>TA::TSpArrayI</code>: block-sparse DistArray over <code>int</code></li>
<li><code>TA::TSpArrayL</code>: block-sparse DistArray over <code>long</code></li>
</ul>
<p>Throughout the rest of the guide we will use these aliases instead of using more verbose <code>TA::DistArray</code> type (note, however, that when debugging your code that uses these aliases most debuggers will show the name of the full type rather than the alias names).</p>
<p>This example demonstrates how to construct dense and sparse DistArrays: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">// Construct a dense DistArray (of doubles) with the default process map</div>
<div class="line">TA::TArrayD a1(world, trange);</div>
<div class="line"> </div>
<div class="line">// Construct a dense DistArray with a user specified process map</div>
<div class="line">TA::TArrayD a2(world, trange, pmap);</div>
<div class="line"> </div>
<div class="line">// Construct a sparse DistArray with the default process map</div>
<div class="line">TA::TSpArrayD a3(world, trange, shape);</div>
<div class="line"> </div>
<div class="line">// Construct a sparse DistArray with a user specified process map</div>
<div class="line">TA::TSpArrayD a4(world, trange, shape, pmap);</div>
</div><!-- fragment --><p>Recall that <code>DistArray</code> objects have their data <em>distributed</em> across the entire World in which they are constructed. To ensure a consistent state their constructor is a <em>collective</em> operation, i.e. it must be invoked on every processor with the same arguments.</p>
<h2>Initializing Tiles</h2>
<p>There are several methods available to initialize array tiles. Users can initialize tiles by calling a <code>Array::set</code> with index and</p><ul>
<li>a tile object,</li>
<li>a future to a tile object,</li>
<li>an iterator tile data, or</li>
<li>a constant to fill the tile. The preferred method is to construct tiles via MADNESS tasks and provide a <code><a class="el" href="classmadness_1_1_future.html">madness::Future</a></code> for the tile (see example below).</li>
</ul>
<h3>Explicit Tile Initialization</h3>
<p>The easiest method to initialize a DistArray is to loop over local tiles and explicitly initialize each tile. This method distributes initialization work over all processes in the World. Here's the example: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">// Construct a dense array</div>
<div class="line">TA::TArrayD array(world...);</div>
<div class="line">// Initialize local tiles</div>
<div class="line">for(TArrayD::iterator it = array.begin(); it != array.end(); ++it) {</div>
<div class="line">  // Construct a tile</div>
<div class="line">  TArrayD::value_type tile(array.trange().make_tile_range(it.index()));</div>
<div class="line"> </div>
<div class="line">  // Fill tile with data</div>
<div class="line">  for(std::size_t i = 0; i &lt; tile.size(); ++i)</div>
<div class="line">    tile[i] = 0.0;</div>
<div class="line"> </div>
<div class="line">  // Insert the tile into the array</div>
<div class="line">  *it = tile;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The outer loop in this example iterates over the local tiles of <code>array</code>. Within the loop body we first create an tile (an object of <code>TArrayD::value_type</code> type, which in this case is <code>TA::Tensor&lt;double&gt;</code>). Then we loop over its elements and assign each to zero.</p>
<p>N.B. Of course, filling a DistArray with a constant is such a common use case that there's already a method for exactly that: <code>array.fill(0.0)</code>.</p>
<p>There are more serious issues with the last example. First, it is too verbose. Second, it's not generic enough (i.e. trying to reuse it for a sparse DistArray would require changing a few lines). Both issues can be solved by using modern C++ features: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">// Initialize local tiles</div>
<div class="line">for(auto it = begin(array); it != end(array); ++it) {</div>
<div class="line">  // Construct a tile</div>
<div class="line">  auto tile = decltype(array)::value_type(array.trange().make_tile_range(it.index()));</div>
<div class="line"> </div>
<div class="line">  // Fill tile with data</div>
<div class="line">  std::fill(tile.begin(), tile.end(), 0.0);</div>
<div class="line"> </div>
<div class="line">  // Insert the tile into the array</div>
<div class="line">  *it = tile;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The new code is better in a few ways:</p><ul>
<li>explicit use of <code>array</code>'s type is eliminated thanks to <code>auto</code> and <code>decltype</code> (caveat: type deduction can make it more difficult to diagnose compilation errors or introduce unwanted conversions), and</li>
<li>the inner loop has been replaced by a more efficient and cleaner <code>std::fill</code> (N.B. any modern compiler at the max optimization level will replace <code>std::fill</code> with call to <code>memset</code> when appropriate, so this is the fastest way to fill the tile).</li>
</ul>
<p>You can also initialize tile elements using a coordinate index instead of an ordinal index. The following example is equivalent to the previous example, except the tile elements are accessed via a coordinate index. </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">// Add local tiles</div>
<div class="line">for(auto it = begin(array); it != end(array); ++it) {</div>
<div class="line">  // Construct a tile</div>
<div class="line">  auto tile = decltype(array)::value_type(array.trange().make_tile_range(it.index()));</div>
<div class="line"> </div>
<div class="line">  // Store a reference to the start and finish array of the tile</div>
<div class="line">  const auto&amp; lobound = tile.range().lobound();</div>
<div class="line">  const auto&amp; upbound = tile.range().upbound();</div>
<div class="line"> </div>
<div class="line">  // Fill tile with data</div>
<div class="line">  // this explicitly assumes order-4 tensors!</div>
<div class="line">  std::size_t i[] = {0,0,0,0};  // instead of fundamental array could use std::array, std::vector, or any SequenceContainer</div>
<div class="line">  for(i[0] = lobound[0]; i[0] != upbound[0]; ++i[0])</div>
<div class="line">    for(i[1] = lobound[1]; i[1] != upbound[1]; ++i[1])</div>
<div class="line">      for(i[2] = lobound[2]; i[2] != upbound[2]; ++i[2])</div>
<div class="line">        for(i[3] = lobound[3]; i[3] != upbound[3]; ++i[3])</div>
<div class="line">          tile[i] = 0.0;</div>
<div class="line"> </div>
<div class="line">  // Insert the tile into the array</div>
<div class="line">  *it = tile;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that in the examples shown so far tile initialization is parallelized over MPI processes only; on each process <em>only</em> the main thread does the initialization work. To parallelize over threads on each process we can also initialize tiles by submitting within MADNESS tasks. To do this we need to define a task function that will generate tiles. For example: </p><div class="fragment"><div class="line">auto make_tile(const TA::Range&amp; range) {</div>
<div class="line">  // Construct a tile</div>
<div class="line">  TA::TArrayD::value_type tile(range);</div>
<div class="line"> </div>
<div class="line">  // Fill tile with data</div>
<div class="line">  std::fill(tile.begin(), tile.end(), 0.0);</div>
<div class="line"> </div>
<div class="line">  return tile;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Using <code><a class="el" href="namespace_tiled_array_1_1detail.html#ada724a31400bb94f55097560394438de" title="Factory function for tiles.">make_tile()</a></code>, the first example can be rewritten to generate tiles in parallel. </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">// Add local tiles</div>
<div class="line">for(auto it = begin(array); it != end(array); ++it) {</div>
<div class="line">  // Construct a tile using a MADNESS task.</div>
<div class="line">  auto tile = world.taskq.add(&amp; make_tile, array.trange().make_tile_range(it.index()));</div>
<div class="line"> </div>
<div class="line">  // Insert the tile into the array</div>
<div class="line">  *it = tile;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Pushing off the initialization work to MADNESS tasks makes initialization asynchronous, i.e. actual initialization work will happen after task creation. However, in general there is no need to wait for the initialization work to complete: it is completely safe to use <code>array</code> in <a class="el" href="namespace_tiled_array.html">TiledArray</a> expressions even though its initialization may not be complete yet. <code>DistArray</code> was designed for such asynchronous execution from the ground up.</p>
<h3>Optimized Tile Initialization</h3>
<p>In the above example, we generated one task per tile. However, there is a small overhead associated with generating and running a task. If the tiles are very small and/or the time required to initialize a tile is very small, then the overhead from creating and running tasks may cause your application to run slower in parallel than serially. To alleviate this problem we need to create tasks that initialize several tiles at once.</p>
<p>The example below, does this by recursively dividing an iterator range in half until the number of elements in the range is less than or equal to <code>block_size</code>. Once the size of the iterator range is small enough, the task will initialize the tiles in the iterator subrange. You do not want to make block size too small or too big, but it is usually fairly easy to achieve optimal performance.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">// Construct a tile filled with zeros</div>
<div class="line">template &lt;typename Iterator&gt;</div>
<div class="line">void make_tile(</div>
<div class="line">    TA::TArrayD&amp; array,</div>
<div class="line">    Iterator first,</div>
<div class="line">    Iterator last,</div>
<div class="line">    const std::size_t block_size)</div>
<div class="line">{</div>
<div class="line">  //Make tasks that generate more than one tile.</div>
<div class="line">  std::size_t size = std::distance(first, last);</div>
<div class="line">  while(size &gt; block_size) {</div>
<div class="line">    // Divide the iterator range in half, middle = (last - first)/2</div>
<div class="line">    Iterator middle = first;</div>
<div class="line">    size /= 2;</div>
<div class="line">    std::advance(middle, size);</div>
<div class="line"> </div>
<div class="line">    // Construct a task to evaluate middle to last</div>
<div class="line">    make_tile_task(array, middle, last, block_size);</div>
<div class="line"> </div>
<div class="line">    // This task will now evaluate first to middle</div>
<div class="line">    last = middle;</div>
<div class="line">  }// This loop uses tasks to generates tasks.</div>
<div class="line">  // once the size is small enough then use the current task to assign tiles.</div>
<div class="line"> </div>
<div class="line">  // Assign portion of array</div>
<div class="line">  for(; first != last; ++first) {</div>
<div class="line"> </div>
<div class="line">    // Construct tile</div>
<div class="line">    auto tile = TA::TArrayD::value_type(array.trange().make_tile_range(first.index()));</div>
<div class="line"> </div>
<div class="line">    // Fill tile with your data, here it is 0&#39;s</div>
<div class="line">    std::fill(tile.begin(), tile.end(), 0.0);</div>
<div class="line"> </div>
<div class="line">    // Add the tile to the array</div>
<div class="line">    *first = tile;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">template &lt;typename Iterator&gt;</div>
<div class="line">void make_tile_task(TA::TArrayD &amp;array, Iterator first, Iterator last, const std::size_t block_size){</div>
<div class="line">  //Generate a madness task to make tile.  This assumes you defined the trange for array elsewhere.</div>
<div class="line">  array.world().taskq.add(&amp; make_tile&lt;Iterator&gt;, array, first, last, block_size);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void make_array(TA::TArrayD &amp;array, std::size_t block_size) {</div>
<div class="line">  make_tile_task(array, begin(array), end(array), block_size);</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>make_array</code> is the top-level function that initializes an array: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">make_array(array, 2);  // each task will initialize up to 2 tiles</div>
</div><!-- fragment --><h1>Complete Example Program</h1>
<p>This example shows a complete program that constructs arrays in parallel and performs a tensor contraction. </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;tiledarray.h&gt;</div>
<div class="line"> </div>
<div class="line">// Construct a TA::Tensor&lt;T&gt; filled with v</div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line">TA::Tensor&lt;T&gt; make_tile(const TA::Range&amp; range, const double v) {</div>
<div class="line">  // Allocate a tile</div>
<div class="line">  TA::Tensor&lt;T&gt; tile(range);</div>
<div class="line">  std::fill(tile.begin(), tile.end(), v);</div>
<div class="line"> </div>
<div class="line">  return tile;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Fill array x with value v</div>
<div class="line">void init_array(TA::TArrayD&amp; x, const double v) {</div>
<div class="line">  // Add local tiles to a</div>
<div class="line">  for(auto it = begin(x); it != end(x); ++it) {</div>
<div class="line">    // Construct a tile using a MADNESS task.</div>
<div class="line">    auto tile = x.world().taskq.add(make_tile&lt;double&gt;, x.trange().make_tile_range(it.index()), v);</div>
<div class="line"> </div>
<div class="line">    // Insert the tile into the array</div>
<div class="line">    *it = tile;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main(int argc, char* argv[]) {</div>
<div class="line">  // Initialize runtime</div>
<div class="line">  auto&amp; world = TA::initialize(argc, argv);</div>
<div class="line"> </div>
<div class="line">  // Construct tile boundary vector</div>
<div class="line">  std::vector&lt;std::size_t&gt; tile_boundaries;</div>
<div class="line">  for(std::size_t i = 0; i &lt;= 16; i += 4)</div>
<div class="line">    tile_boundaries.push_back(i);</div>
<div class="line"> </div>
<div class="line">  // Construct a set of TiledRange1&#39;s</div>
<div class="line">  std::vector&lt;TA::TiledRange1&gt;</div>
<div class="line">    ranges(2, TA::TiledRange1(tile_boundaries.begin(), tile_boundaries.end()));</div>
<div class="line"> </div>
<div class="line">  // Construct the 2D TiledRange</div>
<div class="line">  TA::TiledRange trange(ranges.begin(), ranges.end());</div>
<div class="line"> </div>
<div class="line">  // Construct array objects.</div>
<div class="line">  TA::TArrayD a(world, trange);</div>
<div class="line">  TA::TArrayD b(world, trange);</div>
<div class="line">  TA::TArrayD c(world, trange);</div>
<div class="line"> </div>
<div class="line">  // Initialize a and b.</div>
<div class="line">  init_array(a, 3.0);</div>
<div class="line">  init_array(b, 2.0);</div>
<div class="line"> </div>
<div class="line">  // Print the content of input tensors, a and b.</div>
<div class="line">  std::cout &lt;&lt; &quot;a = \n&quot; &lt;&lt; a &lt;&lt; &quot;\n&quot;;</div>
<div class="line">  std::cout &lt;&lt; &quot;b = \n&quot; &lt;&lt; b &lt;&lt; &quot;\n&quot;;</div>
<div class="line"> </div>
<div class="line">  // Compute the contraction c(m,n) = sum_k a(m,k) * b(k,n)</div>
<div class="line">  c(&quot;m,n&quot;) = a(&quot;m,k&quot;) * b(&quot;k,n&quot;);</div>
<div class="line"> </div>
<div class="line">  // Print the result tensor, c.</div>
<div class="line">  std::cout &lt;&lt; &quot;c = \n&quot; &lt;&lt; c &lt;&lt; &quot;\n&quot;;</div>
<div class="line"> </div>
<div class="line">  TA::finalize();</div>
<div class="line">  return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that the tasks that initialize <code>a</code> and <code>b</code> will execute during and after the corresponding <code>init_array</code> statements; in fact initialization of <code>a</code> and <code>b</code> can overlap.. If your initialization work needs to be performed in particular sequence you may need to add <code>world.gop.fence()</code> to ensure that all preceding work in the particular world has finished.</p>
<h3>Constructing Replicated Arrays</h3>
<p>There are two methods for generating replicated Arrays. The first method distributes computation, where data for each tile is generated on one node and distributed to all other nodes. The communication cost for this method is <code>O(n(n-1))</code>. This type of construction is appropriate when the data is small but expensive to compute.</p>
<p>The second method is replicated computation, where the data for each tile is generated on all nodes. Since the data is generated on all nodes, there is no communication with this method. Replicated computation is appropriate for data that is inexpensive to compute and/or the communcation cost in the first method is greater than the computation time.</p>
<p>If you want to use a hybrid approach, where each tile is computed on a small subset of nodes and distributed to the remaining, you should construct a replicated Array and write your own algorithm to computing and distributing data.</p>
<h4>Distributed Computation</h4>
<p>The procedure for constructing a replicated array with distributed computation is the same as constructing other replicated arrays, except <code>Array::make_replicated()</code> is called after the local tiles have been inserted into the array. </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">// Construct a distributed array.</div>
<div class="line">TA::TArrayD array(world, trange);</div>
<div class="line"> </div>
<div class="line">// Add local tiles</div>
<div class="line">for(auto it = begin(array); it != end(array); ++it) {</div>
<div class="line">  // Construct a tile using a MADNESS task.</div>
<div class="line">  auto tile =</div>
<div class="line">    world.taskq.add(&amp; make_tile, array.trange().make_tile_range(it.index()));</div>
<div class="line"> </div>
<div class="line">  // Insert the tile into the array</div>
<div class="line">  array.set(it.index(), tile);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Convert the distributed array to a replicated array,</div>
<div class="line">// add distribute data.</div>
<div class="line">array.make_replicated();</div>
</div><!-- fragment --><h4>Replicated Computation</h4>
<p>The procedure for constructing a replicated array with replicated computation is similar to the distributed computation method, except the array is constructed with a replicated process map (pmap). </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">// Construct a replicated array.</div>
<div class="line">auto replicated_pmap = std::make_shared&lt;TA::detail::ReplicatedPmap&gt;(world, trange.tiles_range().volume());</div>
<div class="line">TA::TArrayD array(world, trange, replicated_pmap);</div>
<div class="line"> </div>
<div class="line">// Add all tiles</div>
<div class="line">for(std::size_t i = 0; i &lt; array.size(); ++i) {</div>
<div class="line">  // Construct a tile using a MADNESS task.</div>
<div class="line">  auto tile =</div>
<div class="line">    world.taskq.add(&amp; make_tile, array.trange().make_tile_range(i));</div>
<div class="line"> </div>
<div class="line">  // Insert the tile into the array</div>
<div class="line">  array.set(i, tile);</div>
<div class="line">}</div>
</div><!-- fragment --><h1>Tensor Expressions</h1>
<p>Examples of tensor expressions: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">E(&quot;i,j&quot;) = 2.0 * A(&quot;i,k&quot;) * B(&quot;k,j&quot;) + C(&quot;k,j&quot;) * D(&quot;k,i&quot;);</div>
<div class="line"> </div>
<div class="line">C(&quot;i,j&quot;) = A(&quot;i,j&quot;) + B(&quot;i,j&quot;);</div>
<div class="line"> </div>
<div class="line">B(&quot;i,j&quot;) = -A(&quot;i,j&quot;);</div>
<div class="line"> </div>
<div class="line">C(&quot;i,j&quot;) = multiply(A(&quot;i,j&quot;), B(&quot;i,j&quot;));</div>
<div class="line"> </div>
<div class="line">double x = A(&quot;i,j&quot;).dot(B(&quot;j,i&quot;));</div>
<div class="line"> </div>
<div class="line">double n = A(&quot;i,j&quot;).norm2();</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->

<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
    Generated at Wed Mar 4 2020 15:58:00 for <a href="https://https://github.com/ValeevGroup/tiledarray/">TiledArray</a>
    1.0.0-alpha.2 by &#160;<a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
<script type="text/javascript" src="doxy-boot.js"></script>
</html>
