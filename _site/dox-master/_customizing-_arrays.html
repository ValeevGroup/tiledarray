<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.17"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>TiledArray: Customizing DistArray</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
        <script type="text/javascript" src="jquery.smartmenus.js"></script>
        <!-- SmartMenus jQuery Bootstrap Addon -->
        <script type="text/javascript" src="jquery.smartmenus.bootstrap.js"></script>
        <!-- SmartMenus jQuery plugin -->
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">TiledArray 1.0.0-alpha.2</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="userguide.html"><span>User&#160;Guide</span></a></li>
      <li><a href="usergroup0.html"><span>Programmer&#160;Guides</span></a></li>
      <li><a href="usergroup1.html"><span>Source&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Customizing DistArray </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a href="#wiki-user-defined-tiles">User Defined Tiles</a><ul>
<li><a href="#wiki-lazy-tiles">Lazy Tiles</a></li>
<li><a href="#wiki-data-tiles">Data Tiles</a></li>
</ul>
</li>
<li><a href="#wiki-ser-defined-shapes">User Defined Shapes</a></li>
<li><a href="#wiki-user-defined-process-map">User Defined Process Map</a></li>
</ul>
<h1>User Defined Tiles</h1>
<p>The default tile type of <code><a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">TiledArray::DistArray</a></code> is <code><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">TiledArray::Tensor</a></code>. However, <a class="el" href="namespace_tiled_array.html">TiledArray</a> supports using user-defined types as tiles. There are few scenarios where one would like to provide a non-standard type as a tile; for example, user wants to provide a more efficient implementation of certain operations on tiles. There are two modes of user-defined types that can be used as tiles: types that store the data elements explicitly (“data tiles”) and types that generate a data tile as needed (“lazy evaluation tiles”).</p>
<h2>User-Defined Data Tiles</h2>
<p>Any user-defined tensor type can play a role of a data tile provided it matches the same concept as <code><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">TiledArray::Tensor</a></code>. For brevity, instead of an actual concept spec here is an example of a custom tile type that meets the concept spec.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">class MyTensor {</div>
<div class="line">public:</div>
<div class="line">  // Typedefs</div>
<div class="line">  typedef MyTensor eval_type;           // The type used when evaluating expressions</div>
<div class="line">  typedef TiledArray::Range range_type; // Tensor range type</div>
<div class="line">  typedef ... value_type;               // Element type</div>
<div class="line">  typedef ... numeric_type;             // The scalar type that is compatible with value_type</div>
<div class="line">  typedef ... size_type;                // Size type</div>
<div class="line"> </div>
<div class="line">public:</div>
<div class="line"> </div>
<div class="line">  // Default constructors (may be uninitialized)</div>
<div class="line">  MyTensor();</div>
<div class="line"> </div>
<div class="line">  // Shallow copy constructor; see MyTensor::clone() for deep copy</div>
<div class="line">  MyTensor(const MyTensor&amp; other);</div>
<div class="line"> </div>
<div class="line">  // Shallow assignment operator; see MyTensor::clone() for deep copy</div>
<div class="line">  MyTensor&amp; operator=(const MyTensor&amp; other);</div>
<div class="line"> </div>
<div class="line">  // Deep copy</div>
<div class="line">  MyTensor clone() const;</div>
<div class="line"> </div>
<div class="line">  // Tile range accessor</div>
<div class="line">  const range_type&amp; range() const;</div>
<div class="line"> </div>
<div class="line">  // Number of elements in the tile</div>
<div class="line">  size_type size() const;</div>
<div class="line"> </div>
<div class="line">  // Initialization check. False if the tile is fully initialized.</div>
<div class="line">  bool empty() const;</div>
<div class="line"> </div>
<div class="line">  // MADNESS-compliant serialization</div>
<div class="line">  template &lt;typename Archive&gt;</div>
<div class="line">  void serialize(Archive&amp; ar);</div>
<div class="line"> </div>
<div class="line">  // Permutation operation</div>
<div class="line"> </div>
<div class="line">  // result[perm ^ i] = (*this)[i]</div>
<div class="line">  MyTensor permute(const TiledArray::Permutation&amp; perm) const;</div>
<div class="line"> </div>
<div class="line">  // Scaling operations</div>
<div class="line"> </div>
<div class="line">  // result[i] = (*this)[i] * factor</div>
<div class="line">  MyTensor scale(const numeric_type factor) const;</div>
<div class="line">  // result[perm ^ i] = (*this)[i] * factor</div>
<div class="line">  MyTensor scale(const numeric_type factor, const TiledArray::Permutation&amp; perm) const;</div>
<div class="line">  // (*this)[i] *= factor</div>
<div class="line">  MyTensor&amp; scale_to(const numeric_type factor) const;</div>
<div class="line"> </div>
<div class="line">  // Addition operations</div>
<div class="line"> </div>
<div class="line">  // result[i] = (*this)[i] + right[i]</div>
<div class="line">  MyTensor add(const MyTensor&amp; right) const;</div>
<div class="line">  // result[i] = ((*this)[i] + right[i]) * factor</div>
<div class="line">  MyTensor add(const MyTensor&amp; right, const numeric_type factor) const;</div>
<div class="line">  // result[i] = (*this)[i] + value</div>
<div class="line">  MyTensor add(const value_type&amp; value) const;</div>
<div class="line"> </div>
<div class="line">  // result[perm ^ i] = (*this)[i] + right[i]</div>
<div class="line">  MyTensor add(const MyTensor&amp; right, const TiledArray::Permutation&amp; perm) const;</div>
<div class="line">  // result[perm ^ i] = ((*this)[i] + right[i]) * factor</div>
<div class="line">  MyTensor add(const MyTensor&amp; right, const numeric_type factor, const TiledArray::Permutation&amp; perm) const;</div>
<div class="line">  // result[perm ^ i] = (*this)[i] + value</div>
<div class="line">  MyTensor add(const value_type&amp; value, const TiledArray::Permutation&amp; perm) const;</div>
<div class="line"> </div>
<div class="line">  // (*this)[i] += right[i]</div>
<div class="line">  MyTensor&amp; add_to(const MyTensor&amp; right) const;</div>
<div class="line">  // ((*this)[i] += right[i]) *= factor</div>
<div class="line">  MyTensor&amp; add_to(const MyTensor&amp; right, const numeric_type factor) const;</div>
<div class="line">  // (*this)[i] += value</div>
<div class="line">  MyTensor&amp; add_to(const value_type&amp; value) const;</div>
<div class="line"> </div>
<div class="line">  // Subtraction operations</div>
<div class="line"> </div>
<div class="line">  // result[i] = (*this)[i] - right[i]</div>
<div class="line">  MyTensor subt(const MyTensor&amp; right) const;</div>
<div class="line">  // result[i] = ((*this)[i] - right[i]) * factor</div>
<div class="line">  MyTensor subt(const MyTensor&amp; right, const numeric_type factor) const;</div>
<div class="line">  // result[i] = (*this)[i] - value</div>
<div class="line">  MyTensor subt(const value_type&amp; value) const;</div>
<div class="line"> </div>
<div class="line">  // result[perm ^ i] = (*this)[i] - right[i]</div>
<div class="line">  MyTensor subt(const MyTensor&amp; right, const TiledArray::Permutation&amp; perm) const;</div>
<div class="line">  // result[perm ^ i] = ((*this)[i] - right[i]) * factor</div>
<div class="line">  MyTensor subt(const MyTensor&amp; right, const numeric_type factor, const TiledArray::Permutation&amp; perm) const;</div>
<div class="line">  // result[perm ^ i] = (*this)[i] - value</div>
<div class="line">  MyTensor subt(const value_type value, const TiledArray::Permutation&amp; perm) const;</div>
<div class="line"> </div>
<div class="line">  // (*this)[i] -= right[i]</div>
<div class="line">  MyTensor&amp; subt_to(const MyTensor&amp; right);</div>
<div class="line">  // ((*this)[i] -= right[i]) *= factor</div>
<div class="line">  MyTensor&amp; subt_to(const MyTensor&amp; right, const numeric_type factor);</div>
<div class="line">  // (*this)[i] -= value</div>
<div class="line">  MyTensor&amp; subt_to(const value_type&amp; value);</div>
<div class="line"> </div>
<div class="line">  // (Entrywise) multiplication operations (Hadamard product)</div>
<div class="line"> </div>
<div class="line">  // result[i] = (*this)[i] * right[i]</div>
<div class="line">  MyTensor mult(const MyTensor&amp; right) const;</div>
<div class="line">  // result[i] = ((*this)[i] * right[i]) * factor</div>
<div class="line">  MyTensor mult(const MyTensor&amp; right, const numeric_type factor) const;</div>
<div class="line"> </div>
<div class="line">  // result[perm ^ i] = (*this)[i] * right[i]</div>
<div class="line">  MyTensor mult(const MyTensor&amp; right, const TiledArray::Permutation&amp; perm) const;</div>
<div class="line">  // result[perm^ i] = ((*this)[i] * right[i]) * factor</div>
<div class="line">  MyTensor mult(const MyTensor&amp; right, const numeric_type factor, const TiledArray::Permutation&amp; perm) const;</div>
<div class="line"> </div>
<div class="line">  // *this[i] *= right[i]</div>
<div class="line">  MyTensor&amp; mult_to(const MyTensor&amp; right);</div>
<div class="line">  // (*this[i] *= right[i]) *= factor</div>
<div class="line">  MyTensor&amp; mult_to(const MyTensor&amp; right, const numeric_type factor);</div>
<div class="line"> </div>
<div class="line">  // Negation operations</div>
<div class="line"> </div>
<div class="line">  // result[i] = -((*this)[i])</div>
<div class="line">  MyTensor neg() const;</div>
<div class="line">  // result[perm ^ i] = -((*this)[i])</div>
<div class="line">  MyTensor neg(const TiledArray::Permutation&amp; perm) const;</div>
<div class="line">  // arg[i] = -((*this)[i])</div>
<div class="line">  MyTensor&amp; neg_to();</div>
<div class="line"> </div>
<div class="line">  // Contraction operations</div>
<div class="line"> </div>
<div class="line">  // GEMM operation with fused indices as defined by gemm_config; multiply this by other, return the result</div>
<div class="line">  MyTensor gemm(const MyTensor&amp; other, const numeric_type factor,</div>
<div class="line">                const TiledArray::math::GemmHelper&amp; gemm_config) const;</div>
<div class="line"> </div>
<div class="line">  // GEMM operation with fused indices as defined by gemm_config; multiply left by right, store to this</div>
<div class="line">  MyTensor&amp; gemm(const MyTensor&amp; left, const MyTensor&amp; right, const numeric_type factor,</div>
<div class="line">                 const TiledArray::math::GemmHelper&amp; gemm_config);</div>
<div class="line"> </div>
<div class="line">  // Reduction operations</div>
<div class="line"> </div>
<div class="line">  // Sum of hyper diagonal elements</div>
<div class="line">  numeric_type trace() const;</div>
<div class="line">  // foreach(i) result += arg[i]</div>
<div class="line">  numeric_type sum() const;</div>
<div class="line">  // foreach(i) result *= arg[i]</div>
<div class="line">  numeric_type product() const;</div>
<div class="line">  // foreach(i) result += arg[i] * arg[i]</div>
<div class="line">  numeric_type squared_norm() const;</div>
<div class="line">  // sqrt(squared_norm(arg))</div>
<div class="line">  numeric_type norm() const;</div>
<div class="line">  // foreach(i) result = max(result, arg[i])</div>
<div class="line">  numeric_type max() const;</div>
<div class="line">  // foreach(i) result = min(result, arg[i])</div>
<div class="line">  numeric_type min() const;</div>
<div class="line">  // foreach(i) result = max(result, abs(arg[i]))</div>
<div class="line">  numeric_type abs_max() const;</div>
<div class="line">  // foreach(i) result = max(result, abs(arg[i]))</div>
<div class="line">  numeric_type abs_min() const;</div>
<div class="line">  </div>
<div class="line">} // class MyTensor</div>
</div><!-- fragment --><p>It is also possible to implement most of the concept requirements non-intrusively, by providing free functions. This can be helpful if you want to use an existing tensor class as a tile. Here’s an example of how to implement MyTensor without member functions:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">class MyTensor {</div>
<div class="line">public:</div>
<div class="line">  // Typedefs</div>
<div class="line">  typedef TiledArray::Range range_type; // Tensor range type</div>
<div class="line">  typedef ... value_type;               // Element type</div>
<div class="line">  typedef ... numeric_type;             // The scalar type that is compatible with value_type</div>
<div class="line">  typedef ... size_type;                // Size type</div>
<div class="line"> </div>
<div class="line">public:</div>
<div class="line"> </div>
<div class="line">  // Default constructors (may be uninitialized)</div>
<div class="line">  MyTensor();</div>
<div class="line"> </div>
<div class="line">  // Shallow copy constructor; see MyTensor::clone() for deep copy</div>
<div class="line">  MyTensor(const MyTensor&amp; other);</div>
<div class="line"> </div>
<div class="line">  // Shallow assignment operator; see MyTensor::clone() for deep copy</div>
<div class="line">  MyTensor&amp; operator=(const MyTensor&amp; other);</div>
<div class="line"> </div>
<div class="line">  // Deep copy</div>
<div class="line">  MyTensor clone() const;</div>
<div class="line"> </div>
<div class="line">  // Tile range accessor</div>
<div class="line">  const range_type&amp; range() const;</div>
<div class="line"> </div>
<div class="line">  // Number of elements in the tile</div>
<div class="line">  size_type size() const;</div>
<div class="line"> </div>
<div class="line">  // Initialization check. False if the tile is fully initialized.</div>
<div class="line">  bool empty() const;</div>
<div class="line"> </div>
<div class="line">  // MADNESS-compliant serialization</div>
<div class="line">  template &lt;typename Archive&gt;</div>
<div class="line">  void serialize(Archive&amp; ar);</div>
<div class="line"> </div>
<div class="line">  // Scaling operations</div>
<div class="line"> </div>
<div class="line">  // result[i] = (*this)[i] * factor</div>
<div class="line">  MyTensor scale(const numeric_type factor) const;</div>
<div class="line">  // result[perm ^ i] = (*this)[i] * factor</div>
<div class="line">  MyTensor scale(const numeric_type factor, const TiledArray::Permutation&amp; perm) const;</div>
<div class="line">  // (*this)[i] *= factor</div>
<div class="line">  MyTensor&amp; scale_to(const numeric_type factor) const;</div>
<div class="line"> </div>
<div class="line">} // class MyTensor</div>
<div class="line"> </div>
<div class="line">namespace TiledArray {</div>
<div class="line"> </div>
<div class="line">  // MyTensor is used directly evaluate expressions (see also Lazy Tiles section below)</div>
<div class="line">  struct eval_trait&lt;MyTensor&gt; {</div>
<div class="line">      typedef MyTensor type;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  namespace math {</div>
<div class="line"> </div>
<div class="line">  // Permutation operation</div>
<div class="line"> </div>
<div class="line">  // returns a tile for which result[perm ^ i] = tile[i]</div>
<div class="line">  MyTensor permute(const MyTensor&amp; tile,</div>
<div class="line">                   const TiledArray::Permutation&amp; perm);</div>
<div class="line"> </div>
<div class="line">  // Addition operations</div>
<div class="line"> </div>
<div class="line">  // result[i] = arg1[i] + arg2[i]</div>
<div class="line">  MyTensor add(const MyTensor&amp; arg1,</div>
<div class="line">               const MyTensor&amp; arg2);</div>
<div class="line">  // result[i] = (arg1[i] + arg2[i]) * factor</div>
<div class="line">  MyTensor add(const MyTensor&amp; arg1,</div>
<div class="line">               const MyTensor&amp; arg2,</div>
<div class="line">               const MyTensor::value_type factor);</div>
<div class="line">  // result[i] = arg[i] + value</div>
<div class="line">  MyTensor add(const MyTensor&amp; arg,</div>
<div class="line">               const MyTensor::value_type&amp; value);</div>
<div class="line"> </div>
<div class="line">  // result[perm ^ i] = arg1[i] + arg2[i]</div>
<div class="line">  MyTensor add(const MyTensor&amp; arg1,</div>
<div class="line">               const MyTensor&amp; arg2,</div>
<div class="line">               const TiledArray::Permutation&amp; perm);</div>
<div class="line">  // result[perm ^ i] = (arg1[i] + arg2[i]) * factor</div>
<div class="line">  MyTensor add(const MyTensor&amp; arg1,</div>
<div class="line">               const MyTensor&amp; arg2,</div>
<div class="line">               const MyTensor::numeric_type factor,</div>
<div class="line">               const TiledArray::Permutation&amp; perm);</div>
<div class="line">  // result[perm ^ i] = arg[i] + value</div>
<div class="line">  MyTensor add(const MyTensor&amp; arg,</div>
<div class="line">               const MyTensor::value_type&amp; value,</div>
<div class="line">               const TiledArray::Permutation&amp; perm);</div>
<div class="line"> </div>
<div class="line">  // result[i] += arg[i]</div>
<div class="line">  void add_to(MyTensor&amp; result,</div>
<div class="line">              const MyTensor&amp; arg);</div>
<div class="line">  // (result[i] += arg[i]) *= factor</div>
<div class="line">  void add_to(MyTensor&amp; result,</div>
<div class="line">              const MyTensor&amp; arg,</div>
<div class="line">              const MyTensor::numeric_type factor);</div>
<div class="line">  // result[i] += value</div>
<div class="line">  void add_to(MyTensor&amp; result,</div>
<div class="line">              const MyTensor::value_type&amp; value);</div>
<div class="line"> </div>
<div class="line">  // Subtraction operations</div>
<div class="line"> </div>
<div class="line">  // result[i] = arg1[i] - arg2[i]</div>
<div class="line">  MyTensor subt(const MyTensor&amp; arg1,</div>
<div class="line">                const MyTensor&amp; arg2);</div>
<div class="line">  // result[i] = (arg1[i] - arg2[i]) * factor</div>
<div class="line">  MyTensor subt(const MyTensor&amp; arg1,</div>
<div class="line">                const MyTensor&amp; arg2,</div>
<div class="line">                const MyTensor::numeric_type factor);</div>
<div class="line">  // result[i] = arg[i] - value</div>
<div class="line">  MyTensor subt(const MyTensor&amp; arg,</div>
<div class="line">                const MyTensor::value_type&amp; value);</div>
<div class="line"> </div>
<div class="line">  // result[perm ^ i] = arg1[i] - arg2[i]</div>
<div class="line">  MyTensor subt(const MyTensor&amp; arg1,</div>
<div class="line">                const MyTensor&amp; arg2,</div>
<div class="line">                const TiledArray::Permutation&amp; perm);</div>
<div class="line">  // result[perm ^ i] = (arg1[i] - arg2[i]) * factor</div>
<div class="line">  MyTensor subt(const MyTensor&amp; arg1,</div>
<div class="line">                const MyTensor&amp; arg2,</div>
<div class="line">                const MyTensor::numeric_type factor,</div>
<div class="line">                const TiledArray::Permutation&amp; perm);</div>
<div class="line">  // result[perm ^ i] = arg[i] - value</div>
<div class="line">  MyTensor subt(const MyTensor&amp; arg,</div>
<div class="line">                const MyTensor::value_type value,</div>
<div class="line">                const TiledArray::Permutation&amp; perm);</div>
<div class="line"> </div>
<div class="line">  // result[i] -= arg[i]</div>
<div class="line">  void subt_to(MyTensor&amp; result,</div>
<div class="line">               const MyTensor&amp; arg);</div>
<div class="line">  // (result[i] -= arg[i]) *= factor</div>
<div class="line">  void subt_to(MyTensor&amp; result,</div>
<div class="line">               const MyTensor&amp; arg,</div>
<div class="line">               const MyTensor::numeric_type factor);</div>
<div class="line">  // result[i] -= value</div>
<div class="line">  void subt_to(MyTensor&amp; result,</div>
<div class="line">               const MyTensor::value_type&amp; value);</div>
<div class="line"> </div>
<div class="line">  // (Entrywise) multiplication operations (Hadamard product)</div>
<div class="line"> </div>
<div class="line">  // result[i] = arg1[i] * arg2[i]</div>
<div class="line">  MyTensor mult(const MyTensor&amp; arg1,</div>
<div class="line">                const MyTensor&amp; arg2);</div>
<div class="line">  // result[i] = (arg1[i] * arg2[i]) * factor</div>
<div class="line">  MyTensor mult(const MyTensor&amp; arg1,</div>
<div class="line">                const MyTensor&amp; arg2,</div>
<div class="line">                const MyTensor::numeric_type factor);</div>
<div class="line"> </div>
<div class="line">  // result[perm ^ i] = arg1[i] * arg2[i]</div>
<div class="line">  MyTensor mult(const MyTensor&amp; arg1,</div>
<div class="line">                const MyTensor&amp; arg2,</div>
<div class="line">                const TiledArray::Permutation&amp; perm);</div>
<div class="line">  // result[perm^ i] = (arg1[i] * arg2[i]) * factor</div>
<div class="line">  MyTensor mult(const MyTensor&amp; arg1,</div>
<div class="line">                const MyTensor&amp; arg2,</div>
<div class="line">                const MyTensor::numeric_type factor,</div>
<div class="line">                const TiledArray::Permutation&amp; perm);</div>
<div class="line"> </div>
<div class="line">  // result[i] *= arg[i]</div>
<div class="line">  void mult_to(MyTensor&amp; result,</div>
<div class="line">               const MyTensor&amp; arg);</div>
<div class="line">  // (result[i] *= arg[i]) *= factor</div>
<div class="line">  void mult_to(MyTensor&amp; result,</div>
<div class="line">               const MyTensor&amp; arg,</div>
<div class="line">               const MyTensor::numeric_type factor);</div>
<div class="line"> </div>
<div class="line">  // Negation operations</div>
<div class="line"> </div>
<div class="line">  // result[i] = -(arg[i])</div>
<div class="line">  MyTensor neg(const MyTensor&amp; arg);</div>
<div class="line">  // result[perm ^ i] = -(arg[i])</div>
<div class="line">  MyTensor neg(const MyTensor&amp; arg,</div>
<div class="line">               const TiledArray::Permutation&amp; perm);</div>
<div class="line">  // result[i] = -(result[i])</div>
<div class="line">  void neg_to(MyTensor&amp; result);</div>
<div class="line"> </div>
<div class="line">  // Contraction operations</div>
<div class="line"> </div>
<div class="line">  // GEMM operation with fused indices as defined by gemm_config; multiply arg1 by arg2, return the result</div>
<div class="line">  MyTensor gemm(const MyTensor&amp; arg1,</div>
<div class="line">                const MyTensor&amp; arg2,</div>
<div class="line">                const MyTensor::numeric_type factor,</div>
<div class="line">                const TiledArray::math::GemmHelper&amp; gemm_config);</div>
<div class="line"> </div>
<div class="line">  // GEMM operation with fused indices as defined by gemm_config; multiply left by right, store to result</div>
<div class="line">  void gemm(MyTensor&amp; result,</div>
<div class="line">            const MyTensor&amp; arg1,</div>
<div class="line">            const MyTensor&amp; arg2,</div>
<div class="line">            const MyTensor::numeric_type factor,</div>
<div class="line">            const TiledArray::math::GemmHelper&amp; gemm_config);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  // Reduction operations</div>
<div class="line"> </div>
<div class="line">  // Sum of hyper diagonal elements</div>
<div class="line">  MyTensor::numeric_type trace(const MyTensor&amp; arg);</div>
<div class="line">  // foreach(i) result += arg[i]</div>
<div class="line">  MyTensor::numeric_type sum(const MyTensor&amp; arg);</div>
<div class="line">  // foreach(i) result *= arg[i]</div>
<div class="line">  MyTensor::numeric_type product(const MyTensor&amp; arg);</div>
<div class="line">  // foreach(i) result += arg[i] * arg[i]</div>
<div class="line">  MyTensor::numeric_type squared_norm(const MyTensor&amp; arg);</div>
<div class="line">  // sqrt(squared_norm(arg))</div>
<div class="line">  MyTensor::numeric_type norm(const MyTensor&amp; arg);</div>
<div class="line">  // foreach(i) result = max(result, arg[i])</div>
<div class="line">  MyTensor::numeric_type max(const MyTensor&amp; arg);</div>
<div class="line">  // foreach(i) result = min(result, arg[i])</div>
<div class="line">  MyTensor::numeric_type min(const MyTensor&amp; arg);</div>
<div class="line">  // foreach(i) result = max(result, abs(arg[i]))</div>
<div class="line">  MyTensor::numeric_type abs_max(const MyTensor&amp; arg);</div>
<div class="line">  // foreach(i) result = min(result, abs(arg[i]))</div>
<div class="line">  MyTensor::numeric_type abs_min(const MyTensor&amp; arg);</div>
</div><!-- fragment --><h2>User-Defined Lazy Tiles</h2>
<p>Lazy tiles are generated only when they are needed and discarded immediately after use. Common uses for lazy tiles include computing arrays on-the-fly, reading them from disk, etc. Lazy tiles are used internally by <code><a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations.">TiledArray::DistArray</a></code> to generate data tiles that are then fed into arithmetic operations.</p>
<p>The main requirements of lazy tiles are:</p>
<ol type="1">
<li><code>typedef ... eval_type</code>, which is the data tile type (e.g. <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object.">TiledArray::Tensor</a>).</li>
<li><code>eval_type</code> cannot be the same object type as the lazy tile itself.</li>
<li><code>explicit operator eval_type() const</code>, which is the function used to generate the data tile.</li>
</ol>
<p>Lazy tiles should have the following interface.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">class MyLazyTile {</div>
<div class="line">public:</div>
<div class="line">  typedef ... eval_type; // The data tile to which this tile will be converted to; typically TiledArray::Tensor</div>
<div class="line">                         // Can instead define TiledArray::eval_trait&lt;MyLazyTile&gt;::type</div>
<div class="line"> </div>
<div class="line">  // Default constructor</div>
<div class="line">  MyLazyTile();</div>
<div class="line"> </div>
<div class="line">  // Copy constructor</div>
<div class="line">  MyLazyTile(const MyLazyTile&amp; other);</div>
<div class="line"> </div>
<div class="line">  // Assignment operator</div>
<div class="line">  MyLazyTile&amp; operator=(const MyLazyTile&amp; other);</div>
<div class="line"> </div>
<div class="line">  // Convert lazy tile to data tile</div>
<div class="line">  explicit operator eval_type() const;</div>
<div class="line"> </div>
<div class="line">  // MADNESS compliant serialization</div>
<div class="line">  template &lt;typename Archive&gt;</div>
<div class="line">  void serialize(const Archive&amp;);</div>
<div class="line"> </div>
<div class="line">}; // class MyLazyTile</div>
</div><!-- fragment --><h1>User Defined Shapes</h1>
<p>You can define a shape object for your <code>Array</code> object, which defines the sparsity of an array. A shape object is a replicated object, so you should design your shape object accordingly. You may implement an initialization algorithm for your shape that communicates with other processes. However, communication is not allowed after the object has been initialized, shape arithmetic operations must be completely local (non-communicating) operations.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">class MyShape {</div>
<div class="line">public:</div>
<div class="line"> </div>
<div class="line">  // Return true if range matches the range of this shape</div>
<div class="line">  bool validate(const Range&amp; shape);</div>
<div class="line"> </div>
<div class="line">  // Returns true if the </div>
<div class="line">  template &lt;typename Index&gt;</div>
<div class="line">  bool is_zero(const Index&amp;);</div>
<div class="line"> </div>
<div class="line">  /// Returns true if this shape is dense.</div>
<div class="line">  bool is_dense();</div>
<div class="line"> </div>
<div class="line">  // Permute shape</div>
<div class="line">  MyShape perm(const TiledArray::Permutation&amp; perm);</div>
<div class="line"> </div>
<div class="line">  // Scale shape</div>
<div class="line">  template &lt;typename Scalar&gt;</div>
<div class="line">  MyShape scale(const Scalar factor);</div>
<div class="line"> </div>
<div class="line">  // Scale and permute shape</div>
<div class="line">  template &lt;typename Scalar&gt;</div>
<div class="line">  MyShape scale(const Scalar factor, const TiledArray::Permutation&amp; perm);</div>
<div class="line"> </div>
<div class="line">  // Add shapes</div>
<div class="line">  MyShape add(const MyShape&amp; right);</div>
<div class="line"> </div>
<div class="line">  // Add shapes and permute the result</div>
<div class="line">  MyShape add(const MyShape&amp; right, const TiledArray::Permutation&amp; perm);</div>
<div class="line"> </div>
<div class="line">  // Add and scale shapes</div>
<div class="line">  template &lt;typename Scalar&gt;</div>
<div class="line">  MyShape add(const MyShape&amp; right, const Scalar factor);</div>
<div class="line"> </div>
<div class="line">  // Add and scale shapes, and permute the result</div>
<div class="line">  template &lt;typename Scalar&gt;</div>
<div class="line">  MyShape add(const MyShape&amp; right, const Scalar factor, const TiledArray::Permutation&amp; perm);</div>
<div class="line"> </div>
<div class="line">  // Add a constant to a shape</div>
<div class="line">  template &lt;typename Scalar&gt;</div>
<div class="line">  MyShape add(const Scalar value)</div>
<div class="line"> </div>
<div class="line">  // Add a constant to and scale a shape, and permute the result</div>
<div class="line">  template &lt;typename Scalar&gt;</div>
<div class="line">  MyShape add(const Scalar value, const TiledArray::Permutation&amp; perm);</div>
<div class="line"> </div>
<div class="line">  // Subtract shapes</div>
<div class="line">  MyShape subt(const MyShape&amp; right);</div>
<div class="line"> </div>
<div class="line">  // Subtract shapes, and permute the result</div>
<div class="line">  MyShape subt(const MyShape&amp; right, const TiledArray::Permutation&amp; perm);</div>
<div class="line"> </div>
<div class="line">  // Subtract and scale shapes </div>
<div class="line">  template &lt;typename Scalar&gt;</div>
<div class="line">  MyShape subt(const MyShape&amp; right, const Scalar factor);</div>
<div class="line"> </div>
<div class="line">  // Subtract and scale shapes, and permute the result</div>
<div class="line">  template &lt;typename Scalar&gt;</div>
<div class="line">  MyShape subt(const MyShape&amp; right, const Scalar factor, const TiledArray::Permutation&amp; perm);</div>
<div class="line"> </div>
<div class="line">  // Subtract a constant value</div>
<div class="line">  template &lt;typename Scalar&gt;</div>
<div class="line">  MyShape subt(const Scalar value);</div>
<div class="line"> </div>
<div class="line">  // Subtract a constant value, and permute the result</div>
<div class="line">  template &lt;typename Scalar&gt;</div>
<div class="line">  MyShape subt(const Scalar value, const TiledArray::Permutation&amp; perm);</div>
<div class="line"> </div>
<div class="line">  // (Entrywise) multiplication of shapes</div>
<div class="line">  MyShape mult(const MyShape&amp; right);</div>
<div class="line"> </div>
<div class="line">  // (Entrywise) multiplication of shapes, followed by permutation</div>
<div class="line">  MyShape mult(const MyShape&amp; right, const TiledArray::Permutation&amp; perm);</div>
<div class="line"> </div>
<div class="line">  // (Entrywise) multiplication of shapes, followed by scaling</div>
<div class="line">  template &lt;typename Scalar&gt;</div>
<div class="line">  MyShape mult(const MyShape&amp; right, const Scalar factor);</div>
<div class="line"> </div>
<div class="line">  // (Entrywise) multiplication of shapes, followed by scaling, followed by permutation</div>
<div class="line">  template &lt;typename Scalar&gt;</div>
<div class="line">  MyShape mult(const MyShape&amp; right, const Scalar factor, const TiledArray::Permutation&amp; perm);</div>
<div class="line"> </div>
<div class="line">  // Contract and scale shapes</div>
<div class="line">  template &lt;typename Scalar&gt;</div>
<div class="line">  MyShape gemm(const MyShape&amp; right, const Scalar factor,</div>
<div class="line">      const TiledArray::math::GemmHelper&amp; gemm_helper);</div>
<div class="line"> </div>
<div class="line">  // Contract and scale shapes, and permute the result</div>
<div class="line">  template &lt;typename Scalar&gt;</div>
<div class="line">  MyShape gemm(const MyShape&amp; right, const Scalar factor, </div>
<div class="line">      const TiledArray::math::GemmHelper&amp; gemm_helper, const TiledArray::Permutation&amp; perm);</div>
<div class="line">}; // class MyShape</div>
</div><!-- fragment --><h1>User Defined Process Map</h1>
<p>You can also create process maps for your <code>Array</code> object, which is used by <a class="el" href="namespace_tiled_array.html">TiledArray</a> to determine the process that owns a tile for a given <code>Array</code> object. For a process map to be valid, all tiles are owned by exactly one process and all processes must agree on this tile ownership. The exception to these rules is a replicated process map. In addition, a process map must maintain a list of local tiles.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">class MyPmap : public TiledArray::Pmap {</div>
<div class="line">protected:</div>
<div class="line"> </div>
<div class="line">  // Import Pmap protected variables</div>
<div class="line">  using Pmap::rank_;  // The rank of this process</div>
<div class="line">  using Pmap::procs_; // The number of processes</div>
<div class="line">  using Pmap::size_;  // The number of tiles mapped among all processes</div>
<div class="line">  using Pmap::local_; // A list of local tiles (you must initialize this in the constructor)</div>
<div class="line"> </div>
<div class="line">public:</div>
<div class="line">  typedef Pmap::size_type size_type; // Key type</div>
<div class="line"> </div>
<div class="line">  // Constructor</div>
<div class="line">  MyPmap(madness::World&amp; world, size_type size);</div>
<div class="line"> </div>
<div class="line">  // Virtual destructor</div>
<div class="line">  virtual ~MyPmap();</div>
<div class="line"> </div>
<div class="line">  // Returns the process that owns tile</div>
<div class="line">  virtual size_type owner(const size_type tile) const;</div>
<div class="line"> </div>
<div class="line">  // Returns true if tile is owned by this process</div>
<div class="line">  virtual bool is_local(const size_type tile) const;</div>
<div class="line">}; // class MyPmap</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->

<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
    Generated at Wed Mar 4 2020 15:58:00 for <a href="https://https://github.com/ValeevGroup/tiledarray/">TiledArray</a>
    1.0.0-alpha.2 by &#160;<a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
<script type="text/javascript" src="doxy-boot.js"></script>
</html>
